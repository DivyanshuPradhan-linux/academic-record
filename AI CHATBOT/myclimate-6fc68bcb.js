( () => {
    var Gm = Object.create;
    var Ur = Object.defineProperty;
    var Qm = Object.getOwnPropertyDescriptor;
    var Jm = Object.getOwnPropertyNames;
    var Zm = Object.getPrototypeOf
      , tv = Object.prototype.hasOwnProperty;
    var o = (n, t) => Ur(n, "name", {
        value: t,
        configurable: !0
    });
    var ii = (n, t) => () => (n && (t = n(n = 0)),
    t);
    var Kr = (n, t) => () => (t || n((t = {
        exports: {}
    }).exports, t),
    t.exports)
      , Rt = (n, t) => {
        for (var e in t)
            Ur(n, e, {
                get: t[e],
                enumerable: !0
            })
    }
      , zd = (n, t, e, s) => {
        if (t && typeof t == "object" || typeof t == "function")
            for (let r of Jm(t))
                !tv.call(n, r) && r !== e && Ur(n, r, {
                    get: () => t[r],
                    enumerable: !(s = Qm(t, r)) || s.enumerable
                });
        return n
    }
    ;
    var Yr = (n, t, e) => (e = n != null ? Gm(Zm(n)) : {},
    zd(t || !n || !n.__esModule ? Ur(e, "default", {
        value: n,
        enumerable: !0
    }) : e, n))
      , Il = n => zd(Ur({}, "__esModule", {
        value: !0
    }), n);
    var Ws = Kr( (Ud, ta) => {
        (function(n, t) {
            "use strict";
            typeof ta == "object" && typeof ta.exports == "object" ? ta.exports = n.document ? t(n, !0) : function(e) {
                if (!e.document)
                    throw new Error("jQuery requires a window with a document");
                return t(e)
            }
            : t(n)
        }
        )(typeof window < "u" ? window : Ud, function(n, t) {
            "use strict";
            var e = []
              , s = Object.getPrototypeOf
              , r = e.slice
              , a = e.flat ? function(c) {
                return e.flat.call(c)
            }
            : function(c) {
                return e.concat.apply([], c)
            }
              , l = e.push
              , u = e.indexOf
              , d = {}
              , p = d.toString
              , b = d.hasOwnProperty
              , E = b.toString
              , x = E.call(Object)
              , w = {}
              , C = o(function(h) {
                return typeof h == "function" && typeof h.nodeType != "number" && typeof h.item != "function"
            }, "isFunction")
              , I = o(function(h) {
                return h != null && h === h.window
            }, "isWindow")
              , L = n.document
              , k = {
                type: !0,
                src: !0,
                nonce: !0,
                noModule: !0
            };
            function F(c, h, g) {
                g = g || L;
                var m, y, _ = g.createElement("script");
                if (_.text = c,
                h)
                    for (m in k)
                        y = h[m] || h.getAttribute && h.getAttribute(m),
                        y && _.setAttribute(m, y);
                g.head.appendChild(_).parentNode.removeChild(_)
            }
            o(F, "DOMEval");
            function z(c) {
                return c == null ? c + "" : typeof c == "object" || typeof c == "function" ? d[p.call(c)] || "object" : typeof c
            }
            o(z, "toType");
            var j = "3.7.1"
              , H = /HTML$/i
              , f = o(function(c, h) {
                return new f.fn.init(c,h)
            }, "jQuery");
            f.fn = f.prototype = {
                jquery: j,
                constructor: f,
                length: 0,
                toArray: o(function() {
                    return r.call(this)
                }, "toArray"),
                get: o(function(c) {
                    return c == null ? r.call(this) : c < 0 ? this[c + this.length] : this[c]
                }, "get"),
                pushStack: o(function(c) {
                    var h = f.merge(this.constructor(), c);
                    return h.prevObject = this,
                    h
                }, "pushStack"),
                each: o(function(c) {
                    return f.each(this, c)
                }, "each"),
                map: o(function(c) {
                    return this.pushStack(f.map(this, function(h, g) {
                        return c.call(h, g, h)
                    }))
                }, "map"),
                slice: o(function() {
                    return this.pushStack(r.apply(this, arguments))
                }, "slice"),
                first: o(function() {
                    return this.eq(0)
                }, "first"),
                last: o(function() {
                    return this.eq(-1)
                }, "last"),
                even: o(function() {
                    return this.pushStack(f.grep(this, function(c, h) {
                        return (h + 1) % 2
                    }))
                }, "even"),
                odd: o(function() {
                    return this.pushStack(f.grep(this, function(c, h) {
                        return h % 2
                    }))
                }, "odd"),
                eq: o(function(c) {
                    var h = this.length
                      , g = +c + (c < 0 ? h : 0);
                    return this.pushStack(g >= 0 && g < h ? [this[g]] : [])
                }, "eq"),
                end: o(function() {
                    return this.prevObject || this.constructor()
                }, "end"),
                push: l,
                sort: e.sort,
                splice: e.splice
            },
            f.extend = f.fn.extend = function() {
                var c, h, g, m, y, _, S = arguments[0] || {}, N = 1, D = arguments.length, q = !1;
                for (typeof S == "boolean" && (q = S,
                S = arguments[N] || {},
                N++),
                typeof S != "object" && !C(S) && (S = {}),
                N === D && (S = this,
                N--); N < D; N++)
                    if ((c = arguments[N]) != null)
                        for (h in c)
                            m = c[h],
                            !(h === "__proto__" || S === m) && (q && m && (f.isPlainObject(m) || (y = Array.isArray(m))) ? (g = S[h],
                            y && !Array.isArray(g) ? _ = [] : !y && !f.isPlainObject(g) ? _ = {} : _ = g,
                            y = !1,
                            S[h] = f.extend(q, _, m)) : m !== void 0 && (S[h] = m));
                return S
            }
            ,
            f.extend({
                expando: "jQuery" + (j + Math.random()).replace(/\D/g, ""),
                isReady: !0,
                error: o(function(c) {
                    throw new Error(c)
                }, "error"),
                noop: o(function() {}, "noop"),
                isPlainObject: o(function(c) {
                    var h, g;
                    return !c || p.call(c) !== "[object Object]" ? !1 : (h = s(c),
                    h ? (g = b.call(h, "constructor") && h.constructor,
                    typeof g == "function" && E.call(g) === x) : !0)
                }, "isPlainObject"),
                isEmptyObject: o(function(c) {
                    var h;
                    for (h in c)
                        return !1;
                    return !0
                }, "isEmptyObject"),
                globalEval: o(function(c, h, g) {
                    F(c, {
                        nonce: h && h.nonce
                    }, g)
                }, "globalEval"),
                each: o(function(c, h) {
                    var g, m = 0;
                    if (Y(c))
                        for (g = c.length; m < g && h.call(c[m], m, c[m]) !== !1; m++)
                            ;
                    else
                        for (m in c)
                            if (h.call(c[m], m, c[m]) === !1)
                                break;
                    return c
                }, "each"),
                text: o(function(c) {
                    var h, g = "", m = 0, y = c.nodeType;
                    if (!y)
                        for (; h = c[m++]; )
                            g += f.text(h);
                    return y === 1 || y === 11 ? c.textContent : y === 9 ? c.documentElement.textContent : y === 3 || y === 4 ? c.nodeValue : g
                }, "text"),
                makeArray: o(function(c, h) {
                    var g = h || [];
                    return c != null && (Y(Object(c)) ? f.merge(g, typeof c == "string" ? [c] : c) : l.call(g, c)),
                    g
                }, "makeArray"),
                inArray: o(function(c, h, g) {
                    return h == null ? -1 : u.call(h, c, g)
                }, "inArray"),
                isXMLDoc: o(function(c) {
                    var h = c && c.namespaceURI
                      , g = c && (c.ownerDocument || c).documentElement;
                    return !H.test(h || g && g.nodeName || "HTML")
                }, "isXMLDoc"),
                merge: o(function(c, h) {
                    for (var g = +h.length, m = 0, y = c.length; m < g; m++)
                        c[y++] = h[m];
                    return c.length = y,
                    c
                }, "merge"),
                grep: o(function(c, h, g) {
                    for (var m, y = [], _ = 0, S = c.length, N = !g; _ < S; _++)
                        m = !h(c[_], _),
                        m !== N && y.push(c[_]);
                    return y
                }, "grep"),
                map: o(function(c, h, g) {
                    var m, y, _ = 0, S = [];
                    if (Y(c))
                        for (m = c.length; _ < m; _++)
                            y = h(c[_], _, g),
                            y != null && S.push(y);
                    else
                        for (_ in c)
                            y = h(c[_], _, g),
                            y != null && S.push(y);
                    return a(S)
                }, "map"),
                guid: 1,
                support: w
            }),
            typeof Symbol == "function" && (f.fn[Symbol.iterator] = e[Symbol.iterator]),
            f.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(c, h) {
                d["[object " + h + "]"] = h.toLowerCase()
            });
            function Y(c) {
                var h = !!c && "length"in c && c.length
                  , g = z(c);
                return C(c) || I(c) ? !1 : g === "array" || h === 0 || typeof h == "number" && h > 0 && h - 1 in c
            }
            o(Y, "isArrayLike");
            function Q(c, h) {
                return c.nodeName && c.nodeName.toLowerCase() === h.toLowerCase()
            }
            o(Q, "nodeName");
            var ot = e.pop
              , mt = e.sort
              , bt = e.splice
              , ft = "[\\x20\\t\\r\\n\\f]"
              , $t = new RegExp("^" + ft + "+|((?:^|[^\\\\])(?:\\\\.)*)" + ft + "+$","g");
            f.contains = function(c, h) {
                var g = h && h.parentNode;
                return c === g || !!(g && g.nodeType === 1 && (c.contains ? c.contains(g) : c.compareDocumentPosition && c.compareDocumentPosition(g) & 16))
            }
            ;
            var Ut = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
            function wt(c, h) {
                return h ? c === "\0" ? "\uFFFD" : c.slice(0, -1) + "\\" + c.charCodeAt(c.length - 1).toString(16) + " " : "\\" + c
            }
            o(wt, "fcssescape"),
            f.escapeSelector = function(c) {
                return (c + "").replace(Ut, wt)
            }
            ;
            var Nt = L
              , Xt = l;
            (function() {
                var c, h, g, m, y, _ = Xt, S, N, D, q, tt, it = f.expando, G = 0, lt = 0, kt = Fs(), Wt = Fs(), Pt = Fs(), le = Fs(), ce = o(function(M, B) {
                    return M === B && (y = !0),
                    0
                }, "sortOrder"), Ze = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", fi = "(?:\\\\[\\da-fA-F]{1,6}" + ft + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", Bt = "\\[" + ft + "*(" + fi + ")(?:" + ft + "*([*^$|!~]?=)" + ft + `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + fi + "))|)" + ft + "*\\]", cn = ":(" + fi + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + Bt + ")*)|.*)\\)|)", qt = new RegExp(ft + "+","g"), oe = new RegExp("^" + ft + "*," + ft + "*"), Tn = new RegExp("^" + ft + "*([>+~]|" + ft + ")" + ft + "*"), un = new RegExp(ft + "|>"), pi = new RegExp(cn), es = new RegExp("^" + fi + "$"), gi = {
                    ID: new RegExp("^#(" + fi + ")"),
                    CLASS: new RegExp("^\\.(" + fi + ")"),
                    TAG: new RegExp("^(" + fi + "|[*])"),
                    ATTR: new RegExp("^" + Bt),
                    PSEUDO: new RegExp("^" + cn),
                    CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + ft + "*(even|odd|(([+-]|)(\\d*)n|)" + ft + "*(?:([+-]|)" + ft + "*(\\d+)|))" + ft + "*\\)|)","i"),
                    bool: new RegExp("^(?:" + Ze + ")$","i"),
                    needsContext: new RegExp("^" + ft + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + ft + "*((?:-\\d)?\\d*)" + ft + "*\\)|)(?=[^-]|$)","i")
                }, Hi = /^(?:input|select|textarea|button)$/i, ji = /^h\d$/i, je = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, Is = /[+~]/, Ce = new RegExp("\\\\[\\da-fA-F]{1,6}" + ft + "?|\\\\([^\\r\\n\\f])","g"), Ci = o(function(M, B) {
                    var K = "0x" + M.slice(1) - 65536;
                    return B || (K < 0 ? String.fromCharCode(K + 65536) : String.fromCharCode(K >> 10 | 55296, K & 1023 | 56320))
                }, "funescape"), Ns = o(function() {
                    We()
                }, "unloadHandler"), ti = Wi(function(M) {
                    return M.disabled === !0 && Q(M, "fieldset")
                }, {
                    dir: "parentNode",
                    next: "legend"
                });
                function kl() {
                    try {
                        return S.activeElement
                    } catch {}
                }
                o(kl, "safeActiveElement");
                try {
                    _.apply(e = r.call(Nt.childNodes), Nt.childNodes),
                    e[Nt.childNodes.length].nodeType
                } catch {
                    _ = {
                        apply: o(function(B, K) {
                            Xt.apply(B, r.call(K))
                        }, "apply"),
                        call: o(function(B) {
                            Xt.apply(B, r.call(arguments, 1))
                        }, "call")
                    }
                }
                function Kt(M, B, K, Z) {
                    var nt, ht, pt, Et, gt, Ft, Ct, At = B && B.ownerDocument, Vt = B ? B.nodeType : 9;
                    if (K = K || [],
                    typeof M != "string" || !M || Vt !== 1 && Vt !== 9 && Vt !== 11)
                        return K;
                    if (!Z && (We(B),
                    B = B || S,
                    D)) {
                        if (Vt !== 11 && (gt = je.exec(M)))
                            if (nt = gt[1]) {
                                if (Vt === 9)
                                    if (pt = B.getElementById(nt)) {
                                        if (pt.id === nt)
                                            return _.call(K, pt),
                                            K
                                    } else
                                        return K;
                                else if (At && (pt = At.getElementById(nt)) && Kt.contains(B, pt) && pt.id === nt)
                                    return _.call(K, pt),
                                    K
                            } else {
                                if (gt[2])
                                    return _.apply(K, B.getElementsByTagName(M)),
                                    K;
                                if ((nt = gt[3]) && B.getElementsByClassName)
                                    return _.apply(K, B.getElementsByClassName(nt)),
                                    K
                            }
                        if (!le[M + " "] && (!q || !q.test(M))) {
                            if (Ct = M,
                            At = B,
                            Vt === 1 && (un.test(M) || Tn.test(M))) {
                                for (At = Is.test(M) && Vr(B.parentNode) || B,
                                (At != B || !w.scope) && ((Et = B.getAttribute("id")) ? Et = f.escapeSelector(Et) : B.setAttribute("id", Et = it)),
                                Ft = is(M),
                                ht = Ft.length; ht--; )
                                    Ft[ht] = (Et ? "#" + Et : ":scope") + " " + Vs(Ft[ht]);
                                Ct = Ft.join(",")
                            }
                            try {
                                return _.apply(K, At.querySelectorAll(Ct)),
                                K
                            } catch {
                                le(M, !0)
                            } finally {
                                Et === it && B.removeAttribute("id")
                            }
                        }
                    }
                    return $e(M.replace($t, "$1"), B, K, Z)
                }
                o(Kt, "find");
                function Fs() {
                    var M = [];
                    function B(K, Z) {
                        return M.push(K + " ") > h.cacheLength && delete B[M.shift()],
                        B[K + " "] = Z
                    }
                    return o(B, "cache"),
                    B
                }
                o(Fs, "createCache");
                function ei(M) {
                    return M[it] = !0,
                    M
                }
                o(ei, "markFunction");
                function xn(M) {
                    var B = S.createElement("fieldset");
                    try {
                        return !!M(B)
                    } catch {
                        return !1
                    } finally {
                        B.parentNode && B.parentNode.removeChild(B),
                        B = null
                    }
                }
                o(xn, "assert");
                function Ml(M) {
                    return function(B) {
                        return Q(B, "input") && B.type === M
                    }
                }
                o(Ml, "createInputPseudo");
                function Ol(M) {
                    return function(B) {
                        return (Q(B, "input") || Q(B, "button")) && B.type === M
                    }
                }
                o(Ol, "createButtonPseudo");
                function wn(M) {
                    return function(B) {
                        return "form"in B ? B.parentNode && B.disabled === !1 ? "label"in B ? "label"in B.parentNode ? B.parentNode.disabled === M : B.disabled === M : B.isDisabled === M || B.isDisabled !== !M && ti(B) === M : B.disabled === M : "label"in B ? B.disabled === M : !1
                    }
                }
                o(wn, "createDisabledPseudo");
                function Ai(M) {
                    return ei(function(B) {
                        return B = +B,
                        ei(function(K, Z) {
                            for (var nt, ht = M([], K.length, B), pt = ht.length; pt--; )
                                K[nt = ht[pt]] && (K[nt] = !(Z[nt] = K[nt]))
                        })
                    })
                }
                o(Ai, "createPositionalPseudo");
                function Vr(M) {
                    return M && typeof M.getElementsByTagName < "u" && M
                }
                o(Vr, "testContext");
                function We(M) {
                    var B, K = M ? M.ownerDocument || M : Nt;
                    return K == S || K.nodeType !== 9 || !K.documentElement || (S = K,
                    N = S.documentElement,
                    D = !f.isXMLDoc(S),
                    tt = N.matches || N.webkitMatchesSelector || N.msMatchesSelector,
                    N.msMatchesSelector && Nt != S && (B = S.defaultView) && B.top !== B && B.addEventListener("unload", Ns),
                    w.getById = xn(function(Z) {
                        return N.appendChild(Z).id = f.expando,
                        !S.getElementsByName || !S.getElementsByName(f.expando).length
                    }),
                    w.disconnectedMatch = xn(function(Z) {
                        return tt.call(Z, "*")
                    }),
                    w.scope = xn(function() {
                        return S.querySelectorAll(":scope")
                    }),
                    w.cssHas = xn(function() {
                        try {
                            return S.querySelector(":has(*,:jqfake)"),
                            !1
                        } catch {
                            return !0
                        }
                    }),
                    w.getById ? (h.filter.ID = function(Z) {
                        var nt = Z.replace(Ce, Ci);
                        return function(ht) {
                            return ht.getAttribute("id") === nt
                        }
                    }
                    ,
                    h.find.ID = function(Z, nt) {
                        if (typeof nt.getElementById < "u" && D) {
                            var ht = nt.getElementById(Z);
                            return ht ? [ht] : []
                        }
                    }
                    ) : (h.filter.ID = function(Z) {
                        var nt = Z.replace(Ce, Ci);
                        return function(ht) {
                            var pt = typeof ht.getAttributeNode < "u" && ht.getAttributeNode("id");
                            return pt && pt.value === nt
                        }
                    }
                    ,
                    h.find.ID = function(Z, nt) {
                        if (typeof nt.getElementById < "u" && D) {
                            var ht, pt, Et, gt = nt.getElementById(Z);
                            if (gt) {
                                if (ht = gt.getAttributeNode("id"),
                                ht && ht.value === Z)
                                    return [gt];
                                for (Et = nt.getElementsByName(Z),
                                pt = 0; gt = Et[pt++]; )
                                    if (ht = gt.getAttributeNode("id"),
                                    ht && ht.value === Z)
                                        return [gt]
                            }
                            return []
                        }
                    }
                    ),
                    h.find.TAG = function(Z, nt) {
                        return typeof nt.getElementsByTagName < "u" ? nt.getElementsByTagName(Z) : nt.querySelectorAll(Z)
                    }
                    ,
                    h.find.CLASS = function(Z, nt) {
                        if (typeof nt.getElementsByClassName < "u" && D)
                            return nt.getElementsByClassName(Z)
                    }
                    ,
                    q = [],
                    xn(function(Z) {
                        var nt;
                        N.appendChild(Z).innerHTML = "<a id='" + it + "' href='' disabled='disabled'></a><select id='" + it + "-\r\\' disabled='disabled'><option selected=''></option></select>",
                        Z.querySelectorAll("[selected]").length || q.push("\\[" + ft + "*(?:value|" + Ze + ")"),
                        Z.querySelectorAll("[id~=" + it + "-]").length || q.push("~="),
                        Z.querySelectorAll("a#" + it + "+*").length || q.push(".#.+[+~]"),
                        Z.querySelectorAll(":checked").length || q.push(":checked"),
                        nt = S.createElement("input"),
                        nt.setAttribute("type", "hidden"),
                        Z.appendChild(nt).setAttribute("name", "D"),
                        N.appendChild(Z).disabled = !0,
                        Z.querySelectorAll(":disabled").length !== 2 && q.push(":enabled", ":disabled"),
                        nt = S.createElement("input"),
                        nt.setAttribute("name", ""),
                        Z.appendChild(nt),
                        Z.querySelectorAll("[name='']").length || q.push("\\[" + ft + "*name" + ft + "*=" + ft + `*(?:''|"")`)
                    }),
                    w.cssHas || q.push(":has"),
                    q = q.length && new RegExp(q.join("|")),
                    ce = o(function(Z, nt) {
                        if (Z === nt)
                            return y = !0,
                            0;
                        var ht = !Z.compareDocumentPosition - !nt.compareDocumentPosition;
                        return ht || (ht = (Z.ownerDocument || Z) == (nt.ownerDocument || nt) ? Z.compareDocumentPosition(nt) : 1,
                        ht & 1 || !w.sortDetached && nt.compareDocumentPosition(Z) === ht ? Z === S || Z.ownerDocument == Nt && Kt.contains(Nt, Z) ? -1 : nt === S || nt.ownerDocument == Nt && Kt.contains(Nt, nt) ? 1 : m ? u.call(m, Z) - u.call(m, nt) : 0 : ht & 4 ? -1 : 1)
                    }, "sortOrder")),
                    S
                }
                o(We, "setDocument"),
                Kt.matches = function(M, B) {
                    return Kt(M, null, null, B)
                }
                ,
                Kt.matchesSelector = function(M, B) {
                    if (We(M),
                    D && !le[B + " "] && (!q || !q.test(B)))
                        try {
                            var K = tt.call(M, B);
                            if (K || w.disconnectedMatch || M.document && M.document.nodeType !== 11)
                                return K
                        } catch {
                            le(B, !0)
                        }
                    return Kt(B, S, null, [M]).length > 0
                }
                ,
                Kt.contains = function(M, B) {
                    return (M.ownerDocument || M) != S && We(M),
                    f.contains(M, B)
                }
                ,
                Kt.attr = function(M, B) {
                    (M.ownerDocument || M) != S && We(M);
                    var K = h.attrHandle[B.toLowerCase()]
                      , Z = K && b.call(h.attrHandle, B.toLowerCase()) ? K(M, B, !D) : void 0;
                    return Z !== void 0 ? Z : M.getAttribute(B)
                }
                ,
                Kt.error = function(M) {
                    throw new Error("Syntax error, unrecognized expression: " + M)
                }
                ,
                f.uniqueSort = function(M) {
                    var B, K = [], Z = 0, nt = 0;
                    if (y = !w.sortStable,
                    m = !w.sortStable && r.call(M, 0),
                    mt.call(M, ce),
                    y) {
                        for (; B = M[nt++]; )
                            B === M[nt] && (Z = K.push(nt));
                        for (; Z--; )
                            bt.call(M, K[Z], 1)
                    }
                    return m = null,
                    M
                }
                ,
                f.fn.uniqueSort = function() {
                    return this.pushStack(f.uniqueSort(r.apply(this)))
                }
                ,
                h = f.expr = {
                    cacheLength: 50,
                    createPseudo: ei,
                    match: gi,
                    attrHandle: {},
                    find: {},
                    relative: {
                        ">": {
                            dir: "parentNode",
                            first: !0
                        },
                        " ": {
                            dir: "parentNode"
                        },
                        "+": {
                            dir: "previousSibling",
                            first: !0
                        },
                        "~": {
                            dir: "previousSibling"
                        }
                    },
                    preFilter: {
                        ATTR: o(function(M) {
                            return M[1] = M[1].replace(Ce, Ci),
                            M[3] = (M[3] || M[4] || M[5] || "").replace(Ce, Ci),
                            M[2] === "~=" && (M[3] = " " + M[3] + " "),
                            M.slice(0, 4)
                        }, "ATTR"),
                        CHILD: o(function(M) {
                            return M[1] = M[1].toLowerCase(),
                            M[1].slice(0, 3) === "nth" ? (M[3] || Kt.error(M[0]),
                            M[4] = +(M[4] ? M[5] + (M[6] || 1) : 2 * (M[3] === "even" || M[3] === "odd")),
                            M[5] = +(M[7] + M[8] || M[3] === "odd")) : M[3] && Kt.error(M[0]),
                            M
                        }, "CHILD"),
                        PSEUDO: o(function(M) {
                            var B, K = !M[6] && M[2];
                            return gi.CHILD.test(M[0]) ? null : (M[3] ? M[2] = M[4] || M[5] || "" : K && pi.test(K) && (B = is(K, !0)) && (B = K.indexOf(")", K.length - B) - K.length) && (M[0] = M[0].slice(0, B),
                            M[2] = K.slice(0, B)),
                            M.slice(0, 3))
                        }, "PSEUDO")
                    },
                    filter: {
                        TAG: o(function(M) {
                            var B = M.replace(Ce, Ci).toLowerCase();
                            return M === "*" ? function() {
                                return !0
                            }
                            : function(K) {
                                return Q(K, B)
                            }
                        }, "TAG"),
                        CLASS: o(function(M) {
                            var B = kt[M + " "];
                            return B || (B = new RegExp("(^|" + ft + ")" + M + "(" + ft + "|$)")) && kt(M, function(K) {
                                return B.test(typeof K.className == "string" && K.className || typeof K.getAttribute < "u" && K.getAttribute("class") || "")
                            })
                        }, "CLASS"),
                        ATTR: o(function(M, B, K) {
                            return function(Z) {
                                var nt = Kt.attr(Z, M);
                                return nt == null ? B === "!=" : B ? (nt += "",
                                B === "=" ? nt === K : B === "!=" ? nt !== K : B === "^=" ? K && nt.indexOf(K) === 0 : B === "*=" ? K && nt.indexOf(K) > -1 : B === "$=" ? K && nt.slice(-K.length) === K : B === "~=" ? (" " + nt.replace(qt, " ") + " ").indexOf(K) > -1 : B === "|=" ? nt === K || nt.slice(0, K.length + 1) === K + "-" : !1) : !0
                            }
                        }, "ATTR"),
                        CHILD: o(function(M, B, K, Z, nt) {
                            var ht = M.slice(0, 3) !== "nth"
                              , pt = M.slice(-4) !== "last"
                              , Et = B === "of-type";
                            return Z === 1 && nt === 0 ? function(gt) {
                                return !!gt.parentNode
                            }
                            : function(gt, Ft, Ct) {
                                var At, Vt, xt, Gt, De, Ee = ht !== pt ? "nextSibling" : "previousSibling", Ie = gt.parentNode, mi = Et && gt.nodeName.toLowerCase(), kn = !Ct && !Et, Ae = !1;
                                if (Ie) {
                                    if (ht) {
                                        for (; Ee; ) {
                                            for (xt = gt; xt = xt[Ee]; )
                                                if (Et ? Q(xt, mi) : xt.nodeType === 1)
                                                    return !1;
                                            De = Ee = M === "only" && !De && "nextSibling"
                                        }
                                        return !0
                                    }
                                    if (De = [pt ? Ie.firstChild : Ie.lastChild],
                                    pt && kn) {
                                        for (Vt = Ie[it] || (Ie[it] = {}),
                                        At = Vt[M] || [],
                                        Gt = At[0] === G && At[1],
                                        Ae = Gt && At[2],
                                        xt = Gt && Ie.childNodes[Gt]; xt = ++Gt && xt && xt[Ee] || (Ae = Gt = 0) || De.pop(); )
                                            if (xt.nodeType === 1 && ++Ae && xt === gt) {
                                                Vt[M] = [G, Gt, Ae];
                                                break
                                            }
                                    } else if (kn && (Vt = gt[it] || (gt[it] = {}),
                                    At = Vt[M] || [],
                                    Gt = At[0] === G && At[1],
                                    Ae = Gt),
                                    Ae === !1)
                                        for (; (xt = ++Gt && xt && xt[Ee] || (Ae = Gt = 0) || De.pop()) && !((Et ? Q(xt, mi) : xt.nodeType === 1) && ++Ae && (kn && (Vt = xt[it] || (xt[it] = {}),
                                        Vt[M] = [G, Ae]),
                                        xt === gt)); )
                                            ;
                                    return Ae -= nt,
                                    Ae === Z || Ae % Z === 0 && Ae / Z >= 0
                                }
                            }
                        }, "CHILD"),
                        PSEUDO: o(function(M, B) {
                            var K, Z = h.pseudos[M] || h.setFilters[M.toLowerCase()] || Kt.error("unsupported pseudo: " + M);
                            return Z[it] ? Z(B) : Z.length > 1 ? (K = [M, M, "", B],
                            h.setFilters.hasOwnProperty(M.toLowerCase()) ? ei(function(nt, ht) {
                                for (var pt, Et = Z(nt, B), gt = Et.length; gt--; )
                                    pt = u.call(nt, Et[gt]),
                                    nt[pt] = !(ht[pt] = Et[gt])
                            }) : function(nt) {
                                return Z(nt, 0, K)
                            }
                            ) : Z
                        }, "PSEUDO")
                    },
                    pseudos: {
                        not: ei(function(M) {
                            var B = []
                              , K = []
                              , Z = An(M.replace($t, "$1"));
                            return Z[it] ? ei(function(nt, ht, pt, Et) {
                                for (var gt, Ft = Z(nt, null, Et, []), Ct = nt.length; Ct--; )
                                    (gt = Ft[Ct]) && (nt[Ct] = !(ht[Ct] = gt))
                            }) : function(nt, ht, pt) {
                                return B[0] = nt,
                                Z(B, null, pt, K),
                                B[0] = null,
                                !K.pop()
                            }
                        }),
                        has: ei(function(M) {
                            return function(B) {
                                return Kt(M, B).length > 0
                            }
                        }),
                        contains: ei(function(M) {
                            return M = M.replace(Ce, Ci),
                            function(B) {
                                return (B.textContent || f.text(B)).indexOf(M) > -1
                            }
                        }),
                        lang: ei(function(M) {
                            return es.test(M || "") || Kt.error("unsupported lang: " + M),
                            M = M.replace(Ce, Ci).toLowerCase(),
                            function(B) {
                                var K;
                                do
                                    if (K = D ? B.lang : B.getAttribute("xml:lang") || B.getAttribute("lang"))
                                        return K = K.toLowerCase(),
                                        K === M || K.indexOf(M + "-") === 0;
                                while ((B = B.parentNode) && B.nodeType === 1);
                                return !1
                            }
                        }),
                        target: o(function(M) {
                            var B = n.location && n.location.hash;
                            return B && B.slice(1) === M.id
                        }, "target"),
                        root: o(function(M) {
                            return M === N
                        }, "root"),
                        focus: o(function(M) {
                            return M === kl() && S.hasFocus() && !!(M.type || M.href || ~M.tabIndex)
                        }, "focus"),
                        enabled: wn(!1),
                        disabled: wn(!0),
                        checked: o(function(M) {
                            return Q(M, "input") && !!M.checked || Q(M, "option") && !!M.selected
                        }, "checked"),
                        selected: o(function(M) {
                            return M.parentNode && M.parentNode.selectedIndex,
                            M.selected === !0
                        }, "selected"),
                        empty: o(function(M) {
                            for (M = M.firstChild; M; M = M.nextSibling)
                                if (M.nodeType < 6)
                                    return !1;
                            return !0
                        }, "empty"),
                        parent: o(function(M) {
                            return !h.pseudos.empty(M)
                        }, "parent"),
                        header: o(function(M) {
                            return ji.test(M.nodeName)
                        }, "header"),
                        input: o(function(M) {
                            return Hi.test(M.nodeName)
                        }, "input"),
                        button: o(function(M) {
                            return Q(M, "input") && M.type === "button" || Q(M, "button")
                        }, "button"),
                        text: o(function(M) {
                            var B;
                            return Q(M, "input") && M.type === "text" && ((B = M.getAttribute("type")) == null || B.toLowerCase() === "text")
                        }, "text"),
                        first: Ai(function() {
                            return [0]
                        }),
                        last: Ai(function(M, B) {
                            return [B - 1]
                        }),
                        eq: Ai(function(M, B, K) {
                            return [K < 0 ? K + B : K]
                        }),
                        even: Ai(function(M, B) {
                            for (var K = 0; K < B; K += 2)
                                M.push(K);
                            return M
                        }),
                        odd: Ai(function(M, B) {
                            for (var K = 1; K < B; K += 2)
                                M.push(K);
                            return M
                        }),
                        lt: Ai(function(M, B, K) {
                            var Z;
                            for (K < 0 ? Z = K + B : K > B ? Z = B : Z = K; --Z >= 0; )
                                M.push(Z);
                            return M
                        }),
                        gt: Ai(function(M, B, K) {
                            for (var Z = K < 0 ? K + B : K; ++Z < B; )
                                M.push(Z);
                            return M
                        })
                    }
                },
                h.pseudos.nth = h.pseudos.eq;
                for (c in {
                    radio: !0,
                    checkbox: !0,
                    file: !0,
                    password: !0,
                    image: !0
                })
                    h.pseudos[c] = Ml(c);
                for (c in {
                    submit: !0,
                    reset: !0
                })
                    h.pseudos[c] = Ol(c);
                function Cn() {}
                o(Cn, "setFilters"),
                Cn.prototype = h.filters = h.pseudos,
                h.setFilters = new Cn;
                function is(M, B) {
                    var K, Z, nt, ht, pt, Et, gt, Ft = Wt[M + " "];
                    if (Ft)
                        return B ? 0 : Ft.slice(0);
                    for (pt = M,
                    Et = [],
                    gt = h.preFilter; pt; ) {
                        (!K || (Z = oe.exec(pt))) && (Z && (pt = pt.slice(Z[0].length) || pt),
                        Et.push(nt = [])),
                        K = !1,
                        (Z = Tn.exec(pt)) && (K = Z.shift(),
                        nt.push({
                            value: K,
                            type: Z[0].replace($t, " ")
                        }),
                        pt = pt.slice(K.length));
                        for (ht in h.filter)
                            (Z = gi[ht].exec(pt)) && (!gt[ht] || (Z = gt[ht](Z))) && (K = Z.shift(),
                            nt.push({
                                value: K,
                                type: ht,
                                matches: Z
                            }),
                            pt = pt.slice(K.length));
                        if (!K)
                            break
                    }
                    return B ? pt.length : pt ? Kt.error(M) : Wt(M, Et).slice(0)
                }
                o(is, "tokenize");
                function Vs(M) {
                    for (var B = 0, K = M.length, Z = ""; B < K; B++)
                        Z += M[B].value;
                    return Z
                }
                o(Vs, "toSelector");
                function Wi(M, B, K) {
                    var Z = B.dir
                      , nt = B.next
                      , ht = nt || Z
                      , pt = K && ht === "parentNode"
                      , Et = lt++;
                    return B.first ? function(gt, Ft, Ct) {
                        for (; gt = gt[Z]; )
                            if (gt.nodeType === 1 || pt)
                                return M(gt, Ft, Ct);
                        return !1
                    }
                    : function(gt, Ft, Ct) {
                        var At, Vt, xt = [G, Et];
                        if (Ct) {
                            for (; gt = gt[Z]; )
                                if ((gt.nodeType === 1 || pt) && M(gt, Ft, Ct))
                                    return !0
                        } else
                            for (; gt = gt[Z]; )
                                if (gt.nodeType === 1 || pt)
                                    if (Vt = gt[it] || (gt[it] = {}),
                                    nt && Q(gt, nt))
                                        gt = gt[Z] || gt;
                                    else {
                                        if ((At = Vt[ht]) && At[0] === G && At[1] === Et)
                                            return xt[2] = At[2];
                                        if (Vt[ht] = xt,
                                        xt[2] = M(gt, Ft, Ct))
                                            return !0
                                    }
                        return !1
                    }
                }
                o(Wi, "addCombinator");
                function ns(M) {
                    return M.length > 1 ? function(B, K, Z) {
                        for (var nt = M.length; nt--; )
                            if (!M[nt](B, K, Z))
                                return !1;
                        return !0
                    }
                    : M[0]
                }
                o(ns, "elementMatcher");
                function Ll(M, B, K) {
                    for (var Z = 0, nt = B.length; Z < nt; Z++)
                        Kt(M, B[Z], K);
                    return K
                }
                o(Ll, "multipleContexts");
                function Bs(M, B, K, Z, nt) {
                    for (var ht, pt = [], Et = 0, gt = M.length, Ft = B != null; Et < gt; Et++)
                        (ht = M[Et]) && (!K || K(ht, Z, nt)) && (pt.push(ht),
                        Ft && B.push(Et));
                    return pt
                }
                o(Bs, "condense");
                function ki(M, B, K, Z, nt, ht) {
                    return Z && !Z[it] && (Z = ki(Z)),
                    nt && !nt[it] && (nt = ki(nt, ht)),
                    ei(function(pt, Et, gt, Ft) {
                        var Ct, At, Vt, xt, Gt = [], De = [], Ee = Et.length, Ie = pt || Ll(B || "*", gt.nodeType ? [gt] : gt, []), mi = M && (pt || !B) ? Bs(Ie, Gt, M, gt, Ft) : Ie;
                        if (K ? (xt = nt || (pt ? M : Ee || Z) ? [] : Et,
                        K(mi, xt, gt, Ft)) : xt = mi,
                        Z)
                            for (Ct = Bs(xt, De),
                            Z(Ct, [], gt, Ft),
                            At = Ct.length; At--; )
                                (Vt = Ct[At]) && (xt[De[At]] = !(mi[De[At]] = Vt));
                        if (pt) {
                            if (nt || M) {
                                if (nt) {
                                    for (Ct = [],
                                    At = xt.length; At--; )
                                        (Vt = xt[At]) && Ct.push(mi[At] = Vt);
                                    nt(null, xt = [], Ct, Ft)
                                }
                                for (At = xt.length; At--; )
                                    (Vt = xt[At]) && (Ct = nt ? u.call(pt, Vt) : Gt[At]) > -1 && (pt[Ct] = !(Et[Ct] = Vt))
                            }
                        } else
                            xt = Bs(xt === Et ? xt.splice(Ee, xt.length) : xt),
                            nt ? nt(null, Et, xt, Ft) : _.apply(Et, xt)
                    })
                }
                o(ki, "setMatcher");
                function $i(M) {
                    for (var B, K, Z, nt = M.length, ht = h.relative[M[0].type], pt = ht || h.relative[" "], Et = ht ? 1 : 0, gt = Wi(function(At) {
                        return At === B
                    }, pt, !0), Ft = Wi(function(At) {
                        return u.call(B, At) > -1
                    }, pt, !0), Ct = [function(At, Vt, xt) {
                        var Gt = !ht && (xt || Vt != g) || ((B = Vt).nodeType ? gt(At, Vt, xt) : Ft(At, Vt, xt));
                        return B = null,
                        Gt
                    }
                    ]; Et < nt; Et++)
                        if (K = h.relative[M[Et].type])
                            Ct = [Wi(ns(Ct), K)];
                        else {
                            if (K = h.filter[M[Et].type].apply(null, M[Et].matches),
                            K[it]) {
                                for (Z = ++Et; Z < nt && !h.relative[M[Z].type]; Z++)
                                    ;
                                return ki(Et > 1 && ns(Ct), Et > 1 && Vs(M.slice(0, Et - 1).concat({
                                    value: M[Et - 2].type === " " ? "*" : ""
                                })).replace($t, "$1"), K, Et < Z && $i(M.slice(Et, Z)), Z < nt && $i(M = M.slice(Z)), Z < nt && Vs(M))
                            }
                            Ct.push(K)
                        }
                    return ns(Ct)
                }
                o($i, "matcherFromTokens");
                function Dl(M, B) {
                    var K = B.length > 0
                      , Z = M.length > 0
                      , nt = o(function(ht, pt, Et, gt, Ft) {
                        var Ct, At, Vt, xt = 0, Gt = "0", De = ht && [], Ee = [], Ie = g, mi = ht || Z && h.find.TAG("*", Ft), kn = G += Ie == null ? 1 : Math.random() || .1, Ae = mi.length;
                        for (Ft && (g = pt == S || pt || Ft); Gt !== Ae && (Ct = mi[Gt]) != null; Gt++) {
                            if (Z && Ct) {
                                for (At = 0,
                                !pt && Ct.ownerDocument != S && (We(Ct),
                                Et = !D); Vt = M[At++]; )
                                    if (Vt(Ct, pt || S, Et)) {
                                        _.call(gt, Ct);
                                        break
                                    }
                                Ft && (G = kn)
                            }
                            K && ((Ct = !Vt && Ct) && xt--,
                            ht && De.push(Ct))
                        }
                        if (xt += Gt,
                        K && Gt !== xt) {
                            for (At = 0; Vt = B[At++]; )
                                Vt(De, Ee, pt, Et);
                            if (ht) {
                                if (xt > 0)
                                    for (; Gt--; )
                                        De[Gt] || Ee[Gt] || (Ee[Gt] = ot.call(gt));
                                Ee = Bs(Ee)
                            }
                            _.apply(gt, Ee),
                            Ft && !ht && Ee.length > 0 && xt + B.length > 1 && f.uniqueSort(gt)
                        }
                        return Ft && (G = kn,
                        g = Ie),
                        De
                    }, "superMatcher");
                    return K ? ei(nt) : nt
                }
                o(Dl, "matcherFromGroupMatchers");
                function An(M, B) {
                    var K, Z = [], nt = [], ht = Pt[M + " "];
                    if (!ht) {
                        for (B || (B = is(M)),
                        K = B.length; K--; )
                            ht = $i(B[K]),
                            ht[it] ? Z.push(ht) : nt.push(ht);
                        ht = Pt(M, Dl(nt, Z)),
                        ht.selector = M
                    }
                    return ht
                }
                o(An, "compile");
                function $e(M, B, K, Z) {
                    var nt, ht, pt, Et, gt, Ft = typeof M == "function" && M, Ct = !Z && is(M = Ft.selector || M);
                    if (K = K || [],
                    Ct.length === 1) {
                        if (ht = Ct[0] = Ct[0].slice(0),
                        ht.length > 2 && (pt = ht[0]).type === "ID" && B.nodeType === 9 && D && h.relative[ht[1].type]) {
                            if (B = (h.find.ID(pt.matches[0].replace(Ce, Ci), B) || [])[0],
                            B)
                                Ft && (B = B.parentNode);
                            else
                                return K;
                            M = M.slice(ht.shift().value.length)
                        }
                        for (nt = gi.needsContext.test(M) ? 0 : ht.length; nt-- && (pt = ht[nt],
                        !h.relative[Et = pt.type]); )
                            if ((gt = h.find[Et]) && (Z = gt(pt.matches[0].replace(Ce, Ci), Is.test(ht[0].type) && Vr(B.parentNode) || B))) {
                                if (ht.splice(nt, 1),
                                M = Z.length && Vs(ht),
                                !M)
                                    return _.apply(K, Z),
                                    K;
                                break
                            }
                    }
                    return (Ft || An(M, Ct))(Z, B, !D, K, !B || Is.test(M) && Vr(B.parentNode) || B),
                    K
                }
                o($e, "select"),
                w.sortStable = it.split("").sort(ce).join("") === it,
                We(),
                w.sortDetached = xn(function(M) {
                    return M.compareDocumentPosition(S.createElement("fieldset")) & 1
                }),
                f.find = Kt,
                f.expr[":"] = f.expr.pseudos,
                f.unique = f.uniqueSort,
                Kt.compile = An,
                Kt.select = $e,
                Kt.setDocument = We,
                Kt.tokenize = is,
                Kt.escape = f.escapeSelector,
                Kt.getText = f.text,
                Kt.isXML = f.isXMLDoc,
                Kt.selectors = f.expr,
                Kt.support = f.support,
                Kt.uniqueSort = f.uniqueSort
            }
            )();
            var pe = o(function(c, h, g) {
                for (var m = [], y = g !== void 0; (c = c[h]) && c.nodeType !== 9; )
                    if (c.nodeType === 1) {
                        if (y && f(c).is(g))
                            break;
                        m.push(c)
                    }
                return m
            }, "dir")
              , Ne = o(function(c, h) {
                for (var g = []; c; c = c.nextSibling)
                    c.nodeType === 1 && c !== h && g.push(c);
                return g
            }, "siblings")
              , xe = f.expr.match.needsContext
              , ci = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
            function re(c, h, g) {
                return C(h) ? f.grep(c, function(m, y) {
                    return !!h.call(m, y, m) !== g
                }) : h.nodeType ? f.grep(c, function(m) {
                    return m === h !== g
                }) : typeof h != "string" ? f.grep(c, function(m) {
                    return u.call(h, m) > -1 !== g
                }) : f.filter(h, c, g)
            }
            o(re, "winnow"),
            f.filter = function(c, h, g) {
                var m = h[0];
                return g && (c = ":not(" + c + ")"),
                h.length === 1 && m.nodeType === 1 ? f.find.matchesSelector(m, c) ? [m] : [] : f.find.matches(c, f.grep(h, function(y) {
                    return y.nodeType === 1
                }))
            }
            ,
            f.fn.extend({
                find: o(function(c) {
                    var h, g, m = this.length, y = this;
                    if (typeof c != "string")
                        return this.pushStack(f(c).filter(function() {
                            for (h = 0; h < m; h++)
                                if (f.contains(y[h], this))
                                    return !0
                        }));
                    for (g = this.pushStack([]),
                    h = 0; h < m; h++)
                        f.find(c, y[h], g);
                    return m > 1 ? f.uniqueSort(g) : g
                }, "find"),
                filter: o(function(c) {
                    return this.pushStack(re(this, c || [], !1))
                }, "filter"),
                not: o(function(c) {
                    return this.pushStack(re(this, c || [], !0))
                }, "not"),
                is: o(function(c) {
                    return !!re(this, typeof c == "string" && xe.test(c) ? f(c) : c || [], !1).length
                }, "is")
            });
            var Ke, Ye = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, Li = f.fn.init = function(c, h, g) {
                var m, y;
                if (!c)
                    return this;
                if (g = g || Ke,
                typeof c == "string")
                    if (c[0] === "<" && c[c.length - 1] === ">" && c.length >= 3 ? m = [null, c, null] : m = Ye.exec(c),
                    m && (m[1] || !h))
                        if (m[1]) {
                            if (h = h instanceof f ? h[0] : h,
                            f.merge(this, f.parseHTML(m[1], h && h.nodeType ? h.ownerDocument || h : L, !0)),
                            ci.test(m[1]) && f.isPlainObject(h))
                                for (m in h)
                                    C(this[m]) ? this[m](h[m]) : this.attr(m, h[m]);
                            return this
                        } else
                            return y = L.getElementById(m[2]),
                            y && (this[0] = y,
                            this.length = 1),
                            this;
                    else
                        return !h || h.jquery ? (h || g).find(c) : this.constructor(h).find(c);
                else {
                    if (c.nodeType)
                        return this[0] = c,
                        this.length = 1,
                        this;
                    if (C(c))
                        return g.ready !== void 0 ? g.ready(c) : c(f)
                }
                return f.makeArray(c, this)
            }
            ;
            Li.prototype = f.fn,
            Ke = f(L);
            var Di = /^(?:parents|prev(?:Until|All))/
              , xr = {
                children: !0,
                contents: !0,
                next: !0,
                prev: !0
            };
            f.fn.extend({
                has: o(function(c) {
                    var h = f(c, this)
                      , g = h.length;
                    return this.filter(function() {
                        for (var m = 0; m < g; m++)
                            if (f.contains(this, h[m]))
                                return !0
                    })
                }, "has"),
                closest: o(function(c, h) {
                    var g, m = 0, y = this.length, _ = [], S = typeof c != "string" && f(c);
                    if (!xe.test(c)) {
                        for (; m < y; m++)
                            for (g = this[m]; g && g !== h; g = g.parentNode)
                                if (g.nodeType < 11 && (S ? S.index(g) > -1 : g.nodeType === 1 && f.find.matchesSelector(g, c))) {
                                    _.push(g);
                                    break
                                }
                    }
                    return this.pushStack(_.length > 1 ? f.uniqueSort(_) : _)
                }, "closest"),
                index: o(function(c) {
                    return c ? typeof c == "string" ? u.call(f(c), this[0]) : u.call(this, c.jquery ? c[0] : c) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
                }, "index"),
                add: o(function(c, h) {
                    return this.pushStack(f.uniqueSort(f.merge(this.get(), f(c, h))))
                }, "add"),
                addBack: o(function(c) {
                    return this.add(c == null ? this.prevObject : this.prevObject.filter(c))
                }, "addBack")
            });
            function Un(c, h) {
                for (; (c = c[h]) && c.nodeType !== 1; )
                    ;
                return c
            }
            o(Un, "sibling"),
            f.each({
                parent: o(function(c) {
                    var h = c.parentNode;
                    return h && h.nodeType !== 11 ? h : null
                }, "parent"),
                parents: o(function(c) {
                    return pe(c, "parentNode")
                }, "parents"),
                parentsUntil: o(function(c, h, g) {
                    return pe(c, "parentNode", g)
                }, "parentsUntil"),
                next: o(function(c) {
                    return Un(c, "nextSibling")
                }, "next"),
                prev: o(function(c) {
                    return Un(c, "previousSibling")
                }, "prev"),
                nextAll: o(function(c) {
                    return pe(c, "nextSibling")
                }, "nextAll"),
                prevAll: o(function(c) {
                    return pe(c, "previousSibling")
                }, "prevAll"),
                nextUntil: o(function(c, h, g) {
                    return pe(c, "nextSibling", g)
                }, "nextUntil"),
                prevUntil: o(function(c, h, g) {
                    return pe(c, "previousSibling", g)
                }, "prevUntil"),
                siblings: o(function(c) {
                    return Ne((c.parentNode || {}).firstChild, c)
                }, "siblings"),
                children: o(function(c) {
                    return Ne(c.firstChild)
                }, "children"),
                contents: o(function(c) {
                    return c.contentDocument != null && s(c.contentDocument) ? c.contentDocument : (Q(c, "template") && (c = c.content || c),
                    f.merge([], c.childNodes))
                }, "contents")
            }, function(c, h) {
                f.fn[c] = function(g, m) {
                    var y = f.map(this, h, g);
                    return c.slice(-5) !== "Until" && (m = g),
                    m && typeof m == "string" && (y = f.filter(m, y)),
                    this.length > 1 && (xr[c] || f.uniqueSort(y),
                    Di.test(c) && y.reverse()),
                    this.pushStack(y)
                }
            });
            var ye = /[^\x20\t\r\n\f]+/g;
            function wr(c) {
                var h = {};
                return f.each(c.match(ye) || [], function(g, m) {
                    h[m] = !0
                }),
                h
            }
            o(wr, "createOptions"),
            f.Callbacks = function(c) {
                c = typeof c == "string" ? wr(c) : f.extend({}, c);
                var h, g, m, y, _ = [], S = [], N = -1, D = o(function() {
                    for (y = y || c.once,
                    m = h = !0; S.length; N = -1)
                        for (g = S.shift(); ++N < _.length; )
                            _[N].apply(g[0], g[1]) === !1 && c.stopOnFalse && (N = _.length,
                            g = !1);
                    c.memory || (g = !1),
                    h = !1,
                    y && (g ? _ = [] : _ = "")
                }, "fire"), q = {
                    add: o(function() {
                        return _ && (g && !h && (N = _.length - 1,
                        S.push(g)),
                        o((function tt(it) {
                            f.each(it, function(G, lt) {
                                C(lt) ? (!c.unique || !q.has(lt)) && _.push(lt) : lt && lt.length && z(lt) !== "string" && tt(lt)
                            })
                        }
                        ), "add")(arguments),
                        g && !h && D()),
                        this
                    }, "add"),
                    remove: o(function() {
                        return f.each(arguments, function(tt, it) {
                            for (var G; (G = f.inArray(it, _, G)) > -1; )
                                _.splice(G, 1),
                                G <= N && N--
                        }),
                        this
                    }, "remove"),
                    has: o(function(tt) {
                        return tt ? f.inArray(tt, _) > -1 : _.length > 0
                    }, "has"),
                    empty: o(function() {
                        return _ && (_ = []),
                        this
                    }, "empty"),
                    disable: o(function() {
                        return y = S = [],
                        _ = g = "",
                        this
                    }, "disable"),
                    disabled: o(function() {
                        return !_
                    }, "disabled"),
                    lock: o(function() {
                        return y = S = [],
                        !g && !h && (_ = g = ""),
                        this
                    }, "lock"),
                    locked: o(function() {
                        return !!y
                    }, "locked"),
                    fireWith: o(function(tt, it) {
                        return y || (it = it || [],
                        it = [tt, it.slice ? it.slice() : it],
                        S.push(it),
                        h || D()),
                        this
                    }, "fireWith"),
                    fire: o(function() {
                        return q.fireWith(this, arguments),
                        this
                    }, "fire"),
                    fired: o(function() {
                        return !!m
                    }, "fired")
                };
                return q
            }
            ;
            function ui(c) {
                return c
            }
            o(ui, "Identity");
            function Qi(c) {
                throw c
            }
            o(Qi, "Thrower");
            function Ts(c, h, g, m) {
                var y;
                try {
                    c && C(y = c.promise) ? y.call(c).done(h).fail(g) : c && C(y = c.then) ? y.call(c, h, g) : h.apply(void 0, [c].slice(m))
                } catch (_) {
                    g.apply(void 0, [_])
                }
            }
            o(Ts, "adoptValue"),
            f.extend({
                Deferred: o(function(c) {
                    var h = [["notify", "progress", f.Callbacks("memory"), f.Callbacks("memory"), 2], ["resolve", "done", f.Callbacks("once memory"), f.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", f.Callbacks("once memory"), f.Callbacks("once memory"), 1, "rejected"]]
                      , g = "pending"
                      , m = {
                        state: o(function() {
                            return g
                        }, "state"),
                        always: o(function() {
                            return y.done(arguments).fail(arguments),
                            this
                        }, "always"),
                        catch: o(function(_) {
                            return m.then(null, _)
                        }, "catch"),
                        pipe: o(function() {
                            var _ = arguments;
                            return f.Deferred(function(S) {
                                f.each(h, function(N, D) {
                                    var q = C(_[D[4]]) && _[D[4]];
                                    y[D[1]](function() {
                                        var tt = q && q.apply(this, arguments);
                                        tt && C(tt.promise) ? tt.promise().progress(S.notify).done(S.resolve).fail(S.reject) : S[D[0] + "With"](this, q ? [tt] : arguments)
                                    })
                                }),
                                _ = null
                            }).promise()
                        }, "pipe"),
                        then: o(function(_, S, N) {
                            var D = 0;
                            function q(tt, it, G, lt) {
                                return function() {
                                    var kt = this
                                      , Wt = arguments
                                      , Pt = o(function() {
                                        var ce, Ze;
                                        if (!(tt < D)) {
                                            if (ce = G.apply(kt, Wt),
                                            ce === it.promise())
                                                throw new TypeError("Thenable self-resolution");
                                            Ze = ce && (typeof ce == "object" || typeof ce == "function") && ce.then,
                                            C(Ze) ? lt ? Ze.call(ce, q(D, it, ui, lt), q(D, it, Qi, lt)) : (D++,
                                            Ze.call(ce, q(D, it, ui, lt), q(D, it, Qi, lt), q(D, it, ui, it.notifyWith))) : (G !== ui && (kt = void 0,
                                            Wt = [ce]),
                                            (lt || it.resolveWith)(kt, Wt))
                                        }
                                    }, "mightThrow")
                                      , le = lt ? Pt : function() {
                                        try {
                                            Pt()
                                        } catch (ce) {
                                            f.Deferred.exceptionHook && f.Deferred.exceptionHook(ce, le.error),
                                            tt + 1 >= D && (G !== Qi && (kt = void 0,
                                            Wt = [ce]),
                                            it.rejectWith(kt, Wt))
                                        }
                                    }
                                    ;
                                    tt ? le() : (f.Deferred.getErrorHook ? le.error = f.Deferred.getErrorHook() : f.Deferred.getStackHook && (le.error = f.Deferred.getStackHook()),
                                    n.setTimeout(le))
                                }
                            }
                            return o(q, "resolve"),
                            f.Deferred(function(tt) {
                                h[0][3].add(q(0, tt, C(N) ? N : ui, tt.notifyWith)),
                                h[1][3].add(q(0, tt, C(_) ? _ : ui)),
                                h[2][3].add(q(0, tt, C(S) ? S : Qi))
                            }).promise()
                        }, "then"),
                        promise: o(function(_) {
                            return _ != null ? f.extend(_, m) : m
                        }, "promise")
                    }
                      , y = {};
                    return f.each(h, function(_, S) {
                        var N = S[2]
                          , D = S[5];
                        m[S[1]] = N.add,
                        D && N.add(function() {
                            g = D
                        }, h[3 - _][2].disable, h[3 - _][3].disable, h[0][2].lock, h[0][3].lock),
                        N.add(S[3].fire),
                        y[S[0]] = function() {
                            return y[S[0] + "With"](this === y ? void 0 : this, arguments),
                            this
                        }
                        ,
                        y[S[0] + "With"] = N.fireWith
                    }),
                    m.promise(y),
                    c && c.call(y, y),
                    y
                }, "Deferred"),
                when: o(function(c) {
                    var h = arguments.length
                      , g = h
                      , m = Array(g)
                      , y = r.call(arguments)
                      , _ = f.Deferred()
                      , S = o(function(N) {
                        return function(D) {
                            m[N] = this,
                            y[N] = arguments.length > 1 ? r.call(arguments) : D,
                            --h || _.resolveWith(m, y)
                        }
                    }, "updateFunc");
                    if (h <= 1 && (Ts(c, _.done(S(g)).resolve, _.reject, !h),
                    _.state() === "pending" || C(y[g] && y[g].then)))
                        return _.then();
                    for (; g--; )
                        Ts(y[g], S(g), _.reject);
                    return _.promise()
                }, "when")
            });
            var Cr = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
            f.Deferred.exceptionHook = function(c, h) {
                n.console && n.console.warn && c && Cr.test(c.name) && n.console.warn("jQuery.Deferred exception: " + c.message, c.stack, h)
            }
            ,
            f.readyException = function(c) {
                n.setTimeout(function() {
                    throw c
                })
            }
            ;
            var Ei = f.Deferred();
            f.fn.ready = function(c) {
                return Ei.then(c).catch(function(h) {
                    f.readyException(h)
                }),
                this
            }
            ,
            f.extend({
                isReady: !1,
                readyWait: 1,
                ready: o(function(c) {
                    (c === !0 ? --f.readyWait : f.isReady) || (f.isReady = !0,
                    !(c !== !0 && --f.readyWait > 0) && Ei.resolveWith(L, [f]))
                }, "ready")
            }),
            f.ready.then = Ei.then;
            function Xe() {
                L.removeEventListener("DOMContentLoaded", Xe),
                n.removeEventListener("load", Xe),
                f.ready()
            }
            o(Xe, "completed"),
            L.readyState === "complete" || L.readyState !== "loading" && !L.documentElement.doScroll ? n.setTimeout(f.ready) : (L.addEventListener("DOMContentLoaded", Xe),
            n.addEventListener("load", Xe));
            var Re = o(function(c, h, g, m, y, _, S) {
                var N = 0
                  , D = c.length
                  , q = g == null;
                if (z(g) === "object") {
                    y = !0;
                    for (N in g)
                        Re(c, h, N, g[N], !0, _, S)
                } else if (m !== void 0 && (y = !0,
                C(m) || (S = !0),
                q && (S ? (h.call(c, m),
                h = null) : (q = h,
                h = o(function(tt, it, G) {
                    return q.call(f(tt), G)
                }, "fn"))),
                h))
                    for (; N < D; N++)
                        h(c[N], g, S ? m : m.call(c[N], N, h(c[N], g)));
                return y ? c : q ? h.call(c) : D ? h(c[0], g) : _
            }, "access")
              , Si = /^-ms-/
              , _e = /-([a-z])/g;
            function xs(c, h) {
                return h.toUpperCase()
            }
            o(xs, "fcamelCase");
            function Fe(c) {
                return c.replace(Si, "ms-").replace(_e, xs)
            }
            o(Fe, "camelCase");
            var Ji = o(function(c) {
                return c.nodeType === 1 || c.nodeType === 9 || !+c.nodeType
            }, "acceptData");
            function Zi() {
                this.expando = f.expando + Zi.uid++
            }
            o(Zi, "Data"),
            Zi.uid = 1,
            Zi.prototype = {
                cache: o(function(c) {
                    var h = c[this.expando];
                    return h || (h = {},
                    Ji(c) && (c.nodeType ? c[this.expando] = h : Object.defineProperty(c, this.expando, {
                        value: h,
                        configurable: !0
                    }))),
                    h
                }, "cache"),
                set: o(function(c, h, g) {
                    var m, y = this.cache(c);
                    if (typeof h == "string")
                        y[Fe(h)] = g;
                    else
                        for (m in h)
                            y[Fe(m)] = h[m];
                    return y
                }, "set"),
                get: o(function(c, h) {
                    return h === void 0 ? this.cache(c) : c[this.expando] && c[this.expando][Fe(h)]
                }, "get"),
                access: o(function(c, h, g) {
                    return h === void 0 || h && typeof h == "string" && g === void 0 ? this.get(c, h) : (this.set(c, h, g),
                    g !== void 0 ? g : h)
                }, "access"),
                remove: o(function(c, h) {
                    var g, m = c[this.expando];
                    if (m !== void 0) {
                        if (h !== void 0)
                            for (Array.isArray(h) ? h = h.map(Fe) : (h = Fe(h),
                            h = h in m ? [h] : h.match(ye) || []),
                            g = h.length; g--; )
                                delete m[h[g]];
                        (h === void 0 || f.isEmptyObject(m)) && (c.nodeType ? c[this.expando] = void 0 : delete c[this.expando])
                    }
                }, "remove"),
                hasData: o(function(c) {
                    var h = c[this.expando];
                    return h !== void 0 && !f.isEmptyObject(h)
                }, "hasData")
            };
            var St = new Zi
              , me = new Zi
              , Kn = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/
              , Ar = /[A-Z]/g;
            function tn(c) {
                return c === "true" ? !0 : c === "false" ? !1 : c === "null" ? null : c === +c + "" ? +c : Kn.test(c) ? JSON.parse(c) : c
            }
            o(tn, "getData");
            function Ti(c, h, g) {
                var m;
                if (g === void 0 && c.nodeType === 1)
                    if (m = "data-" + h.replace(Ar, "-$&").toLowerCase(),
                    g = c.getAttribute(m),
                    typeof g == "string") {
                        try {
                            g = tn(g)
                        } catch {}
                        me.set(c, h, g)
                    } else
                        g = void 0;
                return g
            }
            o(Ti, "dataAttr"),
            f.extend({
                hasData: o(function(c) {
                    return me.hasData(c) || St.hasData(c)
                }, "hasData"),
                data: o(function(c, h, g) {
                    return me.access(c, h, g)
                }, "data"),
                removeData: o(function(c, h) {
                    me.remove(c, h)
                }, "removeData"),
                _data: o(function(c, h, g) {
                    return St.access(c, h, g)
                }, "_data"),
                _removeData: o(function(c, h) {
                    St.remove(c, h)
                }, "_removeData")
            }),
            f.fn.extend({
                data: o(function(c, h) {
                    var g, m, y, _ = this[0], S = _ && _.attributes;
                    if (c === void 0) {
                        if (this.length && (y = me.get(_),
                        _.nodeType === 1 && !St.get(_, "hasDataAttrs"))) {
                            for (g = S.length; g--; )
                                S[g] && (m = S[g].name,
                                m.indexOf("data-") === 0 && (m = Fe(m.slice(5)),
                                Ti(_, m, y[m])));
                            St.set(_, "hasDataAttrs", !0)
                        }
                        return y
                    }
                    return typeof c == "object" ? this.each(function() {
                        me.set(this, c)
                    }) : Re(this, function(N) {
                        var D;
                        if (_ && N === void 0)
                            return D = me.get(_, c),
                            D !== void 0 || (D = Ti(_, c),
                            D !== void 0) ? D : void 0;
                        this.each(function() {
                            me.set(this, c, N)
                        })
                    }, null, h, arguments.length > 1, null, !0)
                }, "data"),
                removeData: o(function(c) {
                    return this.each(function() {
                        me.remove(this, c)
                    })
                }, "removeData")
            }),
            f.extend({
                queue: o(function(c, h, g) {
                    var m;
                    if (c)
                        return h = (h || "fx") + "queue",
                        m = St.get(c, h),
                        g && (!m || Array.isArray(g) ? m = St.access(c, h, f.makeArray(g)) : m.push(g)),
                        m || []
                }, "queue"),
                dequeue: o(function(c, h) {
                    h = h || "fx";
                    var g = f.queue(c, h)
                      , m = g.length
                      , y = g.shift()
                      , _ = f._queueHooks(c, h)
                      , S = o(function() {
                        f.dequeue(c, h)
                    }, "next");
                    y === "inprogress" && (y = g.shift(),
                    m--),
                    y && (h === "fx" && g.unshift("inprogress"),
                    delete _.stop,
                    y.call(c, S, _)),
                    !m && _ && _.empty.fire()
                }, "dequeue"),
                _queueHooks: o(function(c, h) {
                    var g = h + "queueHooks";
                    return St.get(c, g) || St.access(c, g, {
                        empty: f.Callbacks("once memory").add(function() {
                            St.remove(c, [h + "queue", g])
                        })
                    })
                }, "_queueHooks")
            }),
            f.fn.extend({
                queue: o(function(c, h) {
                    var g = 2;
                    return typeof c != "string" && (h = c,
                    c = "fx",
                    g--),
                    arguments.length < g ? f.queue(this[0], c) : h === void 0 ? this : this.each(function() {
                        var m = f.queue(this, c, h);
                        f._queueHooks(this, c),
                        c === "fx" && m[0] !== "inprogress" && f.dequeue(this, c)
                    })
                }, "queue"),
                dequeue: o(function(c) {
                    return this.each(function() {
                        f.dequeue(this, c)
                    })
                }, "dequeue"),
                clearQueue: o(function(c) {
                    return this.queue(c || "fx", [])
                }, "clearQueue"),
                promise: o(function(c, h) {
                    var g, m = 1, y = f.Deferred(), _ = this, S = this.length, N = o(function() {
                        --m || y.resolveWith(_, [_])
                    }, "resolve");
                    for (typeof c != "string" && (h = c,
                    c = void 0),
                    c = c || "fx"; S--; )
                        g = St.get(_[S], c + "queueHooks"),
                        g && g.empty && (m++,
                        g.empty.add(N));
                    return N(),
                    y.promise(h)
                }, "promise")
            });
            var Yn = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source
              , xi = new RegExp("^(?:([+-])=|)(" + Yn + ")([a-z%]*)$","i")
              , Ge = ["Top", "Right", "Bottom", "Left"]
              , hi = L.documentElement
              , Pi = o(function(c) {
                return f.contains(c.ownerDocument, c)
            }, "isAttached")
              , kr = {
                composed: !0
            };
            hi.getRootNode && (Pi = o(function(c) {
                return f.contains(c.ownerDocument, c) || c.getRootNode(kr) === c.ownerDocument
            }, "isAttached"));
            var yn = o(function(c, h) {
                return c = h || c,
                c.style.display === "none" || c.style.display === "" && Pi(c) && f.css(c, "display") === "none"
            }, "isHiddenWithinTree");
            function ws(c, h, g, m) {
                var y, _, S = 20, N = m ? function() {
                    return m.cur()
                }
                : function() {
                    return f.css(c, h, "")
                }
                , D = N(), q = g && g[3] || (f.cssNumber[h] ? "" : "px"), tt = c.nodeType && (f.cssNumber[h] || q !== "px" && +D) && xi.exec(f.css(c, h));
                if (tt && tt[3] !== q) {
                    for (D = D / 2,
                    q = q || tt[3],
                    tt = +D || 1; S--; )
                        f.style(c, h, tt + q),
                        (1 - _) * (1 - (_ = N() / D || .5)) <= 0 && (S = 0),
                        tt = tt / _;
                    tt = tt * 2,
                    f.style(c, h, tt + q),
                    g = g || []
                }
                return g && (tt = +tt || +D || 0,
                y = g[1] ? tt + (g[1] + 1) * g[2] : +g[2],
                m && (m.unit = q,
                m.start = tt,
                m.end = y)),
                y
            }
            o(ws, "adjustCSS");
            var Cs = {};
            function Mr(c) {
                var h, g = c.ownerDocument, m = c.nodeName, y = Cs[m];
                return y || (h = g.body.appendChild(g.createElement(m)),
                y = f.css(h, "display"),
                h.parentNode.removeChild(h),
                y === "none" && (y = "block"),
                Cs[m] = y,
                y)
            }
            o(Mr, "getDefaultDisplay");
            function Ri(c, h) {
                for (var g, m, y = [], _ = 0, S = c.length; _ < S; _++)
                    m = c[_],
                    m.style && (g = m.style.display,
                    h ? (g === "none" && (y[_] = St.get(m, "display") || null,
                    y[_] || (m.style.display = "")),
                    m.style.display === "" && yn(m) && (y[_] = Mr(m))) : g !== "none" && (y[_] = "none",
                    St.set(m, "display", g)));
                for (_ = 0; _ < S; _++)
                    y[_] != null && (c[_].style.display = y[_]);
                return c
            }
            o(Ri, "showHide"),
            f.fn.extend({
                show: o(function() {
                    return Ri(this, !0)
                }, "show"),
                hide: o(function() {
                    return Ri(this)
                }, "hide"),
                toggle: o(function(c) {
                    return typeof c == "boolean" ? c ? this.show() : this.hide() : this.each(function() {
                        yn(this) ? f(this).show() : f(this).hide()
                    })
                }, "toggle")
            });
            var en = /^(?:checkbox|radio)$/i
              , As = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i
              , nn = /^$|^module$|\/(?:java|ecma)script/i;
            (function() {
                var c = L.createDocumentFragment()
                  , h = c.appendChild(L.createElement("div"))
                  , g = L.createElement("input");
                g.setAttribute("type", "radio"),
                g.setAttribute("checked", "checked"),
                g.setAttribute("name", "t"),
                h.appendChild(g),
                w.checkClone = h.cloneNode(!0).cloneNode(!0).lastChild.checked,
                h.innerHTML = "<textarea>x</textarea>",
                w.noCloneChecked = !!h.cloneNode(!0).lastChild.defaultValue,
                h.innerHTML = "<option></option>",
                w.option = !!h.lastChild
            }
            )();
            var T = {
                thead: [1, "<table>", "</table>"],
                col: [2, "<table><colgroup>", "</colgroup></table>"],
                tr: [2, "<table><tbody>", "</tbody></table>"],
                td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
                _default: [0, "", ""]
            };
            T.tbody = T.tfoot = T.colgroup = T.caption = T.thead,
            T.th = T.td,
            w.option || (T.optgroup = T.option = [1, "<select multiple='multiple'>", "</select>"]);
            function R(c, h) {
                var g;
                return typeof c.getElementsByTagName < "u" ? g = c.getElementsByTagName(h || "*") : typeof c.querySelectorAll < "u" ? g = c.querySelectorAll(h || "*") : g = [],
                h === void 0 || h && Q(c, h) ? f.merge([c], g) : g
            }
            o(R, "getAll");
            function W(c, h) {
                for (var g = 0, m = c.length; g < m; g++)
                    St.set(c[g], "globalEval", !h || St.get(h[g], "globalEval"))
            }
            o(W, "setGlobalEval");
            var U = /<|&#?\w+;/;
            function rt(c, h, g, m, y) {
                for (var _, S, N, D, q, tt, it = h.createDocumentFragment(), G = [], lt = 0, kt = c.length; lt < kt; lt++)
                    if (_ = c[lt],
                    _ || _ === 0)
                        if (z(_) === "object")
                            f.merge(G, _.nodeType ? [_] : _);
                        else if (!U.test(_))
                            G.push(h.createTextNode(_));
                        else {
                            for (S = S || it.appendChild(h.createElement("div")),
                            N = (As.exec(_) || ["", ""])[1].toLowerCase(),
                            D = T[N] || T._default,
                            S.innerHTML = D[1] + f.htmlPrefilter(_) + D[2],
                            tt = D[0]; tt--; )
                                S = S.lastChild;
                            f.merge(G, S.childNodes),
                            S = it.firstChild,
                            S.textContent = ""
                        }
                for (it.textContent = "",
                lt = 0; _ = G[lt++]; ) {
                    if (m && f.inArray(_, m) > -1) {
                        y && y.push(_);
                        continue
                    }
                    if (q = Pi(_),
                    S = R(it.appendChild(_), "script"),
                    q && W(S),
                    g)
                        for (tt = 0; _ = S[tt++]; )
                            nn.test(_.type || "") && g.push(_)
                }
                return it
            }
            o(rt, "buildFragment");
            var st = /^([^.]*)(?:\.(.+)|)/;
            function at() {
                return !0
            }
            o(at, "returnTrue");
            function ut() {
                return !1
            }
            o(ut, "returnFalse");
            function dt(c, h, g, m, y, _) {
                var S, N;
                if (typeof h == "object") {
                    typeof g != "string" && (m = m || g,
                    g = void 0);
                    for (N in h)
                        dt(c, N, g, m, h[N], _);
                    return c
                }
                if (m == null && y == null ? (y = g,
                m = g = void 0) : y == null && (typeof g == "string" ? (y = m,
                m = void 0) : (y = m,
                m = g,
                g = void 0)),
                y === !1)
                    y = ut;
                else if (!y)
                    return c;
                return _ === 1 && (S = y,
                y = o(function(D) {
                    return f().off(D),
                    S.apply(this, arguments)
                }, "fn"),
                y.guid = S.guid || (S.guid = f.guid++)),
                c.each(function() {
                    f.event.add(this, h, y, m, g)
                })
            }
            o(dt, "on"),
            f.event = {
                global: {},
                add: o(function(c, h, g, m, y) {
                    var _, S, N, D, q, tt, it, G, lt, kt, Wt, Pt = St.get(c);
                    if (Ji(c))
                        for (g.handler && (_ = g,
                        g = _.handler,
                        y = _.selector),
                        y && f.find.matchesSelector(hi, y),
                        g.guid || (g.guid = f.guid++),
                        (D = Pt.events) || (D = Pt.events = Object.create(null)),
                        (S = Pt.handle) || (S = Pt.handle = function(le) {
                            return typeof f < "u" && f.event.triggered !== le.type ? f.event.dispatch.apply(c, arguments) : void 0
                        }
                        ),
                        h = (h || "").match(ye) || [""],
                        q = h.length; q--; )
                            N = st.exec(h[q]) || [],
                            lt = Wt = N[1],
                            kt = (N[2] || "").split(".").sort(),
                            lt && (it = f.event.special[lt] || {},
                            lt = (y ? it.delegateType : it.bindType) || lt,
                            it = f.event.special[lt] || {},
                            tt = f.extend({
                                type: lt,
                                origType: Wt,
                                data: m,
                                handler: g,
                                guid: g.guid,
                                selector: y,
                                needsContext: y && f.expr.match.needsContext.test(y),
                                namespace: kt.join(".")
                            }, _),
                            (G = D[lt]) || (G = D[lt] = [],
                            G.delegateCount = 0,
                            (!it.setup || it.setup.call(c, m, kt, S) === !1) && c.addEventListener && c.addEventListener(lt, S)),
                            it.add && (it.add.call(c, tt),
                            tt.handler.guid || (tt.handler.guid = g.guid)),
                            y ? G.splice(G.delegateCount++, 0, tt) : G.push(tt),
                            f.event.global[lt] = !0)
                }, "add"),
                remove: o(function(c, h, g, m, y) {
                    var _, S, N, D, q, tt, it, G, lt, kt, Wt, Pt = St.hasData(c) && St.get(c);
                    if (!(!Pt || !(D = Pt.events))) {
                        for (h = (h || "").match(ye) || [""],
                        q = h.length; q--; ) {
                            if (N = st.exec(h[q]) || [],
                            lt = Wt = N[1],
                            kt = (N[2] || "").split(".").sort(),
                            !lt) {
                                for (lt in D)
                                    f.event.remove(c, lt + h[q], g, m, !0);
                                continue
                            }
                            for (it = f.event.special[lt] || {},
                            lt = (m ? it.delegateType : it.bindType) || lt,
                            G = D[lt] || [],
                            N = N[2] && new RegExp("(^|\\.)" + kt.join("\\.(?:.*\\.|)") + "(\\.|$)"),
                            S = _ = G.length; _--; )
                                tt = G[_],
                                (y || Wt === tt.origType) && (!g || g.guid === tt.guid) && (!N || N.test(tt.namespace)) && (!m || m === tt.selector || m === "**" && tt.selector) && (G.splice(_, 1),
                                tt.selector && G.delegateCount--,
                                it.remove && it.remove.call(c, tt));
                            S && !G.length && ((!it.teardown || it.teardown.call(c, kt, Pt.handle) === !1) && f.removeEvent(c, lt, Pt.handle),
                            delete D[lt])
                        }
                        f.isEmptyObject(D) && St.remove(c, "handle events")
                    }
                }, "remove"),
                dispatch: o(function(c) {
                    var h, g, m, y, _, S, N = new Array(arguments.length), D = f.event.fix(c), q = (St.get(this, "events") || Object.create(null))[D.type] || [], tt = f.event.special[D.type] || {};
                    for (N[0] = D,
                    h = 1; h < arguments.length; h++)
                        N[h] = arguments[h];
                    if (D.delegateTarget = this,
                    !(tt.preDispatch && tt.preDispatch.call(this, D) === !1)) {
                        for (S = f.event.handlers.call(this, D, q),
                        h = 0; (y = S[h++]) && !D.isPropagationStopped(); )
                            for (D.currentTarget = y.elem,
                            g = 0; (_ = y.handlers[g++]) && !D.isImmediatePropagationStopped(); )
                                (!D.rnamespace || _.namespace === !1 || D.rnamespace.test(_.namespace)) && (D.handleObj = _,
                                D.data = _.data,
                                m = ((f.event.special[_.origType] || {}).handle || _.handler).apply(y.elem, N),
                                m !== void 0 && (D.result = m) === !1 && (D.preventDefault(),
                                D.stopPropagation()));
                        return tt.postDispatch && tt.postDispatch.call(this, D),
                        D.result
                    }
                }, "dispatch"),
                handlers: o(function(c, h) {
                    var g, m, y, _, S, N = [], D = h.delegateCount, q = c.target;
                    if (D && q.nodeType && !(c.type === "click" && c.button >= 1)) {
                        for (; q !== this; q = q.parentNode || this)
                            if (q.nodeType === 1 && !(c.type === "click" && q.disabled === !0)) {
                                for (_ = [],
                                S = {},
                                g = 0; g < D; g++)
                                    m = h[g],
                                    y = m.selector + " ",
                                    S[y] === void 0 && (S[y] = m.needsContext ? f(y, this).index(q) > -1 : f.find(y, this, null, [q]).length),
                                    S[y] && _.push(m);
                                _.length && N.push({
                                    elem: q,
                                    handlers: _
                                })
                            }
                    }
                    return q = this,
                    D < h.length && N.push({
                        elem: q,
                        handlers: h.slice(D)
                    }),
                    N
                }, "handlers"),
                addProp: o(function(c, h) {
                    Object.defineProperty(f.Event.prototype, c, {
                        enumerable: !0,
                        configurable: !0,
                        get: C(h) ? function() {
                            if (this.originalEvent)
                                return h(this.originalEvent)
                        }
                        : function() {
                            if (this.originalEvent)
                                return this.originalEvent[c]
                        }
                        ,
                        set: o(function(g) {
                            Object.defineProperty(this, c, {
                                enumerable: !0,
                                configurable: !0,
                                writable: !0,
                                value: g
                            })
                        }, "set")
                    })
                }, "addProp"),
                fix: o(function(c) {
                    return c[f.expando] ? c : new f.Event(c)
                }, "fix"),
                special: {
                    load: {
                        noBubble: !0
                    },
                    click: {
                        setup: o(function(c) {
                            var h = this || c;
                            return en.test(h.type) && h.click && Q(h, "input") && _t(h, "click", !0),
                            !1
                        }, "setup"),
                        trigger: o(function(c) {
                            var h = this || c;
                            return en.test(h.type) && h.click && Q(h, "input") && _t(h, "click"),
                            !0
                        }, "trigger"),
                        _default: o(function(c) {
                            var h = c.target;
                            return en.test(h.type) && h.click && Q(h, "input") && St.get(h, "click") || Q(h, "a")
                        }, "_default")
                    },
                    beforeunload: {
                        postDispatch: o(function(c) {
                            c.result !== void 0 && c.originalEvent && (c.originalEvent.returnValue = c.result)
                        }, "postDispatch")
                    }
                }
            };
            function _t(c, h, g) {
                if (!g) {
                    St.get(c, h) === void 0 && f.event.add(c, h, at);
                    return
                }
                St.set(c, h, !1),
                f.event.add(c, h, {
                    namespace: !1,
                    handler: o(function(m) {
                        var y, _ = St.get(this, h);
                        if (m.isTrigger & 1 && this[h]) {
                            if (_)
                                (f.event.special[h] || {}).delegateType && m.stopPropagation();
                            else if (_ = r.call(arguments),
                            St.set(this, h, _),
                            this[h](),
                            y = St.get(this, h),
                            St.set(this, h, !1),
                            _ !== y)
                                return m.stopImmediatePropagation(),
                                m.preventDefault(),
                                y
                        } else
                            _ && (St.set(this, h, f.event.trigger(_[0], _.slice(1), this)),
                            m.stopPropagation(),
                            m.isImmediatePropagationStopped = at)
                    }, "handler")
                })
            }
            o(_t, "leverageNative"),
            f.removeEvent = function(c, h, g) {
                c.removeEventListener && c.removeEventListener(h, g)
            }
            ,
            f.Event = function(c, h) {
                if (!(this instanceof f.Event))
                    return new f.Event(c,h);
                c && c.type ? (this.originalEvent = c,
                this.type = c.type,
                this.isDefaultPrevented = c.defaultPrevented || c.defaultPrevented === void 0 && c.returnValue === !1 ? at : ut,
                this.target = c.target && c.target.nodeType === 3 ? c.target.parentNode : c.target,
                this.currentTarget = c.currentTarget,
                this.relatedTarget = c.relatedTarget) : this.type = c,
                h && f.extend(this, h),
                this.timeStamp = c && c.timeStamp || Date.now(),
                this[f.expando] = !0
            }
            ,
            f.Event.prototype = {
                constructor: f.Event,
                isDefaultPrevented: ut,
                isPropagationStopped: ut,
                isImmediatePropagationStopped: ut,
                isSimulated: !1,
                preventDefault: o(function() {
                    var c = this.originalEvent;
                    this.isDefaultPrevented = at,
                    c && !this.isSimulated && c.preventDefault()
                }, "preventDefault"),
                stopPropagation: o(function() {
                    var c = this.originalEvent;
                    this.isPropagationStopped = at,
                    c && !this.isSimulated && c.stopPropagation()
                }, "stopPropagation"),
                stopImmediatePropagation: o(function() {
                    var c = this.originalEvent;
                    this.isImmediatePropagationStopped = at,
                    c && !this.isSimulated && c.stopImmediatePropagation(),
                    this.stopPropagation()
                }, "stopImmediatePropagation")
            },
            f.each({
                altKey: !0,
                bubbles: !0,
                cancelable: !0,
                changedTouches: !0,
                ctrlKey: !0,
                detail: !0,
                eventPhase: !0,
                metaKey: !0,
                pageX: !0,
                pageY: !0,
                shiftKey: !0,
                view: !0,
                char: !0,
                code: !0,
                charCode: !0,
                key: !0,
                keyCode: !0,
                button: !0,
                buttons: !0,
                clientX: !0,
                clientY: !0,
                offsetX: !0,
                offsetY: !0,
                pointerId: !0,
                pointerType: !0,
                screenX: !0,
                screenY: !0,
                targetTouches: !0,
                toElement: !0,
                touches: !0,
                which: !0
            }, f.event.addProp),
            f.each({
                focus: "focusin",
                blur: "focusout"
            }, function(c, h) {
                function g(m) {
                    if (L.documentMode) {
                        var y = St.get(this, "handle")
                          , _ = f.event.fix(m);
                        _.type = m.type === "focusin" ? "focus" : "blur",
                        _.isSimulated = !0,
                        y(m),
                        _.target === _.currentTarget && y(_)
                    } else
                        f.event.simulate(h, m.target, f.event.fix(m))
                }
                o(g, "focusMappedHandler"),
                f.event.special[c] = {
                    setup: o(function() {
                        var m;
                        if (_t(this, c, !0),
                        L.documentMode)
                            m = St.get(this, h),
                            m || this.addEventListener(h, g),
                            St.set(this, h, (m || 0) + 1);
                        else
                            return !1
                    }, "setup"),
                    trigger: o(function() {
                        return _t(this, c),
                        !0
                    }, "trigger"),
                    teardown: o(function() {
                        var m;
                        if (L.documentMode)
                            m = St.get(this, h) - 1,
                            m ? St.set(this, h, m) : (this.removeEventListener(h, g),
                            St.remove(this, h));
                        else
                            return !1
                    }, "teardown"),
                    _default: o(function(m) {
                        return St.get(m.target, c)
                    }, "_default"),
                    delegateType: h
                },
                f.event.special[h] = {
                    setup: o(function() {
                        var m = this.ownerDocument || this.document || this
                          , y = L.documentMode ? this : m
                          , _ = St.get(y, h);
                        _ || (L.documentMode ? this.addEventListener(h, g) : m.addEventListener(c, g, !0)),
                        St.set(y, h, (_ || 0) + 1)
                    }, "setup"),
                    teardown: o(function() {
                        var m = this.ownerDocument || this.document || this
                          , y = L.documentMode ? this : m
                          , _ = St.get(y, h) - 1;
                        _ ? St.set(y, h, _) : (L.documentMode ? this.removeEventListener(h, g) : m.removeEventListener(c, g, !0),
                        St.remove(y, h))
                    }, "teardown")
                }
            }),
            f.each({
                mouseenter: "mouseover",
                mouseleave: "mouseout",
                pointerenter: "pointerover",
                pointerleave: "pointerout"
            }, function(c, h) {
                f.event.special[c] = {
                    delegateType: h,
                    bindType: h,
                    handle: o(function(g) {
                        var m, y = this, _ = g.relatedTarget, S = g.handleObj;
                        return (!_ || _ !== y && !f.contains(y, _)) && (g.type = S.origType,
                        m = S.handler.apply(this, arguments),
                        g.type = h),
                        m
                    }, "handle")
                }
            }),
            f.fn.extend({
                on: o(function(c, h, g, m) {
                    return dt(this, c, h, g, m)
                }, "on"),
                one: o(function(c, h, g, m) {
                    return dt(this, c, h, g, m, 1)
                }, "one"),
                off: o(function(c, h, g) {
                    var m, y;
                    if (c && c.preventDefault && c.handleObj)
                        return m = c.handleObj,
                        f(c.delegateTarget).off(m.namespace ? m.origType + "." + m.namespace : m.origType, m.selector, m.handler),
                        this;
                    if (typeof c == "object") {
                        for (y in c)
                            this.off(y, h, c[y]);
                        return this
                    }
                    return (h === !1 || typeof h == "function") && (g = h,
                    h = void 0),
                    g === !1 && (g = ut),
                    this.each(function() {
                        f.event.remove(this, c, g, h)
                    })
                }, "off")
            });
            var Tt = /<script|<style|<link/i
              , yt = /checked\s*(?:[^=]|=\s*.checked.)/i
              , Lt = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
            function Mt(c, h) {
                return Q(c, "table") && Q(h.nodeType !== 11 ? h : h.firstChild, "tr") && f(c).children("tbody")[0] || c
            }
            o(Mt, "manipulationTarget");
            function Dt(c) {
                return c.type = (c.getAttribute("type") !== null) + "/" + c.type,
                c
            }
            o(Dt, "disableScript");
            function ne(c) {
                return (c.type || "").slice(0, 5) === "true/" ? c.type = c.type.slice(5) : c.removeAttribute("type"),
                c
            }
            o(ne, "restoreScript");
            function Ve(c, h) {
                var g, m, y, _, S, N, D;
                if (h.nodeType === 1) {
                    if (St.hasData(c) && (_ = St.get(c),
                    D = _.events,
                    D)) {
                        St.remove(h, "handle events");
                        for (y in D)
                            for (g = 0,
                            m = D[y].length; g < m; g++)
                                f.event.add(h, y, D[y][g])
                    }
                    me.hasData(c) && (S = me.access(c),
                    N = f.extend({}, S),
                    me.set(h, N))
                }
            }
            o(Ve, "cloneCopyEvent");
            function Qe(c, h) {
                var g = h.nodeName.toLowerCase();
                g === "input" && en.test(c.type) ? h.checked = c.checked : (g === "input" || g === "textarea") && (h.defaultValue = c.defaultValue)
            }
            o(Qe, "fixInput");
            function se(c, h, g, m) {
                h = a(h);
                var y, _, S, N, D, q, tt = 0, it = c.length, G = it - 1, lt = h[0], kt = C(lt);
                if (kt || it > 1 && typeof lt == "string" && !w.checkClone && yt.test(lt))
                    return c.each(function(Wt) {
                        var Pt = c.eq(Wt);
                        kt && (h[0] = lt.call(this, Wt, Pt.html())),
                        se(Pt, h, g, m)
                    });
                if (it && (y = rt(h, c[0].ownerDocument, !1, c, m),
                _ = y.firstChild,
                y.childNodes.length === 1 && (y = _),
                _ || m)) {
                    for (S = f.map(R(y, "script"), Dt),
                    N = S.length; tt < it; tt++)
                        D = y,
                        tt !== G && (D = f.clone(D, !0, !0),
                        N && f.merge(S, R(D, "script"))),
                        g.call(c[tt], D, tt);
                    if (N)
                        for (q = S[S.length - 1].ownerDocument,
                        f.map(S, ne),
                        tt = 0; tt < N; tt++)
                            D = S[tt],
                            nn.test(D.type || "") && !St.access(D, "globalEval") && f.contains(q, D) && (D.src && (D.type || "").toLowerCase() !== "module" ? f._evalUrl && !D.noModule && f._evalUrl(D.src, {
                                nonce: D.nonce || D.getAttribute("nonce")
                            }, q) : F(D.textContent.replace(Lt, ""), D, q))
                }
                return c
            }
            o(se, "domManip");
            function we(c, h, g) {
                for (var m, y = h ? f.filter(h, c) : c, _ = 0; (m = y[_]) != null; _++)
                    !g && m.nodeType === 1 && f.cleanData(R(m)),
                    m.parentNode && (g && Pi(m) && W(R(m, "script")),
                    m.parentNode.removeChild(m));
                return c
            }
            o(we, "remove"),
            f.extend({
                htmlPrefilter: o(function(c) {
                    return c
                }, "htmlPrefilter"),
                clone: o(function(c, h, g) {
                    var m, y, _, S, N = c.cloneNode(!0), D = Pi(c);
                    if (!w.noCloneChecked && (c.nodeType === 1 || c.nodeType === 11) && !f.isXMLDoc(c))
                        for (S = R(N),
                        _ = R(c),
                        m = 0,
                        y = _.length; m < y; m++)
                            Qe(_[m], S[m]);
                    if (h)
                        if (g)
                            for (_ = _ || R(c),
                            S = S || R(N),
                            m = 0,
                            y = _.length; m < y; m++)
                                Ve(_[m], S[m]);
                        else
                            Ve(c, N);
                    return S = R(N, "script"),
                    S.length > 0 && W(S, !D && R(c, "script")),
                    N
                }, "clone"),
                cleanData: o(function(c) {
                    for (var h, g, m, y = f.event.special, _ = 0; (g = c[_]) !== void 0; _++)
                        if (Ji(g)) {
                            if (h = g[St.expando]) {
                                if (h.events)
                                    for (m in h.events)
                                        y[m] ? f.event.remove(g, m) : f.removeEvent(g, m, h.handle);
                                g[St.expando] = void 0
                            }
                            g[me.expando] && (g[me.expando] = void 0)
                        }
                }, "cleanData")
            }),
            f.fn.extend({
                detach: o(function(c) {
                    return we(this, c, !0)
                }, "detach"),
                remove: o(function(c) {
                    return we(this, c)
                }, "remove"),
                text: o(function(c) {
                    return Re(this, function(h) {
                        return h === void 0 ? f.text(this) : this.empty().each(function() {
                            (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) && (this.textContent = h)
                        })
                    }, null, c, arguments.length)
                }, "text"),
                append: o(function() {
                    return se(this, arguments, function(c) {
                        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                            var h = Mt(this, c);
                            h.appendChild(c)
                        }
                    })
                }, "append"),
                prepend: o(function() {
                    return se(this, arguments, function(c) {
                        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                            var h = Mt(this, c);
                            h.insertBefore(c, h.firstChild)
                        }
                    })
                }, "prepend"),
                before: o(function() {
                    return se(this, arguments, function(c) {
                        this.parentNode && this.parentNode.insertBefore(c, this)
                    })
                }, "before"),
                after: o(function() {
                    return se(this, arguments, function(c) {
                        this.parentNode && this.parentNode.insertBefore(c, this.nextSibling)
                    })
                }, "after"),
                empty: o(function() {
                    for (var c, h = 0; (c = this[h]) != null; h++)
                        c.nodeType === 1 && (f.cleanData(R(c, !1)),
                        c.textContent = "");
                    return this
                }, "empty"),
                clone: o(function(c, h) {
                    return c = c ?? !1,
                    h = h ?? c,
                    this.map(function() {
                        return f.clone(this, c, h)
                    })
                }, "clone"),
                html: o(function(c) {
                    return Re(this, function(h) {
                        var g = this[0] || {}
                          , m = 0
                          , y = this.length;
                        if (h === void 0 && g.nodeType === 1)
                            return g.innerHTML;
                        if (typeof h == "string" && !Tt.test(h) && !T[(As.exec(h) || ["", ""])[1].toLowerCase()]) {
                            h = f.htmlPrefilter(h);
                            try {
                                for (; m < y; m++)
                                    g = this[m] || {},
                                    g.nodeType === 1 && (f.cleanData(R(g, !1)),
                                    g.innerHTML = h);
                                g = 0
                            } catch {}
                        }
                        g && this.empty().append(h)
                    }, null, c, arguments.length)
                }, "html"),
                replaceWith: o(function() {
                    var c = [];
                    return se(this, arguments, function(h) {
                        var g = this.parentNode;
                        f.inArray(this, c) < 0 && (f.cleanData(R(this)),
                        g && g.replaceChild(h, this))
                    }, c)
                }, "replaceWith")
            }),
            f.each({
                appendTo: "append",
                prependTo: "prepend",
                insertBefore: "before",
                insertAfter: "after",
                replaceAll: "replaceWith"
            }, function(c, h) {
                f.fn[c] = function(g) {
                    for (var m, y = [], _ = f(g), S = _.length - 1, N = 0; N <= S; N++)
                        m = N === S ? this : this.clone(!0),
                        f(_[N])[h](m),
                        l.apply(y, m.get());
                    return this.pushStack(y)
                }
            });
            var Xn = new RegExp("^(" + Yn + ")(?!px)[a-z%]+$","i")
              , Be = /^--/
              , Ii = o(function(c) {
                var h = c.ownerDocument.defaultView;
                return (!h || !h.opener) && (h = n),
                h.getComputedStyle(c)
            }, "getStyles")
              , No = o(function(c, h, g) {
                var m, y, _ = {};
                for (y in h)
                    _[y] = c.style[y],
                    c.style[y] = h[y];
                m = g.call(c);
                for (y in h)
                    c.style[y] = _[y];
                return m
            }, "swap")
              , fl = new RegExp(Ge.join("|"),"i");
            (function() {
                function c() {
                    if (q) {
                        D.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",
                        q.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",
                        hi.appendChild(D).appendChild(q);
                        var tt = n.getComputedStyle(q);
                        g = tt.top !== "1%",
                        N = h(tt.marginLeft) === 12,
                        q.style.right = "60%",
                        _ = h(tt.right) === 36,
                        m = h(tt.width) === 36,
                        q.style.position = "absolute",
                        y = h(q.offsetWidth / 3) === 12,
                        hi.removeChild(D),
                        q = null
                    }
                }
                o(c, "computeStyleTests");
                function h(tt) {
                    return Math.round(parseFloat(tt))
                }
                o(h, "roundPixelMeasures");
                var g, m, y, _, S, N, D = L.createElement("div"), q = L.createElement("div");
                q.style && (q.style.backgroundClip = "content-box",
                q.cloneNode(!0).style.backgroundClip = "",
                w.clearCloneStyle = q.style.backgroundClip === "content-box",
                f.extend(w, {
                    boxSizingReliable: o(function() {
                        return c(),
                        m
                    }, "boxSizingReliable"),
                    pixelBoxStyles: o(function() {
                        return c(),
                        _
                    }, "pixelBoxStyles"),
                    pixelPosition: o(function() {
                        return c(),
                        g
                    }, "pixelPosition"),
                    reliableMarginLeft: o(function() {
                        return c(),
                        N
                    }, "reliableMarginLeft"),
                    scrollboxSize: o(function() {
                        return c(),
                        y
                    }, "scrollboxSize"),
                    reliableTrDimensions: o(function() {
                        var tt, it, G, lt;
                        return S == null && (tt = L.createElement("table"),
                        it = L.createElement("tr"),
                        G = L.createElement("div"),
                        tt.style.cssText = "position:absolute;left:-11111px;border-collapse:separate",
                        it.style.cssText = "box-sizing:content-box;border:1px solid",
                        it.style.height = "1px",
                        G.style.height = "9px",
                        G.style.display = "block",
                        hi.appendChild(tt).appendChild(it).appendChild(G),
                        lt = n.getComputedStyle(it),
                        S = parseInt(lt.height, 10) + parseInt(lt.borderTopWidth, 10) + parseInt(lt.borderBottomWidth, 10) === it.offsetHeight,
                        hi.removeChild(tt)),
                        S
                    }, "reliableTrDimensions")
                }))
            }
            )();
            function sn(c, h, g) {
                var m, y, _, S, N = Be.test(h), D = c.style;
                return g = g || Ii(c),
                g && (S = g.getPropertyValue(h) || g[h],
                N && S && (S = S.replace($t, "$1") || void 0),
                S === "" && !Pi(c) && (S = f.style(c, h)),
                !w.pixelBoxStyles() && Xn.test(S) && fl.test(h) && (m = D.width,
                y = D.minWidth,
                _ = D.maxWidth,
                D.minWidth = D.maxWidth = D.width = S,
                S = g.width,
                D.width = m,
                D.minWidth = y,
                D.maxWidth = _)),
                S !== void 0 ? S + "" : S
            }
            o(sn, "curCSS");
            function Fo(c, h) {
                return {
                    get: o(function() {
                        if (c()) {
                            delete this.get;
                            return
                        }
                        return (this.get = h).apply(this, arguments)
                    }, "get")
                }
            }
            o(Fo, "addGetHookIf");
            var Vo = ["Webkit", "Moz", "ms"]
              , Bo = L.createElement("div").style
              , Ho = {};
            function pl(c) {
                for (var h = c[0].toUpperCase() + c.slice(1), g = Vo.length; g--; )
                    if (c = Vo[g] + h,
                    c in Bo)
                        return c
            }
            o(pl, "vendorPropName");
            function Or(c) {
                var h = f.cssProps[c] || Ho[c];
                return h || (c in Bo ? c : Ho[c] = pl(c) || c)
            }
            o(Or, "finalPropName");
            var rn = /^(none|table(?!-c[ea]).+)/
              , Gn = {
                position: "absolute",
                visibility: "hidden",
                display: "block"
            }
              , Qn = {
                letterSpacing: "0",
                fontWeight: "400"
            };
            function ks(c, h, g) {
                var m = xi.exec(h);
                return m ? Math.max(0, m[2] - (g || 0)) + (m[3] || "px") : h
            }
            o(ks, "setPositiveNumber");
            function Ms(c, h, g, m, y, _) {
                var S = h === "width" ? 1 : 0
                  , N = 0
                  , D = 0
                  , q = 0;
                if (g === (m ? "border" : "content"))
                    return 0;
                for (; S < 4; S += 2)
                    g === "margin" && (q += f.css(c, g + Ge[S], !0, y)),
                    m ? (g === "content" && (D -= f.css(c, "padding" + Ge[S], !0, y)),
                    g !== "margin" && (D -= f.css(c, "border" + Ge[S] + "Width", !0, y))) : (D += f.css(c, "padding" + Ge[S], !0, y),
                    g !== "padding" ? D += f.css(c, "border" + Ge[S] + "Width", !0, y) : N += f.css(c, "border" + Ge[S] + "Width", !0, y));
                return !m && _ >= 0 && (D += Math.max(0, Math.ceil(c["offset" + h[0].toUpperCase() + h.slice(1)] - _ - D - N - .5)) || 0),
                D + q
            }
            o(Ms, "boxModelAdjustment");
            function jo(c, h, g) {
                var m = Ii(c)
                  , y = !w.boxSizingReliable() || g
                  , _ = y && f.css(c, "boxSizing", !1, m) === "border-box"
                  , S = _
                  , N = sn(c, h, m)
                  , D = "offset" + h[0].toUpperCase() + h.slice(1);
                if (Xn.test(N)) {
                    if (!g)
                        return N;
                    N = "auto"
                }
                return (!w.boxSizingReliable() && _ || !w.reliableTrDimensions() && Q(c, "tr") || N === "auto" || !parseFloat(N) && f.css(c, "display", !1, m) === "inline") && c.getClientRects().length && (_ = f.css(c, "boxSizing", !1, m) === "border-box",
                S = D in c,
                S && (N = c[D])),
                N = parseFloat(N) || 0,
                N + Ms(c, h, g || (_ ? "border" : "content"), S, m, N) + "px"
            }
            o(jo, "getWidthOrHeight"),
            f.extend({
                cssHooks: {
                    opacity: {
                        get: o(function(c, h) {
                            if (h) {
                                var g = sn(c, "opacity");
                                return g === "" ? "1" : g
                            }
                        }, "get")
                    }
                },
                cssNumber: {
                    animationIterationCount: !0,
                    aspectRatio: !0,
                    borderImageSlice: !0,
                    columnCount: !0,
                    flexGrow: !0,
                    flexShrink: !0,
                    fontWeight: !0,
                    gridArea: !0,
                    gridColumn: !0,
                    gridColumnEnd: !0,
                    gridColumnStart: !0,
                    gridRow: !0,
                    gridRowEnd: !0,
                    gridRowStart: !0,
                    lineHeight: !0,
                    opacity: !0,
                    order: !0,
                    orphans: !0,
                    scale: !0,
                    widows: !0,
                    zIndex: !0,
                    zoom: !0,
                    fillOpacity: !0,
                    floodOpacity: !0,
                    stopOpacity: !0,
                    strokeMiterlimit: !0,
                    strokeOpacity: !0
                },
                cssProps: {},
                style: o(function(c, h, g, m) {
                    if (!(!c || c.nodeType === 3 || c.nodeType === 8 || !c.style)) {
                        var y, _, S, N = Fe(h), D = Be.test(h), q = c.style;
                        if (D || (h = Or(N)),
                        S = f.cssHooks[h] || f.cssHooks[N],
                        g !== void 0) {
                            if (_ = typeof g,
                            _ === "string" && (y = xi.exec(g)) && y[1] && (g = ws(c, h, y),
                            _ = "number"),
                            g == null || g !== g)
                                return;
                            _ === "number" && !D && (g += y && y[3] || (f.cssNumber[N] ? "" : "px")),
                            !w.clearCloneStyle && g === "" && h.indexOf("background") === 0 && (q[h] = "inherit"),
                            (!S || !("set"in S) || (g = S.set(c, g, m)) !== void 0) && (D ? q.setProperty(h, g) : q[h] = g)
                        } else
                            return S && "get"in S && (y = S.get(c, !1, m)) !== void 0 ? y : q[h]
                    }
                }, "style"),
                css: o(function(c, h, g, m) {
                    var y, _, S, N = Fe(h), D = Be.test(h);
                    return D || (h = Or(N)),
                    S = f.cssHooks[h] || f.cssHooks[N],
                    S && "get"in S && (y = S.get(c, !0, g)),
                    y === void 0 && (y = sn(c, h, m)),
                    y === "normal" && h in Qn && (y = Qn[h]),
                    g === "" || g ? (_ = parseFloat(y),
                    g === !0 || isFinite(_) ? _ || 0 : y) : y
                }, "css")
            }),
            f.each(["height", "width"], function(c, h) {
                f.cssHooks[h] = {
                    get: o(function(g, m, y) {
                        if (m)
                            return rn.test(f.css(g, "display")) && (!g.getClientRects().length || !g.getBoundingClientRect().width) ? No(g, Gn, function() {
                                return jo(g, h, y)
                            }) : jo(g, h, y)
                    }, "get"),
                    set: o(function(g, m, y) {
                        var _, S = Ii(g), N = !w.scrollboxSize() && S.position === "absolute", D = N || y, q = D && f.css(g, "boxSizing", !1, S) === "border-box", tt = y ? Ms(g, h, y, q, S) : 0;
                        return q && N && (tt -= Math.ceil(g["offset" + h[0].toUpperCase() + h.slice(1)] - parseFloat(S[h]) - Ms(g, h, "border", !1, S) - .5)),
                        tt && (_ = xi.exec(m)) && (_[3] || "px") !== "px" && (g.style[h] = m,
                        m = f.css(g, h)),
                        ks(g, m, tt)
                    }, "set")
                }
            }),
            f.cssHooks.marginLeft = Fo(w.reliableMarginLeft, function(c, h) {
                if (h)
                    return (parseFloat(sn(c, "marginLeft")) || c.getBoundingClientRect().left - No(c, {
                        marginLeft: 0
                    }, function() {
                        return c.getBoundingClientRect().left
                    })) + "px"
            }),
            f.each({
                margin: "",
                padding: "",
                border: "Width"
            }, function(c, h) {
                f.cssHooks[c + h] = {
                    expand: o(function(g) {
                        for (var m = 0, y = {}, _ = typeof g == "string" ? g.split(" ") : [g]; m < 4; m++)
                            y[c + Ge[m] + h] = _[m] || _[m - 2] || _[0];
                        return y
                    }, "expand")
                },
                c !== "margin" && (f.cssHooks[c + h].set = ks)
            }),
            f.fn.extend({
                css: o(function(c, h) {
                    return Re(this, function(g, m, y) {
                        var _, S, N = {}, D = 0;
                        if (Array.isArray(m)) {
                            for (_ = Ii(g),
                            S = m.length; D < S; D++)
                                N[m[D]] = f.css(g, m[D], !1, _);
                            return N
                        }
                        return y !== void 0 ? f.style(g, m, y) : f.css(g, m)
                    }, c, h, arguments.length > 1)
                }, "css")
            });
            function Oe(c, h, g, m, y) {
                return new Oe.prototype.init(c,h,g,m,y)
            }
            o(Oe, "Tween"),
            f.Tween = Oe,
            Oe.prototype = {
                constructor: Oe,
                init: o(function(c, h, g, m, y, _) {
                    this.elem = c,
                    this.prop = g,
                    this.easing = y || f.easing._default,
                    this.options = h,
                    this.start = this.now = this.cur(),
                    this.end = m,
                    this.unit = _ || (f.cssNumber[g] ? "" : "px")
                }, "init"),
                cur: o(function() {
                    var c = Oe.propHooks[this.prop];
                    return c && c.get ? c.get(this) : Oe.propHooks._default.get(this)
                }, "cur"),
                run: o(function(c) {
                    var h, g = Oe.propHooks[this.prop];
                    return this.options.duration ? this.pos = h = f.easing[this.easing](c, this.options.duration * c, 0, 1, this.options.duration) : this.pos = h = c,
                    this.now = (this.end - this.start) * h + this.start,
                    this.options.step && this.options.step.call(this.elem, this.now, this),
                    g && g.set ? g.set(this) : Oe.propHooks._default.set(this),
                    this
                }, "run")
            },
            Oe.prototype.init.prototype = Oe.prototype,
            Oe.propHooks = {
                _default: {
                    get: o(function(c) {
                        var h;
                        return c.elem.nodeType !== 1 || c.elem[c.prop] != null && c.elem.style[c.prop] == null ? c.elem[c.prop] : (h = f.css(c.elem, c.prop, ""),
                        !h || h === "auto" ? 0 : h)
                    }, "get"),
                    set: o(function(c) {
                        f.fx.step[c.prop] ? f.fx.step[c.prop](c) : c.elem.nodeType === 1 && (f.cssHooks[c.prop] || c.elem.style[Or(c.prop)] != null) ? f.style(c.elem, c.prop, c.now + c.unit) : c.elem[c.prop] = c.now
                    }, "set")
                }
            },
            Oe.propHooks.scrollTop = Oe.propHooks.scrollLeft = {
                set: o(function(c) {
                    c.elem.nodeType && c.elem.parentNode && (c.elem[c.prop] = c.now)
                }, "set")
            },
            f.easing = {
                linear: o(function(c) {
                    return c
                }, "linear"),
                swing: o(function(c) {
                    return .5 - Math.cos(c * Math.PI) / 2
                }, "swing"),
                _default: "swing"
            },
            f.fx = Oe.prototype.init,
            f.fx.step = {};
            var on, Ni, _n = /^(?:toggle|show|hide)$/, gl = /queueHooks$/;
            function an() {
                Ni && (L.hidden === !1 && n.requestAnimationFrame ? n.requestAnimationFrame(an) : n.setTimeout(an, f.fx.interval),
                f.fx.tick())
            }
            o(an, "schedule");
            function di() {
                return n.setTimeout(function() {
                    on = void 0
                }),
                on = Date.now()
            }
            o(di, "createFxNow");
            function En(c, h) {
                var g, m = 0, y = {
                    height: c
                };
                for (h = h ? 1 : 0; m < 4; m += 2 - h)
                    g = Ge[m],
                    y["margin" + g] = y["padding" + g] = c;
                return h && (y.opacity = y.width = c),
                y
            }
            o(En, "genFx");
            function Wo(c, h, g) {
                for (var m, y = (He.tweeners[h] || []).concat(He.tweeners["*"]), _ = 0, S = y.length; _ < S; _++)
                    if (m = y[_].call(g, h, c))
                        return m
            }
            o(Wo, "createTween");
            function Jn(c, h, g) {
                var m, y, _, S, N, D, q, tt, it = "width"in h || "height"in h, G = this, lt = {}, kt = c.style, Wt = c.nodeType && yn(c), Pt = St.get(c, "fxshow");
                g.queue || (S = f._queueHooks(c, "fx"),
                S.unqueued == null && (S.unqueued = 0,
                N = S.empty.fire,
                S.empty.fire = function() {
                    S.unqueued || N()
                }
                ),
                S.unqueued++,
                G.always(function() {
                    G.always(function() {
                        S.unqueued--,
                        f.queue(c, "fx").length || S.empty.fire()
                    })
                }));
                for (m in h)
                    if (y = h[m],
                    _n.test(y)) {
                        if (delete h[m],
                        _ = _ || y === "toggle",
                        y === (Wt ? "hide" : "show"))
                            if (y === "show" && Pt && Pt[m] !== void 0)
                                Wt = !0;
                            else
                                continue;
                        lt[m] = Pt && Pt[m] || f.style(c, m)
                    }
                if (D = !f.isEmptyObject(h),
                !(!D && f.isEmptyObject(lt))) {
                    it && c.nodeType === 1 && (g.overflow = [kt.overflow, kt.overflowX, kt.overflowY],
                    q = Pt && Pt.display,
                    q == null && (q = St.get(c, "display")),
                    tt = f.css(c, "display"),
                    tt === "none" && (q ? tt = q : (Ri([c], !0),
                    q = c.style.display || q,
                    tt = f.css(c, "display"),
                    Ri([c]))),
                    (tt === "inline" || tt === "inline-block" && q != null) && f.css(c, "float") === "none" && (D || (G.done(function() {
                        kt.display = q
                    }),
                    q == null && (tt = kt.display,
                    q = tt === "none" ? "" : tt)),
                    kt.display = "inline-block")),
                    g.overflow && (kt.overflow = "hidden",
                    G.always(function() {
                        kt.overflow = g.overflow[0],
                        kt.overflowX = g.overflow[1],
                        kt.overflowY = g.overflow[2]
                    })),
                    D = !1;
                    for (m in lt)
                        D || (Pt ? "hidden"in Pt && (Wt = Pt.hidden) : Pt = St.access(c, "fxshow", {
                            display: q
                        }),
                        _ && (Pt.hidden = !Wt),
                        Wt && Ri([c], !0),
                        G.done(function() {
                            Wt || Ri([c]),
                            St.remove(c, "fxshow");
                            for (m in lt)
                                f.style(c, m, lt[m])
                        })),
                        D = Wo(Wt ? Pt[m] : 0, m, G),
                        m in Pt || (Pt[m] = D.start,
                        Wt && (D.end = D.start,
                        D.start = 0))
                }
            }
            o(Jn, "defaultPrefilter");
            function $o(c, h) {
                var g, m, y, _, S;
                for (g in c)
                    if (m = Fe(g),
                    y = h[m],
                    _ = c[g],
                    Array.isArray(_) && (y = _[1],
                    _ = c[g] = _[0]),
                    g !== m && (c[m] = _,
                    delete c[g]),
                    S = f.cssHooks[m],
                    S && "expand"in S) {
                        _ = S.expand(_),
                        delete c[m];
                        for (g in _)
                            g in c || (c[g] = _[g],
                            h[g] = y)
                    } else
                        h[m] = y
            }
            o($o, "propFilter");
            function He(c, h, g) {
                var m, y, _ = 0, S = He.prefilters.length, N = f.Deferred().always(function() {
                    delete D.elem
                }), D = o(function() {
                    if (y)
                        return !1;
                    for (var it = on || di(), G = Math.max(0, q.startTime + q.duration - it), lt = G / q.duration || 0, kt = 1 - lt, Wt = 0, Pt = q.tweens.length; Wt < Pt; Wt++)
                        q.tweens[Wt].run(kt);
                    return N.notifyWith(c, [q, kt, G]),
                    kt < 1 && Pt ? G : (Pt || N.notifyWith(c, [q, 1, 0]),
                    N.resolveWith(c, [q]),
                    !1)
                }, "tick"), q = N.promise({
                    elem: c,
                    props: f.extend({}, h),
                    opts: f.extend(!0, {
                        specialEasing: {},
                        easing: f.easing._default
                    }, g),
                    originalProperties: h,
                    originalOptions: g,
                    startTime: on || di(),
                    duration: g.duration,
                    tweens: [],
                    createTween: o(function(it, G) {
                        var lt = f.Tween(c, q.opts, it, G, q.opts.specialEasing[it] || q.opts.easing);
                        return q.tweens.push(lt),
                        lt
                    }, "createTween"),
                    stop: o(function(it) {
                        var G = 0
                          , lt = it ? q.tweens.length : 0;
                        if (y)
                            return this;
                        for (y = !0; G < lt; G++)
                            q.tweens[G].run(1);
                        return it ? (N.notifyWith(c, [q, 1, 0]),
                        N.resolveWith(c, [q, it])) : N.rejectWith(c, [q, it]),
                        this
                    }, "stop")
                }), tt = q.props;
                for ($o(tt, q.opts.specialEasing); _ < S; _++)
                    if (m = He.prefilters[_].call(q, c, tt, q.opts),
                    m)
                        return C(m.stop) && (f._queueHooks(q.elem, q.opts.queue).stop = m.stop.bind(m)),
                        m;
                return f.map(tt, Wo, q),
                C(q.opts.start) && q.opts.start.call(c, q),
                q.progress(q.opts.progress).done(q.opts.done, q.opts.complete).fail(q.opts.fail).always(q.opts.always),
                f.fx.timer(f.extend(D, {
                    elem: c,
                    anim: q,
                    queue: q.opts.queue
                })),
                q
            }
            o(He, "Animation"),
            f.Animation = f.extend(He, {
                tweeners: {
                    "*": [function(c, h) {
                        var g = this.createTween(c, h);
                        return ws(g.elem, c, xi.exec(h), g),
                        g
                    }
                    ]
                },
                tweener: o(function(c, h) {
                    C(c) ? (h = c,
                    c = ["*"]) : c = c.match(ye);
                    for (var g, m = 0, y = c.length; m < y; m++)
                        g = c[m],
                        He.tweeners[g] = He.tweeners[g] || [],
                        He.tweeners[g].unshift(h)
                }, "tweener"),
                prefilters: [Jn],
                prefilter: o(function(c, h) {
                    h ? He.prefilters.unshift(c) : He.prefilters.push(c)
                }, "prefilter")
            }),
            f.speed = function(c, h, g) {
                var m = c && typeof c == "object" ? f.extend({}, c) : {
                    complete: g || !g && h || C(c) && c,
                    duration: c,
                    easing: g && h || h && !C(h) && h
                };
                return f.fx.off ? m.duration = 0 : typeof m.duration != "number" && (m.duration in f.fx.speeds ? m.duration = f.fx.speeds[m.duration] : m.duration = f.fx.speeds._default),
                (m.queue == null || m.queue === !0) && (m.queue = "fx"),
                m.old = m.complete,
                m.complete = function() {
                    C(m.old) && m.old.call(this),
                    m.queue && f.dequeue(this, m.queue)
                }
                ,
                m
            }
            ,
            f.fn.extend({
                fadeTo: o(function(c, h, g, m) {
                    return this.filter(yn).css("opacity", 0).show().end().animate({
                        opacity: h
                    }, c, g, m)
                }, "fadeTo"),
                animate: o(function(c, h, g, m) {
                    var y = f.isEmptyObject(c)
                      , _ = f.speed(h, g, m)
                      , S = o(function() {
                        var N = He(this, f.extend({}, c), _);
                        (y || St.get(this, "finish")) && N.stop(!0)
                    }, "doAnimation");
                    return S.finish = S,
                    y || _.queue === !1 ? this.each(S) : this.queue(_.queue, S)
                }, "animate"),
                stop: o(function(c, h, g) {
                    var m = o(function(y) {
                        var _ = y.stop;
                        delete y.stop,
                        _(g)
                    }, "stopQueue");
                    return typeof c != "string" && (g = h,
                    h = c,
                    c = void 0),
                    h && this.queue(c || "fx", []),
                    this.each(function() {
                        var y = !0
                          , _ = c != null && c + "queueHooks"
                          , S = f.timers
                          , N = St.get(this);
                        if (_)
                            N[_] && N[_].stop && m(N[_]);
                        else
                            for (_ in N)
                                N[_] && N[_].stop && gl.test(_) && m(N[_]);
                        for (_ = S.length; _--; )
                            S[_].elem === this && (c == null || S[_].queue === c) && (S[_].anim.stop(g),
                            y = !1,
                            S.splice(_, 1));
                        (y || !g) && f.dequeue(this, c)
                    })
                }, "stop"),
                finish: o(function(c) {
                    return c !== !1 && (c = c || "fx"),
                    this.each(function() {
                        var h, g = St.get(this), m = g[c + "queue"], y = g[c + "queueHooks"], _ = f.timers, S = m ? m.length : 0;
                        for (g.finish = !0,
                        f.queue(this, c, []),
                        y && y.stop && y.stop.call(this, !0),
                        h = _.length; h--; )
                            _[h].elem === this && _[h].queue === c && (_[h].anim.stop(!0),
                            _.splice(h, 1));
                        for (h = 0; h < S; h++)
                            m[h] && m[h].finish && m[h].finish.call(this);
                        delete g.finish
                    })
                }, "finish")
            }),
            f.each(["toggle", "show", "hide"], function(c, h) {
                var g = f.fn[h];
                f.fn[h] = function(m, y, _) {
                    return m == null || typeof m == "boolean" ? g.apply(this, arguments) : this.animate(En(h, !0), m, y, _)
                }
            }),
            f.each({
                slideDown: En("show"),
                slideUp: En("hide"),
                slideToggle: En("toggle"),
                fadeIn: {
                    opacity: "show"
                },
                fadeOut: {
                    opacity: "hide"
                },
                fadeToggle: {
                    opacity: "toggle"
                }
            }, function(c, h) {
                f.fn[c] = function(g, m, y) {
                    return this.animate(h, g, m, y)
                }
            }),
            f.timers = [],
            f.fx.tick = function() {
                var c, h = 0, g = f.timers;
                for (on = Date.now(); h < g.length; h++)
                    c = g[h],
                    !c() && g[h] === c && g.splice(h--, 1);
                g.length || f.fx.stop(),
                on = void 0
            }
            ,
            f.fx.timer = function(c) {
                f.timers.push(c),
                f.fx.start()
            }
            ,
            f.fx.interval = 13,
            f.fx.start = function() {
                Ni || (Ni = !0,
                an())
            }
            ,
            f.fx.stop = function() {
                Ni = null
            }
            ,
            f.fx.speeds = {
                slow: 600,
                fast: 200,
                _default: 400
            },
            f.fn.delay = function(c, h) {
                return c = f.fx && f.fx.speeds[c] || c,
                h = h || "fx",
                this.queue(h, function(g, m) {
                    var y = n.setTimeout(g, c);
                    m.stop = function() {
                        n.clearTimeout(y)
                    }
                })
            }
            ,
            (function() {
                var c = L.createElement("input")
                  , h = L.createElement("select")
                  , g = h.appendChild(L.createElement("option"));
                c.type = "checkbox",
                w.checkOn = c.value !== "",
                w.optSelected = g.selected,
                c = L.createElement("input"),
                c.value = "t",
                c.type = "radio",
                w.radioValue = c.value === "t"
            }
            )();
            var Os, ln = f.expr.attrHandle;
            f.fn.extend({
                attr: o(function(c, h) {
                    return Re(this, f.attr, c, h, arguments.length > 1)
                }, "attr"),
                removeAttr: o(function(c) {
                    return this.each(function() {
                        f.removeAttr(this, c)
                    })
                }, "removeAttr")
            }),
            f.extend({
                attr: o(function(c, h, g) {
                    var m, y, _ = c.nodeType;
                    if (!(_ === 3 || _ === 8 || _ === 2)) {
                        if (typeof c.getAttribute > "u")
                            return f.prop(c, h, g);
                        if ((_ !== 1 || !f.isXMLDoc(c)) && (y = f.attrHooks[h.toLowerCase()] || (f.expr.match.bool.test(h) ? Os : void 0)),
                        g !== void 0) {
                            if (g === null) {
                                f.removeAttr(c, h);
                                return
                            }
                            return y && "set"in y && (m = y.set(c, g, h)) !== void 0 ? m : (c.setAttribute(h, g + ""),
                            g)
                        }
                        return y && "get"in y && (m = y.get(c, h)) !== null ? m : (m = f.find.attr(c, h),
                        m ?? void 0)
                    }
                }, "attr"),
                attrHooks: {
                    type: {
                        set: o(function(c, h) {
                            if (!w.radioValue && h === "radio" && Q(c, "input")) {
                                var g = c.value;
                                return c.setAttribute("type", h),
                                g && (c.value = g),
                                h
                            }
                        }, "set")
                    }
                },
                removeAttr: o(function(c, h) {
                    var g, m = 0, y = h && h.match(ye);
                    if (y && c.nodeType === 1)
                        for (; g = y[m++]; )
                            c.removeAttribute(g)
                }, "removeAttr")
            }),
            Os = {
                set: o(function(c, h, g) {
                    return h === !1 ? f.removeAttr(c, g) : c.setAttribute(g, g),
                    g
                }, "set")
            },
            f.each(f.expr.match.bool.source.match(/\w+/g), function(c, h) {
                var g = ln[h] || f.find.attr;
                ln[h] = function(m, y, _) {
                    var S, N, D = y.toLowerCase();
                    return _ || (N = ln[D],
                    ln[D] = S,
                    S = g(m, y, _) != null ? D : null,
                    ln[D] = N),
                    S
                }
            });
            var ml = /^(?:input|select|textarea|button)$/i
              , vl = /^(?:a|area)$/i;
            f.fn.extend({
                prop: o(function(c, h) {
                    return Re(this, f.prop, c, h, arguments.length > 1)
                }, "prop"),
                removeProp: o(function(c) {
                    return this.each(function() {
                        delete this[f.propFix[c] || c]
                    })
                }, "removeProp")
            }),
            f.extend({
                prop: o(function(c, h, g) {
                    var m, y, _ = c.nodeType;
                    if (!(_ === 3 || _ === 8 || _ === 2))
                        return (_ !== 1 || !f.isXMLDoc(c)) && (h = f.propFix[h] || h,
                        y = f.propHooks[h]),
                        g !== void 0 ? y && "set"in y && (m = y.set(c, g, h)) !== void 0 ? m : c[h] = g : y && "get"in y && (m = y.get(c, h)) !== null ? m : c[h]
                }, "prop"),
                propHooks: {
                    tabIndex: {
                        get: o(function(c) {
                            var h = f.find.attr(c, "tabindex");
                            return h ? parseInt(h, 10) : ml.test(c.nodeName) || vl.test(c.nodeName) && c.href ? 0 : -1
                        }, "get")
                    }
                },
                propFix: {
                    for: "htmlFor",
                    class: "className"
                }
            }),
            w.optSelected || (f.propHooks.selected = {
                get: o(function(c) {
                    var h = c.parentNode;
                    return h && h.parentNode && h.parentNode.selectedIndex,
                    null
                }, "get"),
                set: o(function(c) {
                    var h = c.parentNode;
                    h && (h.selectedIndex,
                    h.parentNode && h.parentNode.selectedIndex)
                }, "set")
            }),
            f.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
                f.propFix[this.toLowerCase()] = this
            });
            function Fi(c) {
                var h = c.match(ye) || [];
                return h.join(" ")
            }
            o(Fi, "stripAndCollapse");
            function Vi(c) {
                return c.getAttribute && c.getAttribute("class") || ""
            }
            o(Vi, "getClass");
            function Lr(c) {
                return Array.isArray(c) ? c : typeof c == "string" ? c.match(ye) || [] : []
            }
            o(Lr, "classesToArray"),
            f.fn.extend({
                addClass: o(function(c) {
                    var h, g, m, y, _, S;
                    return C(c) ? this.each(function(N) {
                        f(this).addClass(c.call(this, N, Vi(this)))
                    }) : (h = Lr(c),
                    h.length ? this.each(function() {
                        if (m = Vi(this),
                        g = this.nodeType === 1 && " " + Fi(m) + " ",
                        g) {
                            for (_ = 0; _ < h.length; _++)
                                y = h[_],
                                g.indexOf(" " + y + " ") < 0 && (g += y + " ");
                            S = Fi(g),
                            m !== S && this.setAttribute("class", S)
                        }
                    }) : this)
                }, "addClass"),
                removeClass: o(function(c) {
                    var h, g, m, y, _, S;
                    return C(c) ? this.each(function(N) {
                        f(this).removeClass(c.call(this, N, Vi(this)))
                    }) : arguments.length ? (h = Lr(c),
                    h.length ? this.each(function() {
                        if (m = Vi(this),
                        g = this.nodeType === 1 && " " + Fi(m) + " ",
                        g) {
                            for (_ = 0; _ < h.length; _++)
                                for (y = h[_]; g.indexOf(" " + y + " ") > -1; )
                                    g = g.replace(" " + y + " ", " ");
                            S = Fi(g),
                            m !== S && this.setAttribute("class", S)
                        }
                    }) : this) : this.attr("class", "")
                }, "removeClass"),
                toggleClass: o(function(c, h) {
                    var g, m, y, _, S = typeof c, N = S === "string" || Array.isArray(c);
                    return C(c) ? this.each(function(D) {
                        f(this).toggleClass(c.call(this, D, Vi(this), h), h)
                    }) : typeof h == "boolean" && N ? h ? this.addClass(c) : this.removeClass(c) : (g = Lr(c),
                    this.each(function() {
                        if (N)
                            for (_ = f(this),
                            y = 0; y < g.length; y++)
                                m = g[y],
                                _.hasClass(m) ? _.removeClass(m) : _.addClass(m);
                        else
                            (c === void 0 || S === "boolean") && (m = Vi(this),
                            m && St.set(this, "__className__", m),
                            this.setAttribute && this.setAttribute("class", m || c === !1 ? "" : St.get(this, "__className__") || ""))
                    }))
                }, "toggleClass"),
                hasClass: o(function(c) {
                    var h, g, m = 0;
                    for (h = " " + c + " "; g = this[m++]; )
                        if (g.nodeType === 1 && (" " + Fi(Vi(g)) + " ").indexOf(h) > -1)
                            return !0;
                    return !1
                }, "hasClass")
            });
            var bl = /\r/g;
            f.fn.extend({
                val: o(function(c) {
                    var h, g, m, y = this[0];
                    return arguments.length ? (m = C(c),
                    this.each(function(_) {
                        var S;
                        this.nodeType === 1 && (m ? S = c.call(this, _, f(this).val()) : S = c,
                        S == null ? S = "" : typeof S == "number" ? S += "" : Array.isArray(S) && (S = f.map(S, function(N) {
                            return N == null ? "" : N + ""
                        })),
                        h = f.valHooks[this.type] || f.valHooks[this.nodeName.toLowerCase()],
                        (!h || !("set"in h) || h.set(this, S, "value") === void 0) && (this.value = S))
                    })) : y ? (h = f.valHooks[y.type] || f.valHooks[y.nodeName.toLowerCase()],
                    h && "get"in h && (g = h.get(y, "value")) !== void 0 ? g : (g = y.value,
                    typeof g == "string" ? g.replace(bl, "") : g ?? "")) : void 0
                }, "val")
            }),
            f.extend({
                valHooks: {
                    option: {
                        get: o(function(c) {
                            var h = f.find.attr(c, "value");
                            return h ?? Fi(f.text(c))
                        }, "get")
                    },
                    select: {
                        get: o(function(c) {
                            var h, g, m, y = c.options, _ = c.selectedIndex, S = c.type === "select-one", N = S ? null : [], D = S ? _ + 1 : y.length;
                            for (_ < 0 ? m = D : m = S ? _ : 0; m < D; m++)
                                if (g = y[m],
                                (g.selected || m === _) && !g.disabled && (!g.parentNode.disabled || !Q(g.parentNode, "optgroup"))) {
                                    if (h = f(g).val(),
                                    S)
                                        return h;
                                    N.push(h)
                                }
                            return N
                        }, "get"),
                        set: o(function(c, h) {
                            for (var g, m, y = c.options, _ = f.makeArray(h), S = y.length; S--; )
                                m = y[S],
                                (m.selected = f.inArray(f.valHooks.option.get(m), _) > -1) && (g = !0);
                            return g || (c.selectedIndex = -1),
                            _
                        }, "set")
                    }
                }
            }),
            f.each(["radio", "checkbox"], function() {
                f.valHooks[this] = {
                    set: o(function(c, h) {
                        if (Array.isArray(h))
                            return c.checked = f.inArray(f(c).val(), h) > -1
                    }, "set")
                },
                w.checkOn || (f.valHooks[this].get = function(c) {
                    return c.getAttribute("value") === null ? "on" : c.value
                }
                )
            });
            var Zn = n.location
              , Ls = {
                guid: Date.now()
            }
              , Ds = /\?/;
            f.parseXML = function(c) {
                var h, g;
                if (!c || typeof c != "string")
                    return null;
                try {
                    h = new n.DOMParser().parseFromString(c, "text/xml")
                } catch {}
                return g = h && h.getElementsByTagName("parsererror")[0],
                (!h || g) && f.error("Invalid XML: " + (g ? f.map(g.childNodes, function(m) {
                    return m.textContent
                }).join(`
`) : c)),
                h
            }
            ;
            var qo = /^(?:focusinfocus|focusoutblur)$/
              , ts = o(function(c) {
                c.stopPropagation()
            }, "stopPropagationCallback");
            f.extend(f.event, {
                trigger: o(function(c, h, g, m) {
                    var y, _, S, N, D, q, tt, it, G = [g || L], lt = b.call(c, "type") ? c.type : c, kt = b.call(c, "namespace") ? c.namespace.split(".") : [];
                    if (_ = it = S = g = g || L,
                    !(g.nodeType === 3 || g.nodeType === 8) && !qo.test(lt + f.event.triggered) && (lt.indexOf(".") > -1 && (kt = lt.split("."),
                    lt = kt.shift(),
                    kt.sort()),
                    D = lt.indexOf(":") < 0 && "on" + lt,
                    c = c[f.expando] ? c : new f.Event(lt,typeof c == "object" && c),
                    c.isTrigger = m ? 2 : 3,
                    c.namespace = kt.join("."),
                    c.rnamespace = c.namespace ? new RegExp("(^|\\.)" + kt.join("\\.(?:.*\\.|)") + "(\\.|$)") : null,
                    c.result = void 0,
                    c.target || (c.target = g),
                    h = h == null ? [c] : f.makeArray(h, [c]),
                    tt = f.event.special[lt] || {},
                    !(!m && tt.trigger && tt.trigger.apply(g, h) === !1))) {
                        if (!m && !tt.noBubble && !I(g)) {
                            for (N = tt.delegateType || lt,
                            qo.test(N + lt) || (_ = _.parentNode); _; _ = _.parentNode)
                                G.push(_),
                                S = _;
                            S === (g.ownerDocument || L) && G.push(S.defaultView || S.parentWindow || n)
                        }
                        for (y = 0; (_ = G[y++]) && !c.isPropagationStopped(); )
                            it = _,
                            c.type = y > 1 ? N : tt.bindType || lt,
                            q = (St.get(_, "events") || Object.create(null))[c.type] && St.get(_, "handle"),
                            q && q.apply(_, h),
                            q = D && _[D],
                            q && q.apply && Ji(_) && (c.result = q.apply(_, h),
                            c.result === !1 && c.preventDefault());
                        return c.type = lt,
                        !m && !c.isDefaultPrevented() && (!tt._default || tt._default.apply(G.pop(), h) === !1) && Ji(g) && D && C(g[lt]) && !I(g) && (S = g[D],
                        S && (g[D] = null),
                        f.event.triggered = lt,
                        c.isPropagationStopped() && it.addEventListener(lt, ts),
                        g[lt](),
                        c.isPropagationStopped() && it.removeEventListener(lt, ts),
                        f.event.triggered = void 0,
                        S && (g[D] = S)),
                        c.result
                    }
                }, "trigger"),
                simulate: o(function(c, h, g) {
                    var m = f.extend(new f.Event, g, {
                        type: c,
                        isSimulated: !0
                    });
                    f.event.trigger(m, null, h)
                }, "simulate")
            }),
            f.fn.extend({
                trigger: o(function(c, h) {
                    return this.each(function() {
                        f.event.trigger(c, h, this)
                    })
                }, "trigger"),
                triggerHandler: o(function(c, h) {
                    var g = this[0];
                    if (g)
                        return f.event.trigger(c, h, g, !0)
                }, "triggerHandler")
            });
            var Je = /\[\]$/
              , zo = /\r?\n/g
              , yl = /^(?:submit|button|image|reset|file)$/i
              , _l = /^(?:input|select|textarea|keygen)/i;
            function Ps(c, h, g, m) {
                var y;
                if (Array.isArray(h))
                    f.each(h, function(_, S) {
                        g || Je.test(c) ? m(c, S) : Ps(c + "[" + (typeof S == "object" && S != null ? _ : "") + "]", S, g, m)
                    });
                else if (!g && z(h) === "object")
                    for (y in h)
                        Ps(c + "[" + y + "]", h[y], g, m);
                else
                    m(c, h)
            }
            o(Ps, "buildParams"),
            f.param = function(c, h) {
                var g, m = [], y = o(function(_, S) {
                    var N = C(S) ? S() : S;
                    m[m.length] = encodeURIComponent(_) + "=" + encodeURIComponent(N ?? "")
                }, "add");
                if (c == null)
                    return "";
                if (Array.isArray(c) || c.jquery && !f.isPlainObject(c))
                    f.each(c, function() {
                        y(this.name, this.value)
                    });
                else
                    for (g in c)
                        Ps(g, c[g], h, y);
                return m.join("&")
            }
            ,
            f.fn.extend({
                serialize: o(function() {
                    return f.param(this.serializeArray())
                }, "serialize"),
                serializeArray: o(function() {
                    return this.map(function() {
                        var c = f.prop(this, "elements");
                        return c ? f.makeArray(c) : this
                    }).filter(function() {
                        var c = this.type;
                        return this.name && !f(this).is(":disabled") && _l.test(this.nodeName) && !yl.test(c) && (this.checked || !en.test(c))
                    }).map(function(c, h) {
                        var g = f(this).val();
                        return g == null ? null : Array.isArray(g) ? f.map(g, function(m) {
                            return {
                                name: h.name,
                                value: m.replace(zo, `\r
`)
                            }
                        }) : {
                            name: h.name,
                            value: g.replace(zo, `\r
`)
                        }
                    }).get()
                }, "serializeArray")
            });
            var El = /%20/g
              , Rs = /#.*$/
              , Sl = /([?&])_=[^&]*/
              , Dr = /^(.*?):[ \t]*([^\r\n]*)$/mg
              , Tl = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/
              , xl = /^(?:GET|HEAD)$/
              , wl = /^\/\//
              , Uo = {}
              , Pr = {}
              , Ko = "*/".concat("*")
              , Rr = L.createElement("a");
            Rr.href = Zn.href;
            function Yo(c) {
                return function(h, g) {
                    typeof h != "string" && (g = h,
                    h = "*");
                    var m, y = 0, _ = h.toLowerCase().match(ye) || [];
                    if (C(g))
                        for (; m = _[y++]; )
                            m[0] === "+" ? (m = m.slice(1) || "*",
                            (c[m] = c[m] || []).unshift(g)) : (c[m] = c[m] || []).push(g)
                }
            }
            o(Yo, "addToPrefiltersOrTransports");
            function Xo(c, h, g, m) {
                var y = {}
                  , _ = c === Pr;
                function S(N) {
                    var D;
                    return y[N] = !0,
                    f.each(c[N] || [], function(q, tt) {
                        var it = tt(h, g, m);
                        if (typeof it == "string" && !_ && !y[it])
                            return h.dataTypes.unshift(it),
                            S(it),
                            !1;
                        if (_)
                            return !(D = it)
                    }),
                    D
                }
                return o(S, "inspect"),
                S(h.dataTypes[0]) || !y["*"] && S("*")
            }
            o(Xo, "inspectPrefiltersOrTransports");
            function Ir(c, h) {
                var g, m, y = f.ajaxSettings.flatOptions || {};
                for (g in h)
                    h[g] !== void 0 && ((y[g] ? c : m || (m = {}))[g] = h[g]);
                return m && f.extend(!0, c, m),
                c
            }
            o(Ir, "ajaxExtend");
            function Bi(c, h, g) {
                for (var m, y, _, S, N = c.contents, D = c.dataTypes; D[0] === "*"; )
                    D.shift(),
                    m === void 0 && (m = c.mimeType || h.getResponseHeader("Content-Type"));
                if (m) {
                    for (y in N)
                        if (N[y] && N[y].test(m)) {
                            D.unshift(y);
                            break
                        }
                }
                if (D[0]in g)
                    _ = D[0];
                else {
                    for (y in g) {
                        if (!D[0] || c.converters[y + " " + D[0]]) {
                            _ = y;
                            break
                        }
                        S || (S = y)
                    }
                    _ = _ || S
                }
                if (_)
                    return _ !== D[0] && D.unshift(_),
                    g[_]
            }
            o(Bi, "ajaxHandleResponses");
            function Sn(c, h, g, m) {
                var y, _, S, N, D, q = {}, tt = c.dataTypes.slice();
                if (tt[1])
                    for (S in c.converters)
                        q[S.toLowerCase()] = c.converters[S];
                for (_ = tt.shift(); _; )
                    if (c.responseFields[_] && (g[c.responseFields[_]] = h),
                    !D && m && c.dataFilter && (h = c.dataFilter(h, c.dataType)),
                    D = _,
                    _ = tt.shift(),
                    _) {
                        if (_ === "*")
                            _ = D;
                        else if (D !== "*" && D !== _) {
                            if (S = q[D + " " + _] || q["* " + _],
                            !S) {
                                for (y in q)
                                    if (N = y.split(" "),
                                    N[1] === _ && (S = q[D + " " + N[0]] || q["* " + N[0]],
                                    S)) {
                                        S === !0 ? S = q[y] : q[y] !== !0 && (_ = N[0],
                                        tt.unshift(N[1]));
                                        break
                                    }
                            }
                            if (S !== !0)
                                if (S && c.throws)
                                    h = S(h);
                                else
                                    try {
                                        h = S(h)
                                    } catch (it) {
                                        return {
                                            state: "parsererror",
                                            error: S ? it : "No conversion from " + D + " to " + _
                                        }
                                    }
                        }
                    }
                return {
                    state: "success",
                    data: h
                }
            }
            o(Sn, "ajaxConvert"),
            f.extend({
                active: 0,
                lastModified: {},
                etag: {},
                ajaxSettings: {
                    url: Zn.href,
                    type: "GET",
                    isLocal: Tl.test(Zn.protocol),
                    global: !0,
                    processData: !0,
                    async: !0,
                    contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                    accepts: {
                        "*": Ko,
                        text: "text/plain",
                        html: "text/html",
                        xml: "application/xml, text/xml",
                        json: "application/json, text/javascript"
                    },
                    contents: {
                        xml: /\bxml\b/,
                        html: /\bhtml/,
                        json: /\bjson\b/
                    },
                    responseFields: {
                        xml: "responseXML",
                        text: "responseText",
                        json: "responseJSON"
                    },
                    converters: {
                        "* text": String,
                        "text html": !0,
                        "text json": JSON.parse,
                        "text xml": f.parseXML
                    },
                    flatOptions: {
                        url: !0,
                        context: !0
                    }
                },
                ajaxSetup: o(function(c, h) {
                    return h ? Ir(Ir(c, f.ajaxSettings), h) : Ir(f.ajaxSettings, c)
                }, "ajaxSetup"),
                ajaxPrefilter: Yo(Uo),
                ajaxTransport: Yo(Pr),
                ajax: o(function(c, h) {
                    typeof c == "object" && (h = c,
                    c = void 0),
                    h = h || {};
                    var g, m, y, _, S, N, D, q, tt, it, G = f.ajaxSetup({}, h), lt = G.context || G, kt = G.context && (lt.nodeType || lt.jquery) ? f(lt) : f.event, Wt = f.Deferred(), Pt = f.Callbacks("once memory"), le = G.statusCode || {}, ce = {}, Ze = {}, fi = "canceled", Bt = {
                        readyState: 0,
                        getResponseHeader: o(function(qt) {
                            var oe;
                            if (D) {
                                if (!_)
                                    for (_ = {}; oe = Dr.exec(y); )
                                        _[oe[1].toLowerCase() + " "] = (_[oe[1].toLowerCase() + " "] || []).concat(oe[2]);
                                oe = _[qt.toLowerCase() + " "]
                            }
                            return oe == null ? null : oe.join(", ")
                        }, "getResponseHeader"),
                        getAllResponseHeaders: o(function() {
                            return D ? y : null
                        }, "getAllResponseHeaders"),
                        setRequestHeader: o(function(qt, oe) {
                            return D == null && (qt = Ze[qt.toLowerCase()] = Ze[qt.toLowerCase()] || qt,
                            ce[qt] = oe),
                            this
                        }, "setRequestHeader"),
                        overrideMimeType: o(function(qt) {
                            return D == null && (G.mimeType = qt),
                            this
                        }, "overrideMimeType"),
                        statusCode: o(function(qt) {
                            var oe;
                            if (qt)
                                if (D)
                                    Bt.always(qt[Bt.status]);
                                else
                                    for (oe in qt)
                                        le[oe] = [le[oe], qt[oe]];
                            return this
                        }, "statusCode"),
                        abort: o(function(qt) {
                            var oe = qt || fi;
                            return g && g.abort(oe),
                            cn(0, oe),
                            this
                        }, "abort")
                    };
                    if (Wt.promise(Bt),
                    G.url = ((c || G.url || Zn.href) + "").replace(wl, Zn.protocol + "//"),
                    G.type = h.method || h.type || G.method || G.type,
                    G.dataTypes = (G.dataType || "*").toLowerCase().match(ye) || [""],
                    G.crossDomain == null) {
                        N = L.createElement("a");
                        try {
                            N.href = G.url,
                            N.href = N.href,
                            G.crossDomain = Rr.protocol + "//" + Rr.host != N.protocol + "//" + N.host
                        } catch {
                            G.crossDomain = !0
                        }
                    }
                    if (G.data && G.processData && typeof G.data != "string" && (G.data = f.param(G.data, G.traditional)),
                    Xo(Uo, G, h, Bt),
                    D)
                        return Bt;
                    q = f.event && G.global,
                    q && f.active++ === 0 && f.event.trigger("ajaxStart"),
                    G.type = G.type.toUpperCase(),
                    G.hasContent = !xl.test(G.type),
                    m = G.url.replace(Rs, ""),
                    G.hasContent ? G.data && G.processData && (G.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && (G.data = G.data.replace(El, "+")) : (it = G.url.slice(m.length),
                    G.data && (G.processData || typeof G.data == "string") && (m += (Ds.test(m) ? "&" : "?") + G.data,
                    delete G.data),
                    G.cache === !1 && (m = m.replace(Sl, "$1"),
                    it = (Ds.test(m) ? "&" : "?") + "_=" + Ls.guid++ + it),
                    G.url = m + it),
                    G.ifModified && (f.lastModified[m] && Bt.setRequestHeader("If-Modified-Since", f.lastModified[m]),
                    f.etag[m] && Bt.setRequestHeader("If-None-Match", f.etag[m])),
                    (G.data && G.hasContent && G.contentType !== !1 || h.contentType) && Bt.setRequestHeader("Content-Type", G.contentType),
                    Bt.setRequestHeader("Accept", G.dataTypes[0] && G.accepts[G.dataTypes[0]] ? G.accepts[G.dataTypes[0]] + (G.dataTypes[0] !== "*" ? ", " + Ko + "; q=0.01" : "") : G.accepts["*"]);
                    for (tt in G.headers)
                        Bt.setRequestHeader(tt, G.headers[tt]);
                    if (G.beforeSend && (G.beforeSend.call(lt, Bt, G) === !1 || D))
                        return Bt.abort();
                    if (fi = "abort",
                    Pt.add(G.complete),
                    Bt.done(G.success),
                    Bt.fail(G.error),
                    g = Xo(Pr, G, h, Bt),
                    !g)
                        cn(-1, "No Transport");
                    else {
                        if (Bt.readyState = 1,
                        q && kt.trigger("ajaxSend", [Bt, G]),
                        D)
                            return Bt;
                        G.async && G.timeout > 0 && (S = n.setTimeout(function() {
                            Bt.abort("timeout")
                        }, G.timeout));
                        try {
                            D = !1,
                            g.send(ce, cn)
                        } catch (qt) {
                            if (D)
                                throw qt;
                            cn(-1, qt)
                        }
                    }
                    function cn(qt, oe, Tn, un) {
                        var pi, es, gi, Hi, ji, je = oe;
                        D || (D = !0,
                        S && n.clearTimeout(S),
                        g = void 0,
                        y = un || "",
                        Bt.readyState = qt > 0 ? 4 : 0,
                        pi = qt >= 200 && qt < 300 || qt === 304,
                        Tn && (Hi = Bi(G, Bt, Tn)),
                        !pi && f.inArray("script", G.dataTypes) > -1 && f.inArray("json", G.dataTypes) < 0 && (G.converters["text script"] = function() {}
                        ),
                        Hi = Sn(G, Hi, Bt, pi),
                        pi ? (G.ifModified && (ji = Bt.getResponseHeader("Last-Modified"),
                        ji && (f.lastModified[m] = ji),
                        ji = Bt.getResponseHeader("etag"),
                        ji && (f.etag[m] = ji)),
                        qt === 204 || G.type === "HEAD" ? je = "nocontent" : qt === 304 ? je = "notmodified" : (je = Hi.state,
                        es = Hi.data,
                        gi = Hi.error,
                        pi = !gi)) : (gi = je,
                        (qt || !je) && (je = "error",
                        qt < 0 && (qt = 0))),
                        Bt.status = qt,
                        Bt.statusText = (oe || je) + "",
                        pi ? Wt.resolveWith(lt, [es, je, Bt]) : Wt.rejectWith(lt, [Bt, je, gi]),
                        Bt.statusCode(le),
                        le = void 0,
                        q && kt.trigger(pi ? "ajaxSuccess" : "ajaxError", [Bt, G, pi ? es : gi]),
                        Pt.fireWith(lt, [Bt, je]),
                        q && (kt.trigger("ajaxComplete", [Bt, G]),
                        --f.active || f.event.trigger("ajaxStop")))
                    }
                    return o(cn, "done"),
                    Bt
                }, "ajax"),
                getJSON: o(function(c, h, g) {
                    return f.get(c, h, g, "json")
                }, "getJSON"),
                getScript: o(function(c, h) {
                    return f.get(c, void 0, h, "script")
                }, "getScript")
            }),
            f.each(["get", "post"], function(c, h) {
                f[h] = function(g, m, y, _) {
                    return C(m) && (_ = _ || y,
                    y = m,
                    m = void 0),
                    f.ajax(f.extend({
                        url: g,
                        type: h,
                        dataType: _,
                        data: m,
                        success: y
                    }, f.isPlainObject(g) && g))
                }
            }),
            f.ajaxPrefilter(function(c) {
                var h;
                for (h in c.headers)
                    h.toLowerCase() === "content-type" && (c.contentType = c.headers[h] || "")
            }),
            f._evalUrl = function(c, h, g) {
                return f.ajax({
                    url: c,
                    type: "GET",
                    dataType: "script",
                    cache: !0,
                    async: !1,
                    global: !1,
                    converters: {
                        "text script": o(function() {}, "text script")
                    },
                    dataFilter: o(function(m) {
                        f.globalEval(m, h, g)
                    }, "dataFilter")
                })
            }
            ,
            f.fn.extend({
                wrapAll: o(function(c) {
                    var h;
                    return this[0] && (C(c) && (c = c.call(this[0])),
                    h = f(c, this[0].ownerDocument).eq(0).clone(!0),
                    this[0].parentNode && h.insertBefore(this[0]),
                    h.map(function() {
                        for (var g = this; g.firstElementChild; )
                            g = g.firstElementChild;
                        return g
                    }).append(this)),
                    this
                }, "wrapAll"),
                wrapInner: o(function(c) {
                    return C(c) ? this.each(function(h) {
                        f(this).wrapInner(c.call(this, h))
                    }) : this.each(function() {
                        var h = f(this)
                          , g = h.contents();
                        g.length ? g.wrapAll(c) : h.append(c)
                    })
                }, "wrapInner"),
                wrap: o(function(c) {
                    var h = C(c);
                    return this.each(function(g) {
                        f(this).wrapAll(h ? c.call(this, g) : c)
                    })
                }, "wrap"),
                unwrap: o(function(c) {
                    return this.parent(c).not("body").each(function() {
                        f(this).replaceWith(this.childNodes)
                    }),
                    this
                }, "unwrap")
            }),
            f.expr.pseudos.hidden = function(c) {
                return !f.expr.pseudos.visible(c)
            }
            ,
            f.expr.pseudos.visible = function(c) {
                return !!(c.offsetWidth || c.offsetHeight || c.getClientRects().length)
            }
            ,
            f.ajaxSettings.xhr = function() {
                try {
                    return new n.XMLHttpRequest
                } catch {}
            }
            ;
            var Cl = {
                0: 200,
                1223: 204
            }
              , wi = f.ajaxSettings.xhr();
            w.cors = !!wi && "withCredentials"in wi,
            w.ajax = wi = !!wi,
            f.ajaxTransport(function(c) {
                var h, g;
                if (w.cors || wi && !c.crossDomain)
                    return {
                        send: o(function(m, y) {
                            var _, S = c.xhr();
                            if (S.open(c.type, c.url, c.async, c.username, c.password),
                            c.xhrFields)
                                for (_ in c.xhrFields)
                                    S[_] = c.xhrFields[_];
                            c.mimeType && S.overrideMimeType && S.overrideMimeType(c.mimeType),
                            !c.crossDomain && !m["X-Requested-With"] && (m["X-Requested-With"] = "XMLHttpRequest");
                            for (_ in m)
                                S.setRequestHeader(_, m[_]);
                            h = o(function(N) {
                                return function() {
                                    h && (h = g = S.onload = S.onerror = S.onabort = S.ontimeout = S.onreadystatechange = null,
                                    N === "abort" ? S.abort() : N === "error" ? typeof S.status != "number" ? y(0, "error") : y(S.status, S.statusText) : y(Cl[S.status] || S.status, S.statusText, (S.responseType || "text") !== "text" || typeof S.responseText != "string" ? {
                                        binary: S.response
                                    } : {
                                        text: S.responseText
                                    }, S.getAllResponseHeaders()))
                                }
                            }, "callback"),
                            S.onload = h(),
                            g = S.onerror = S.ontimeout = h("error"),
                            S.onabort !== void 0 ? S.onabort = g : S.onreadystatechange = function() {
                                S.readyState === 4 && n.setTimeout(function() {
                                    h && g()
                                })
                            }
                            ,
                            h = h("abort");
                            try {
                                S.send(c.hasContent && c.data || null)
                            } catch (N) {
                                if (h)
                                    throw N
                            }
                        }, "send"),
                        abort: o(function() {
                            h && h()
                        }, "abort")
                    }
            }),
            f.ajaxPrefilter(function(c) {
                c.crossDomain && (c.contents.script = !1)
            }),
            f.ajaxSetup({
                accepts: {
                    script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
                },
                contents: {
                    script: /\b(?:java|ecma)script\b/
                },
                converters: {
                    "text script": o(function(c) {
                        return f.globalEval(c),
                        c
                    }, "text script")
                }
            }),
            f.ajaxPrefilter("script", function(c) {
                c.cache === void 0 && (c.cache = !1),
                c.crossDomain && (c.type = "GET")
            }),
            f.ajaxTransport("script", function(c) {
                if (c.crossDomain || c.scriptAttrs) {
                    var h, g;
                    return {
                        send: o(function(m, y) {
                            h = f("<script>").attr(c.scriptAttrs || {}).prop({
                                charset: c.scriptCharset,
                                src: c.url
                            }).on("load error", g = o(function(_) {
                                h.remove(),
                                g = null,
                                _ && y(_.type === "error" ? 404 : 200, _.type)
                            }, "callback")),
                            L.head.appendChild(h[0])
                        }, "send"),
                        abort: o(function() {
                            g && g()
                        }, "abort")
                    }
                }
            });
            var Le = []
              , Nr = /(=)\?(?=&|$)|\?\?/;
            f.ajaxSetup({
                jsonp: "callback",
                jsonpCallback: o(function() {
                    var c = Le.pop() || f.expando + "_" + Ls.guid++;
                    return this[c] = !0,
                    c
                }, "jsonpCallback")
            }),
            f.ajaxPrefilter("json jsonp", function(c, h, g) {
                var m, y, _, S = c.jsonp !== !1 && (Nr.test(c.url) ? "url" : typeof c.data == "string" && (c.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && Nr.test(c.data) && "data");
                if (S || c.dataTypes[0] === "jsonp")
                    return m = c.jsonpCallback = C(c.jsonpCallback) ? c.jsonpCallback() : c.jsonpCallback,
                    S ? c[S] = c[S].replace(Nr, "$1" + m) : c.jsonp !== !1 && (c.url += (Ds.test(c.url) ? "&" : "?") + c.jsonp + "=" + m),
                    c.converters["script json"] = function() {
                        return _ || f.error(m + " was not called"),
                        _[0]
                    }
                    ,
                    c.dataTypes[0] = "json",
                    y = n[m],
                    n[m] = function() {
                        _ = arguments
                    }
                    ,
                    g.always(function() {
                        y === void 0 ? f(n).removeProp(m) : n[m] = y,
                        c[m] && (c.jsonpCallback = h.jsonpCallback,
                        Le.push(m)),
                        _ && C(y) && y(_[0]),
                        _ = y = void 0
                    }),
                    "script"
            }),
            w.createHTMLDocument = (function() {
                var c = L.implementation.createHTMLDocument("").body;
                return c.innerHTML = "<form></form><form></form>",
                c.childNodes.length === 2
            }
            )(),
            f.parseHTML = function(c, h, g) {
                if (typeof c != "string")
                    return [];
                typeof h == "boolean" && (g = h,
                h = !1);
                var m, y, _;
                return h || (w.createHTMLDocument ? (h = L.implementation.createHTMLDocument(""),
                m = h.createElement("base"),
                m.href = L.location.href,
                h.head.appendChild(m)) : h = L),
                y = ci.exec(c),
                _ = !g && [],
                y ? [h.createElement(y[1])] : (y = rt([c], h, _),
                _ && _.length && f(_).remove(),
                f.merge([], y.childNodes))
            }
            ,
            f.fn.load = function(c, h, g) {
                var m, y, _, S = this, N = c.indexOf(" ");
                return N > -1 && (m = Fi(c.slice(N)),
                c = c.slice(0, N)),
                C(h) ? (g = h,
                h = void 0) : h && typeof h == "object" && (y = "POST"),
                S.length > 0 && f.ajax({
                    url: c,
                    type: y || "GET",
                    dataType: "html",
                    data: h
                }).done(function(D) {
                    _ = arguments,
                    S.html(m ? f("<div>").append(f.parseHTML(D)).find(m) : D)
                }).always(g && function(D, q) {
                    S.each(function() {
                        g.apply(this, _ || [D.responseText, q, D])
                    })
                }
                ),
                this
            }
            ,
            f.expr.pseudos.animated = function(c) {
                return f.grep(f.timers, function(h) {
                    return c === h.elem
                }).length
            }
            ,
            f.offset = {
                setOffset: o(function(c, h, g) {
                    var m, y, _, S, N, D, q, tt = f.css(c, "position"), it = f(c), G = {};
                    tt === "static" && (c.style.position = "relative"),
                    N = it.offset(),
                    _ = f.css(c, "top"),
                    D = f.css(c, "left"),
                    q = (tt === "absolute" || tt === "fixed") && (_ + D).indexOf("auto") > -1,
                    q ? (m = it.position(),
                    S = m.top,
                    y = m.left) : (S = parseFloat(_) || 0,
                    y = parseFloat(D) || 0),
                    C(h) && (h = h.call(c, g, f.extend({}, N))),
                    h.top != null && (G.top = h.top - N.top + S),
                    h.left != null && (G.left = h.left - N.left + y),
                    "using"in h ? h.using.call(c, G) : it.css(G)
                }, "setOffset")
            },
            f.fn.extend({
                offset: o(function(c) {
                    if (arguments.length)
                        return c === void 0 ? this : this.each(function(y) {
                            f.offset.setOffset(this, c, y)
                        });
                    var h, g, m = this[0];
                    if (m)
                        return m.getClientRects().length ? (h = m.getBoundingClientRect(),
                        g = m.ownerDocument.defaultView,
                        {
                            top: h.top + g.pageYOffset,
                            left: h.left + g.pageXOffset
                        }) : {
                            top: 0,
                            left: 0
                        }
                }, "offset"),
                position: o(function() {
                    if (this[0]) {
                        var c, h, g, m = this[0], y = {
                            top: 0,
                            left: 0
                        };
                        if (f.css(m, "position") === "fixed")
                            h = m.getBoundingClientRect();
                        else {
                            for (h = this.offset(),
                            g = m.ownerDocument,
                            c = m.offsetParent || g.documentElement; c && (c === g.body || c === g.documentElement) && f.css(c, "position") === "static"; )
                                c = c.parentNode;
                            c && c !== m && c.nodeType === 1 && (y = f(c).offset(),
                            y.top += f.css(c, "borderTopWidth", !0),
                            y.left += f.css(c, "borderLeftWidth", !0))
                        }
                        return {
                            top: h.top - y.top - f.css(m, "marginTop", !0),
                            left: h.left - y.left - f.css(m, "marginLeft", !0)
                        }
                    }
                }, "position"),
                offsetParent: o(function() {
                    return this.map(function() {
                        for (var c = this.offsetParent; c && f.css(c, "position") === "static"; )
                            c = c.offsetParent;
                        return c || hi
                    })
                }, "offsetParent")
            }),
            f.each({
                scrollLeft: "pageXOffset",
                scrollTop: "pageYOffset"
            }, function(c, h) {
                var g = h === "pageYOffset";
                f.fn[c] = function(m) {
                    return Re(this, function(y, _, S) {
                        var N;
                        if (I(y) ? N = y : y.nodeType === 9 && (N = y.defaultView),
                        S === void 0)
                            return N ? N[h] : y[_];
                        N ? N.scrollTo(g ? N.pageXOffset : S, g ? S : N.pageYOffset) : y[_] = S
                    }, c, m, arguments.length)
                }
            }),
            f.each(["top", "left"], function(c, h) {
                f.cssHooks[h] = Fo(w.pixelPosition, function(g, m) {
                    if (m)
                        return m = sn(g, h),
                        Xn.test(m) ? f(g).position()[h] + "px" : m
                })
            }),
            f.each({
                Height: "height",
                Width: "width"
            }, function(c, h) {
                f.each({
                    padding: "inner" + c,
                    content: h,
                    "": "outer" + c
                }, function(g, m) {
                    f.fn[m] = function(y, _) {
                        var S = arguments.length && (g || typeof y != "boolean")
                          , N = g || (y === !0 || _ === !0 ? "margin" : "border");
                        return Re(this, function(D, q, tt) {
                            var it;
                            return I(D) ? m.indexOf("outer") === 0 ? D["inner" + c] : D.document.documentElement["client" + c] : D.nodeType === 9 ? (it = D.documentElement,
                            Math.max(D.body["scroll" + c], it["scroll" + c], D.body["offset" + c], it["offset" + c], it["client" + c])) : tt === void 0 ? f.css(D, q, N) : f.style(D, q, tt, N)
                        }, h, S ? y : void 0, S)
                    }
                })
            }),
            f.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(c, h) {
                f.fn[h] = function(g) {
                    return this.on(h, g)
                }
            }),
            f.fn.extend({
                bind: o(function(c, h, g) {
                    return this.on(c, null, h, g)
                }, "bind"),
                unbind: o(function(c, h) {
                    return this.off(c, null, h)
                }, "unbind"),
                delegate: o(function(c, h, g, m) {
                    return this.on(h, c, g, m)
                }, "delegate"),
                undelegate: o(function(c, h, g) {
                    return arguments.length === 1 ? this.off(c, "**") : this.off(h, c || "**", g)
                }, "undelegate"),
                hover: o(function(c, h) {
                    return this.on("mouseenter", c).on("mouseleave", h || c)
                }, "hover")
            }),
            f.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(c, h) {
                f.fn[h] = function(g, m) {
                    return arguments.length > 0 ? this.on(h, null, g, m) : this.trigger(h)
                }
            });
            var Al = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
            f.proxy = function(c, h) {
                var g, m, y;
                if (typeof h == "string" && (g = c[h],
                h = c,
                c = g),
                !!C(c))
                    return m = r.call(arguments, 2),
                    y = o(function() {
                        return c.apply(h || this, m.concat(r.call(arguments)))
                    }, "proxy"),
                    y.guid = c.guid = c.guid || f.guid++,
                    y
            }
            ,
            f.holdReady = function(c) {
                c ? f.readyWait++ : f.ready(!0)
            }
            ,
            f.isArray = Array.isArray,
            f.parseJSON = JSON.parse,
            f.nodeName = Q,
            f.isFunction = C,
            f.isWindow = I,
            f.camelCase = Fe,
            f.type = z,
            f.now = Date.now,
            f.isNumeric = function(c) {
                var h = f.type(c);
                return (h === "number" || h === "string") && !isNaN(c - parseFloat(c))
            }
            ,
            f.trim = function(c) {
                return c == null ? "" : (c + "").replace(Al, "$1")
            }
            ,
            typeof define == "function" && define.amd && define("jquery", [], function() {
                return f
            });
            var Go = n.jQuery
              , Fr = n.$;
            return f.noConflict = function(c) {
                return n.$ === f && (n.$ = Fr),
                c && n.jQuery === f && (n.jQuery = Go),
                f
            }
            ,
            typeof t > "u" && (n.jQuery = n.$ = f),
            f
        })
    }
    );
    var Yd = Kr( (Nl, Fl) => {
        (function(n, t) {
            typeof Nl == "object" && typeof Fl < "u" ? Fl.exports = t() : typeof define == "function" && define.amd ? define(t) : n.Popper = t()
        }
        )(Nl, (function() {
            "use strict";
            var n = typeof window < "u" && typeof document < "u" && typeof navigator < "u"
              , t = (function() {
                for (var T = ["Edge", "Trident", "Firefox"], R = 0; R < T.length; R += 1)
                    if (n && navigator.userAgent.indexOf(T[R]) >= 0)
                        return 1;
                return 0
            }
            )();
            function e(T) {
                var R = !1;
                return function() {
                    R || (R = !0,
                    window.Promise.resolve().then(function() {
                        R = !1,
                        T()
                    }))
                }
            }
            o(e, "microtaskDebounce");
            function s(T) {
                var R = !1;
                return function() {
                    R || (R = !0,
                    setTimeout(function() {
                        R = !1,
                        T()
                    }, t))
                }
            }
            o(s, "taskDebounce");
            var r = n && window.Promise
              , a = r ? e : s;
            function l(T) {
                var R = {};
                return T && R.toString.call(T) === "[object Function]"
            }
            o(l, "isFunction");
            function u(T, R) {
                if (T.nodeType !== 1)
                    return [];
                var W = T.ownerDocument.defaultView
                  , U = W.getComputedStyle(T, null);
                return R ? U[R] : U
            }
            o(u, "getStyleComputedProperty");
            function d(T) {
                return T.nodeName === "HTML" ? T : T.parentNode || T.host
            }
            o(d, "getParentNode");
            function p(T) {
                if (!T)
                    return document.body;
                switch (T.nodeName) {
                case "HTML":
                case "BODY":
                    return T.ownerDocument.body;
                case "#document":
                    return T.body
                }
                var R = u(T)
                  , W = R.overflow
                  , U = R.overflowX
                  , rt = R.overflowY;
                return /(auto|scroll|overlay)/.test(W + rt + U) ? T : p(d(T))
            }
            o(p, "getScrollParent");
            function b(T) {
                return T && T.referenceNode ? T.referenceNode : T
            }
            o(b, "getReferenceNode");
            var E = n && !!(window.MSInputMethodContext && document.documentMode)
              , x = n && /MSIE 10/.test(navigator.userAgent);
            function w(T) {
                return T === 11 ? E : T === 10 ? x : E || x
            }
            o(w, "isIE");
            function C(T) {
                if (!T)
                    return document.documentElement;
                for (var R = w(10) ? document.body : null, W = T.offsetParent || null; W === R && T.nextElementSibling; )
                    W = (T = T.nextElementSibling).offsetParent;
                var U = W && W.nodeName;
                return !U || U === "BODY" || U === "HTML" ? T ? T.ownerDocument.documentElement : document.documentElement : ["TH", "TD", "TABLE"].indexOf(W.nodeName) !== -1 && u(W, "position") === "static" ? C(W) : W
            }
            o(C, "getOffsetParent");
            function I(T) {
                var R = T.nodeName;
                return R === "BODY" ? !1 : R === "HTML" || C(T.firstElementChild) === T
            }
            o(I, "isOffsetContainer");
            function L(T) {
                return T.parentNode !== null ? L(T.parentNode) : T
            }
            o(L, "getRoot");
            function k(T, R) {
                if (!T || !T.nodeType || !R || !R.nodeType)
                    return document.documentElement;
                var W = T.compareDocumentPosition(R) & Node.DOCUMENT_POSITION_FOLLOWING
                  , U = W ? T : R
                  , rt = W ? R : T
                  , st = document.createRange();
                st.setStart(U, 0),
                st.setEnd(rt, 0);
                var at = st.commonAncestorContainer;
                if (T !== at && R !== at || U.contains(rt))
                    return I(at) ? at : C(at);
                var ut = L(T);
                return ut.host ? k(ut.host, R) : k(T, L(R).host)
            }
            o(k, "findCommonOffsetParent");
            function F(T) {
                var R = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "top"
                  , W = R === "top" ? "scrollTop" : "scrollLeft"
                  , U = T.nodeName;
                if (U === "BODY" || U === "HTML") {
                    var rt = T.ownerDocument.documentElement
                      , st = T.ownerDocument.scrollingElement || rt;
                    return st[W]
                }
                return T[W]
            }
            o(F, "getScroll");
            function z(T, R) {
                var W = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1
                  , U = F(R, "top")
                  , rt = F(R, "left")
                  , st = W ? -1 : 1;
                return T.top += U * st,
                T.bottom += U * st,
                T.left += rt * st,
                T.right += rt * st,
                T
            }
            o(z, "includeScroll");
            function j(T, R) {
                var W = R === "x" ? "Left" : "Top"
                  , U = W === "Left" ? "Right" : "Bottom";
                return parseFloat(T["border" + W + "Width"]) + parseFloat(T["border" + U + "Width"])
            }
            o(j, "getBordersSize");
            function H(T, R, W, U) {
                return Math.max(R["offset" + T], R["scroll" + T], W["client" + T], W["offset" + T], W["scroll" + T], w(10) ? parseInt(W["offset" + T]) + parseInt(U["margin" + (T === "Height" ? "Top" : "Left")]) + parseInt(U["margin" + (T === "Height" ? "Bottom" : "Right")]) : 0)
            }
            o(H, "getSize");
            function f(T) {
                var R = T.body
                  , W = T.documentElement
                  , U = w(10) && getComputedStyle(W);
                return {
                    height: H("Height", R, W, U),
                    width: H("Width", R, W, U)
                }
            }
            o(f, "getWindowSizes");
            var Y = o(function(T, R) {
                if (!(T instanceof R))
                    throw new TypeError("Cannot call a class as a function")
            }, "classCallCheck")
              , Q = (function() {
                function T(R, W) {
                    for (var U = 0; U < W.length; U++) {
                        var rt = W[U];
                        rt.enumerable = rt.enumerable || !1,
                        rt.configurable = !0,
                        "value"in rt && (rt.writable = !0),
                        Object.defineProperty(R, rt.key, rt)
                    }
                }
                return o(T, "defineProperties"),
                function(R, W, U) {
                    return W && T(R.prototype, W),
                    U && T(R, U),
                    R
                }
            }
            )()
              , ot = o(function(T, R, W) {
                return R in T ? Object.defineProperty(T, R, {
                    value: W,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : T[R] = W,
                T
            }, "defineProperty")
              , mt = Object.assign || function(T) {
                for (var R = 1; R < arguments.length; R++) {
                    var W = arguments[R];
                    for (var U in W)
                        Object.prototype.hasOwnProperty.call(W, U) && (T[U] = W[U])
                }
                return T
            }
            ;
            function bt(T) {
                return mt({}, T, {
                    right: T.left + T.width,
                    bottom: T.top + T.height
                })
            }
            o(bt, "getClientRect");
            function ft(T) {
                var R = {};
                try {
                    if (w(10)) {
                        R = T.getBoundingClientRect();
                        var W = F(T, "top")
                          , U = F(T, "left");
                        R.top += W,
                        R.left += U,
                        R.bottom += W,
                        R.right += U
                    } else
                        R = T.getBoundingClientRect()
                } catch {}
                var rt = {
                    left: R.left,
                    top: R.top,
                    width: R.right - R.left,
                    height: R.bottom - R.top
                }
                  , st = T.nodeName === "HTML" ? f(T.ownerDocument) : {}
                  , at = st.width || T.clientWidth || rt.width
                  , ut = st.height || T.clientHeight || rt.height
                  , dt = T.offsetWidth - at
                  , _t = T.offsetHeight - ut;
                if (dt || _t) {
                    var Tt = u(T);
                    dt -= j(Tt, "x"),
                    _t -= j(Tt, "y"),
                    rt.width -= dt,
                    rt.height -= _t
                }
                return bt(rt)
            }
            o(ft, "getBoundingClientRect");
            function $t(T, R) {
                var W = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1
                  , U = w(10)
                  , rt = R.nodeName === "HTML"
                  , st = ft(T)
                  , at = ft(R)
                  , ut = p(T)
                  , dt = u(R)
                  , _t = parseFloat(dt.borderTopWidth)
                  , Tt = parseFloat(dt.borderLeftWidth);
                W && rt && (at.top = Math.max(at.top, 0),
                at.left = Math.max(at.left, 0));
                var yt = bt({
                    top: st.top - at.top - _t,
                    left: st.left - at.left - Tt,
                    width: st.width,
                    height: st.height
                });
                if (yt.marginTop = 0,
                yt.marginLeft = 0,
                !U && rt) {
                    var Lt = parseFloat(dt.marginTop)
                      , Mt = parseFloat(dt.marginLeft);
                    yt.top -= _t - Lt,
                    yt.bottom -= _t - Lt,
                    yt.left -= Tt - Mt,
                    yt.right -= Tt - Mt,
                    yt.marginTop = Lt,
                    yt.marginLeft = Mt
                }
                return (U && !W ? R.contains(ut) : R === ut && ut.nodeName !== "BODY") && (yt = z(yt, R)),
                yt
            }
            o($t, "getOffsetRectRelativeToArbitraryNode");
            function Ut(T) {
                var R = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1
                  , W = T.ownerDocument.documentElement
                  , U = $t(T, W)
                  , rt = Math.max(W.clientWidth, window.innerWidth || 0)
                  , st = Math.max(W.clientHeight, window.innerHeight || 0)
                  , at = R ? 0 : F(W)
                  , ut = R ? 0 : F(W, "left")
                  , dt = {
                    top: at - U.top + U.marginTop,
                    left: ut - U.left + U.marginLeft,
                    width: rt,
                    height: st
                };
                return bt(dt)
            }
            o(Ut, "getViewportOffsetRectRelativeToArtbitraryNode");
            function wt(T) {
                var R = T.nodeName;
                if (R === "BODY" || R === "HTML")
                    return !1;
                if (u(T, "position") === "fixed")
                    return !0;
                var W = d(T);
                return W ? wt(W) : !1
            }
            o(wt, "isFixed");
            function Nt(T) {
                if (!T || !T.parentElement || w())
                    return document.documentElement;
                for (var R = T.parentElement; R && u(R, "transform") === "none"; )
                    R = R.parentElement;
                return R || document.documentElement
            }
            o(Nt, "getFixedPositionOffsetParent");
            function Xt(T, R, W, U) {
                var rt = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1
                  , st = {
                    top: 0,
                    left: 0
                }
                  , at = rt ? Nt(T) : k(T, b(R));
                if (U === "viewport")
                    st = Ut(at, rt);
                else {
                    var ut = void 0;
                    U === "scrollParent" ? (ut = p(d(R)),
                    ut.nodeName === "BODY" && (ut = T.ownerDocument.documentElement)) : U === "window" ? ut = T.ownerDocument.documentElement : ut = U;
                    var dt = $t(ut, at, rt);
                    if (ut.nodeName === "HTML" && !wt(at)) {
                        var _t = f(T.ownerDocument)
                          , Tt = _t.height
                          , yt = _t.width;
                        st.top += dt.top - dt.marginTop,
                        st.bottom = Tt + dt.top,
                        st.left += dt.left - dt.marginLeft,
                        st.right = yt + dt.left
                    } else
                        st = dt
                }
                W = W || 0;
                var Lt = typeof W == "number";
                return st.left += Lt ? W : W.left || 0,
                st.top += Lt ? W : W.top || 0,
                st.right -= Lt ? W : W.right || 0,
                st.bottom -= Lt ? W : W.bottom || 0,
                st
            }
            o(Xt, "getBoundaries");
            function pe(T) {
                var R = T.width
                  , W = T.height;
                return R * W
            }
            o(pe, "getArea");
            function Ne(T, R, W, U, rt) {
                var st = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;
                if (T.indexOf("auto") === -1)
                    return T;
                var at = Xt(W, U, st, rt)
                  , ut = {
                    top: {
                        width: at.width,
                        height: R.top - at.top
                    },
                    right: {
                        width: at.right - R.right,
                        height: at.height
                    },
                    bottom: {
                        width: at.width,
                        height: at.bottom - R.bottom
                    },
                    left: {
                        width: R.left - at.left,
                        height: at.height
                    }
                }
                  , dt = Object.keys(ut).map(function(Lt) {
                    return mt({
                        key: Lt
                    }, ut[Lt], {
                        area: pe(ut[Lt])
                    })
                }).sort(function(Lt, Mt) {
                    return Mt.area - Lt.area
                })
                  , _t = dt.filter(function(Lt) {
                    var Mt = Lt.width
                      , Dt = Lt.height;
                    return Mt >= W.clientWidth && Dt >= W.clientHeight
                })
                  , Tt = _t.length > 0 ? _t[0].key : dt[0].key
                  , yt = T.split("-")[1];
                return Tt + (yt ? "-" + yt : "")
            }
            o(Ne, "computeAutoPlacement");
            function xe(T, R, W) {
                var U = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null
                  , rt = U ? Nt(R) : k(R, b(W));
                return $t(W, rt, U)
            }
            o(xe, "getReferenceOffsets");
            function ci(T) {
                var R = T.ownerDocument.defaultView
                  , W = R.getComputedStyle(T)
                  , U = parseFloat(W.marginTop || 0) + parseFloat(W.marginBottom || 0)
                  , rt = parseFloat(W.marginLeft || 0) + parseFloat(W.marginRight || 0)
                  , st = {
                    width: T.offsetWidth + rt,
                    height: T.offsetHeight + U
                };
                return st
            }
            o(ci, "getOuterSizes");
            function re(T) {
                var R = {
                    left: "right",
                    right: "left",
                    bottom: "top",
                    top: "bottom"
                };
                return T.replace(/left|right|bottom|top/g, function(W) {
                    return R[W]
                })
            }
            o(re, "getOppositePlacement");
            function Ke(T, R, W) {
                W = W.split("-")[0];
                var U = ci(T)
                  , rt = {
                    width: U.width,
                    height: U.height
                }
                  , st = ["right", "left"].indexOf(W) !== -1
                  , at = st ? "top" : "left"
                  , ut = st ? "left" : "top"
                  , dt = st ? "height" : "width"
                  , _t = st ? "width" : "height";
                return rt[at] = R[at] + R[dt] / 2 - U[dt] / 2,
                W === ut ? rt[ut] = R[ut] - U[_t] : rt[ut] = R[re(ut)],
                rt
            }
            o(Ke, "getPopperOffsets");
            function Ye(T, R) {
                return Array.prototype.find ? T.find(R) : T.filter(R)[0]
            }
            o(Ye, "find");
            function Li(T, R, W) {
                if (Array.prototype.findIndex)
                    return T.findIndex(function(rt) {
                        return rt[R] === W
                    });
                var U = Ye(T, function(rt) {
                    return rt[R] === W
                });
                return T.indexOf(U)
            }
            o(Li, "findIndex");
            function Di(T, R, W) {
                var U = W === void 0 ? T : T.slice(0, Li(T, "name", W));
                return U.forEach(function(rt) {
                    rt.function && console.warn("`modifier.function` is deprecated, use `modifier.fn`!");
                    var st = rt.function || rt.fn;
                    rt.enabled && l(st) && (R.offsets.popper = bt(R.offsets.popper),
                    R.offsets.reference = bt(R.offsets.reference),
                    R = st(R, rt))
                }),
                R
            }
            o(Di, "runModifiers");
            function xr() {
                if (!this.state.isDestroyed) {
                    var T = {
                        instance: this,
                        styles: {},
                        arrowStyles: {},
                        attributes: {},
                        flipped: !1,
                        offsets: {}
                    };
                    T.offsets.reference = xe(this.state, this.popper, this.reference, this.options.positionFixed),
                    T.placement = Ne(this.options.placement, T.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding),
                    T.originalPlacement = T.placement,
                    T.positionFixed = this.options.positionFixed,
                    T.offsets.popper = Ke(this.popper, T.offsets.reference, T.placement),
                    T.offsets.popper.position = this.options.positionFixed ? "fixed" : "absolute",
                    T = Di(this.modifiers, T),
                    this.state.isCreated ? this.options.onUpdate(T) : (this.state.isCreated = !0,
                    this.options.onCreate(T))
                }
            }
            o(xr, "update");
            function Un(T, R) {
                return T.some(function(W) {
                    var U = W.name
                      , rt = W.enabled;
                    return rt && U === R
                })
            }
            o(Un, "isModifierEnabled");
            function ye(T) {
                for (var R = [!1, "ms", "Webkit", "Moz", "O"], W = T.charAt(0).toUpperCase() + T.slice(1), U = 0; U < R.length; U++) {
                    var rt = R[U]
                      , st = rt ? "" + rt + W : T;
                    if (typeof document.body.style[st] < "u")
                        return st
                }
                return null
            }
            o(ye, "getSupportedPropertyName");
            function wr() {
                return this.state.isDestroyed = !0,
                Un(this.modifiers, "applyStyle") && (this.popper.removeAttribute("x-placement"),
                this.popper.style.position = "",
                this.popper.style.top = "",
                this.popper.style.left = "",
                this.popper.style.right = "",
                this.popper.style.bottom = "",
                this.popper.style.willChange = "",
                this.popper.style[ye("transform")] = ""),
                this.disableEventListeners(),
                this.options.removeOnDestroy && this.popper.parentNode.removeChild(this.popper),
                this
            }
            o(wr, "destroy");
            function ui(T) {
                var R = T.ownerDocument;
                return R ? R.defaultView : window
            }
            o(ui, "getWindow");
            function Qi(T, R, W, U) {
                var rt = T.nodeName === "BODY"
                  , st = rt ? T.ownerDocument.defaultView : T;
                st.addEventListener(R, W, {
                    passive: !0
                }),
                rt || Qi(p(st.parentNode), R, W, U),
                U.push(st)
            }
            o(Qi, "attachToScrollParents");
            function Ts(T, R, W, U) {
                W.updateBound = U,
                ui(T).addEventListener("resize", W.updateBound, {
                    passive: !0
                });
                var rt = p(T);
                return Qi(rt, "scroll", W.updateBound, W.scrollParents),
                W.scrollElement = rt,
                W.eventsEnabled = !0,
                W
            }
            o(Ts, "setupEventListeners");
            function Cr() {
                this.state.eventsEnabled || (this.state = Ts(this.reference, this.options, this.state, this.scheduleUpdate))
            }
            o(Cr, "enableEventListeners");
            function Ei(T, R) {
                return ui(T).removeEventListener("resize", R.updateBound),
                R.scrollParents.forEach(function(W) {
                    W.removeEventListener("scroll", R.updateBound)
                }),
                R.updateBound = null,
                R.scrollParents = [],
                R.scrollElement = null,
                R.eventsEnabled = !1,
                R
            }
            o(Ei, "removeEventListeners");
            function Xe() {
                this.state.eventsEnabled && (cancelAnimationFrame(this.scheduleUpdate),
                this.state = Ei(this.reference, this.state))
            }
            o(Xe, "disableEventListeners");
            function Re(T) {
                return T !== "" && !isNaN(parseFloat(T)) && isFinite(T)
            }
            o(Re, "isNumeric");
            function Si(T, R) {
                Object.keys(R).forEach(function(W) {
                    var U = "";
                    ["width", "height", "top", "right", "bottom", "left"].indexOf(W) !== -1 && Re(R[W]) && (U = "px"),
                    T.style[W] = R[W] + U
                })
            }
            o(Si, "setStyles");
            function _e(T, R) {
                Object.keys(R).forEach(function(W) {
                    var U = R[W];
                    U !== !1 ? T.setAttribute(W, R[W]) : T.removeAttribute(W)
                })
            }
            o(_e, "setAttributes");
            function xs(T) {
                return Si(T.instance.popper, T.styles),
                _e(T.instance.popper, T.attributes),
                T.arrowElement && Object.keys(T.arrowStyles).length && Si(T.arrowElement, T.arrowStyles),
                T
            }
            o(xs, "applyStyle");
            function Fe(T, R, W, U, rt) {
                var st = xe(rt, R, T, W.positionFixed)
                  , at = Ne(W.placement, st, R, T, W.modifiers.flip.boundariesElement, W.modifiers.flip.padding);
                return R.setAttribute("x-placement", at),
                Si(R, {
                    position: W.positionFixed ? "fixed" : "absolute"
                }),
                W
            }
            o(Fe, "applyStyleOnLoad");
            function Ji(T, R) {
                var W = T.offsets
                  , U = W.popper
                  , rt = W.reference
                  , st = Math.round
                  , at = Math.floor
                  , ut = o(function(Qe) {
                    return Qe
                }, "noRound")
                  , dt = st(rt.width)
                  , _t = st(U.width)
                  , Tt = ["left", "right"].indexOf(T.placement) !== -1
                  , yt = T.placement.indexOf("-") !== -1
                  , Lt = dt % 2 === _t % 2
                  , Mt = dt % 2 === 1 && _t % 2 === 1
                  , Dt = R ? Tt || yt || Lt ? st : at : ut
                  , ne = R ? st : ut;
                return {
                    left: Dt(Mt && !yt && R ? U.left - 1 : U.left),
                    top: ne(U.top),
                    bottom: ne(U.bottom),
                    right: Dt(U.right)
                }
            }
            o(Ji, "getRoundedOffsets");
            var Zi = n && /Firefox/i.test(navigator.userAgent);
            function St(T, R) {
                var W = R.x
                  , U = R.y
                  , rt = T.offsets.popper
                  , st = Ye(T.instance.modifiers, function(we) {
                    return we.name === "applyStyle"
                }).gpuAcceleration;
                st !== void 0 && console.warn("WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!");
                var at = st !== void 0 ? st : R.gpuAcceleration
                  , ut = C(T.instance.popper)
                  , dt = ft(ut)
                  , _t = {
                    position: rt.position
                }
                  , Tt = Ji(T, window.devicePixelRatio < 2 || !Zi)
                  , yt = W === "bottom" ? "top" : "bottom"
                  , Lt = U === "right" ? "left" : "right"
                  , Mt = ye("transform")
                  , Dt = void 0
                  , ne = void 0;
                if (yt === "bottom" ? ut.nodeName === "HTML" ? ne = -ut.clientHeight + Tt.bottom : ne = -dt.height + Tt.bottom : ne = Tt.top,
                Lt === "right" ? ut.nodeName === "HTML" ? Dt = -ut.clientWidth + Tt.right : Dt = -dt.width + Tt.right : Dt = Tt.left,
                at && Mt)
                    _t[Mt] = "translate3d(" + Dt + "px, " + ne + "px, 0)",
                    _t[yt] = 0,
                    _t[Lt] = 0,
                    _t.willChange = "transform";
                else {
                    var Ve = yt === "bottom" ? -1 : 1
                      , Qe = Lt === "right" ? -1 : 1;
                    _t[yt] = ne * Ve,
                    _t[Lt] = Dt * Qe,
                    _t.willChange = yt + ", " + Lt
                }
                var se = {
                    "x-placement": T.placement
                };
                return T.attributes = mt({}, se, T.attributes),
                T.styles = mt({}, _t, T.styles),
                T.arrowStyles = mt({}, T.offsets.arrow, T.arrowStyles),
                T
            }
            o(St, "computeStyle");
            function me(T, R, W) {
                var U = Ye(T, function(ut) {
                    var dt = ut.name;
                    return dt === R
                })
                  , rt = !!U && T.some(function(ut) {
                    return ut.name === W && ut.enabled && ut.order < U.order
                });
                if (!rt) {
                    var st = "`" + R + "`"
                      , at = "`" + W + "`";
                    console.warn(at + " modifier is required by " + st + " modifier in order to work, be sure to include it before " + st + "!")
                }
                return rt
            }
            o(me, "isModifierRequired");
            function Kn(T, R) {
                var W;
                if (!me(T.instance.modifiers, "arrow", "keepTogether"))
                    return T;
                var U = R.element;
                if (typeof U == "string") {
                    if (U = T.instance.popper.querySelector(U),
                    !U)
                        return T
                } else if (!T.instance.popper.contains(U))
                    return console.warn("WARNING: `arrow.element` must be child of its popper element!"),
                    T;
                var rt = T.placement.split("-")[0]
                  , st = T.offsets
                  , at = st.popper
                  , ut = st.reference
                  , dt = ["left", "right"].indexOf(rt) !== -1
                  , _t = dt ? "height" : "width"
                  , Tt = dt ? "Top" : "Left"
                  , yt = Tt.toLowerCase()
                  , Lt = dt ? "left" : "top"
                  , Mt = dt ? "bottom" : "right"
                  , Dt = ci(U)[_t];
                ut[Mt] - Dt < at[yt] && (T.offsets.popper[yt] -= at[yt] - (ut[Mt] - Dt)),
                ut[yt] + Dt > at[Mt] && (T.offsets.popper[yt] += ut[yt] + Dt - at[Mt]),
                T.offsets.popper = bt(T.offsets.popper);
                var ne = ut[yt] + ut[_t] / 2 - Dt / 2
                  , Ve = u(T.instance.popper)
                  , Qe = parseFloat(Ve["margin" + Tt])
                  , se = parseFloat(Ve["border" + Tt + "Width"])
                  , we = ne - T.offsets.popper[yt] - Qe - se;
                return we = Math.max(Math.min(at[_t] - Dt, we), 0),
                T.arrowElement = U,
                T.offsets.arrow = (W = {},
                ot(W, yt, Math.round(we)),
                ot(W, Lt, ""),
                W),
                T
            }
            o(Kn, "arrow");
            function Ar(T) {
                return T === "end" ? "start" : T === "start" ? "end" : T
            }
            o(Ar, "getOppositeVariation");
            var tn = ["auto-start", "auto", "auto-end", "top-start", "top", "top-end", "right-start", "right", "right-end", "bottom-end", "bottom", "bottom-start", "left-end", "left", "left-start"]
              , Ti = tn.slice(3);
            function Yn(T) {
                var R = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1
                  , W = Ti.indexOf(T)
                  , U = Ti.slice(W + 1).concat(Ti.slice(0, W));
                return R ? U.reverse() : U
            }
            o(Yn, "clockwise");
            var xi = {
                FLIP: "flip",
                CLOCKWISE: "clockwise",
                COUNTERCLOCKWISE: "counterclockwise"
            };
            function Ge(T, R) {
                if (Un(T.instance.modifiers, "inner") || T.flipped && T.placement === T.originalPlacement)
                    return T;
                var W = Xt(T.instance.popper, T.instance.reference, R.padding, R.boundariesElement, T.positionFixed)
                  , U = T.placement.split("-")[0]
                  , rt = re(U)
                  , st = T.placement.split("-")[1] || ""
                  , at = [];
                switch (R.behavior) {
                case xi.FLIP:
                    at = [U, rt];
                    break;
                case xi.CLOCKWISE:
                    at = Yn(U);
                    break;
                case xi.COUNTERCLOCKWISE:
                    at = Yn(U, !0);
                    break;
                default:
                    at = R.behavior
                }
                return at.forEach(function(ut, dt) {
                    if (U !== ut || at.length === dt + 1)
                        return T;
                    U = T.placement.split("-")[0],
                    rt = re(U);
                    var _t = T.offsets.popper
                      , Tt = T.offsets.reference
                      , yt = Math.floor
                      , Lt = U === "left" && yt(_t.right) > yt(Tt.left) || U === "right" && yt(_t.left) < yt(Tt.right) || U === "top" && yt(_t.bottom) > yt(Tt.top) || U === "bottom" && yt(_t.top) < yt(Tt.bottom)
                      , Mt = yt(_t.left) < yt(W.left)
                      , Dt = yt(_t.right) > yt(W.right)
                      , ne = yt(_t.top) < yt(W.top)
                      , Ve = yt(_t.bottom) > yt(W.bottom)
                      , Qe = U === "left" && Mt || U === "right" && Dt || U === "top" && ne || U === "bottom" && Ve
                      , se = ["top", "bottom"].indexOf(U) !== -1
                      , we = !!R.flipVariations && (se && st === "start" && Mt || se && st === "end" && Dt || !se && st === "start" && ne || !se && st === "end" && Ve)
                      , Xn = !!R.flipVariationsByContent && (se && st === "start" && Dt || se && st === "end" && Mt || !se && st === "start" && Ve || !se && st === "end" && ne)
                      , Be = we || Xn;
                    (Lt || Qe || Be) && (T.flipped = !0,
                    (Lt || Qe) && (U = at[dt + 1]),
                    Be && (st = Ar(st)),
                    T.placement = U + (st ? "-" + st : ""),
                    T.offsets.popper = mt({}, T.offsets.popper, Ke(T.instance.popper, T.offsets.reference, T.placement)),
                    T = Di(T.instance.modifiers, T, "flip"))
                }),
                T
            }
            o(Ge, "flip");
            function hi(T) {
                var R = T.offsets
                  , W = R.popper
                  , U = R.reference
                  , rt = T.placement.split("-")[0]
                  , st = Math.floor
                  , at = ["top", "bottom"].indexOf(rt) !== -1
                  , ut = at ? "right" : "bottom"
                  , dt = at ? "left" : "top"
                  , _t = at ? "width" : "height";
                return W[ut] < st(U[dt]) && (T.offsets.popper[dt] = st(U[dt]) - W[_t]),
                W[dt] > st(U[ut]) && (T.offsets.popper[dt] = st(U[ut])),
                T
            }
            o(hi, "keepTogether");
            function Pi(T, R, W, U) {
                var rt = T.match(/((?:\-|\+)?\d*\.?\d*)(.*)/)
                  , st = +rt[1]
                  , at = rt[2];
                if (!st)
                    return T;
                if (at.indexOf("%") === 0) {
                    var ut = void 0;
                    switch (at) {
                    case "%p":
                        ut = W;
                        break;
                    case "%":
                    case "%r":
                    default:
                        ut = U
                    }
                    var dt = bt(ut);
                    return dt[R] / 100 * st
                } else if (at === "vh" || at === "vw") {
                    var _t = void 0;
                    return at === "vh" ? _t = Math.max(document.documentElement.clientHeight, window.innerHeight || 0) : _t = Math.max(document.documentElement.clientWidth, window.innerWidth || 0),
                    _t / 100 * st
                } else
                    return st
            }
            o(Pi, "toValue");
            function kr(T, R, W, U) {
                var rt = [0, 0]
                  , st = ["right", "left"].indexOf(U) !== -1
                  , at = T.split(/(\+|\-)/).map(function(Tt) {
                    return Tt.trim()
                })
                  , ut = at.indexOf(Ye(at, function(Tt) {
                    return Tt.search(/,|\s/) !== -1
                }));
                at[ut] && at[ut].indexOf(",") === -1 && console.warn("Offsets separated by white space(s) are deprecated, use a comma (,) instead.");
                var dt = /\s*,\s*|\s+/
                  , _t = ut !== -1 ? [at.slice(0, ut).concat([at[ut].split(dt)[0]]), [at[ut].split(dt)[1]].concat(at.slice(ut + 1))] : [at];
                return _t = _t.map(function(Tt, yt) {
                    var Lt = (yt === 1 ? !st : st) ? "height" : "width"
                      , Mt = !1;
                    return Tt.reduce(function(Dt, ne) {
                        return Dt[Dt.length - 1] === "" && ["+", "-"].indexOf(ne) !== -1 ? (Dt[Dt.length - 1] = ne,
                        Mt = !0,
                        Dt) : Mt ? (Dt[Dt.length - 1] += ne,
                        Mt = !1,
                        Dt) : Dt.concat(ne)
                    }, []).map(function(Dt) {
                        return Pi(Dt, Lt, R, W)
                    })
                }),
                _t.forEach(function(Tt, yt) {
                    Tt.forEach(function(Lt, Mt) {
                        Re(Lt) && (rt[yt] += Lt * (Tt[Mt - 1] === "-" ? -1 : 1))
                    })
                }),
                rt
            }
            o(kr, "parseOffset");
            function yn(T, R) {
                var W = R.offset
                  , U = T.placement
                  , rt = T.offsets
                  , st = rt.popper
                  , at = rt.reference
                  , ut = U.split("-")[0]
                  , dt = void 0;
                return Re(+W) ? dt = [+W, 0] : dt = kr(W, st, at, ut),
                ut === "left" ? (st.top += dt[0],
                st.left -= dt[1]) : ut === "right" ? (st.top += dt[0],
                st.left += dt[1]) : ut === "top" ? (st.left += dt[0],
                st.top -= dt[1]) : ut === "bottom" && (st.left += dt[0],
                st.top += dt[1]),
                T.popper = st,
                T
            }
            o(yn, "offset");
            function ws(T, R) {
                var W = R.boundariesElement || C(T.instance.popper);
                T.instance.reference === W && (W = C(W));
                var U = ye("transform")
                  , rt = T.instance.popper.style
                  , st = rt.top
                  , at = rt.left
                  , ut = rt[U];
                rt.top = "",
                rt.left = "",
                rt[U] = "";
                var dt = Xt(T.instance.popper, T.instance.reference, R.padding, W, T.positionFixed);
                rt.top = st,
                rt.left = at,
                rt[U] = ut,
                R.boundaries = dt;
                var _t = R.priority
                  , Tt = T.offsets.popper
                  , yt = {
                    primary: o(function(Mt) {
                        var Dt = Tt[Mt];
                        return Tt[Mt] < dt[Mt] && !R.escapeWithReference && (Dt = Math.max(Tt[Mt], dt[Mt])),
                        ot({}, Mt, Dt)
                    }, "primary"),
                    secondary: o(function(Mt) {
                        var Dt = Mt === "right" ? "left" : "top"
                          , ne = Tt[Dt];
                        return Tt[Mt] > dt[Mt] && !R.escapeWithReference && (ne = Math.min(Tt[Dt], dt[Mt] - (Mt === "right" ? Tt.width : Tt.height))),
                        ot({}, Dt, ne)
                    }, "secondary")
                };
                return _t.forEach(function(Lt) {
                    var Mt = ["left", "top"].indexOf(Lt) !== -1 ? "primary" : "secondary";
                    Tt = mt({}, Tt, yt[Mt](Lt))
                }),
                T.offsets.popper = Tt,
                T
            }
            o(ws, "preventOverflow");
            function Cs(T) {
                var R = T.placement
                  , W = R.split("-")[0]
                  , U = R.split("-")[1];
                if (U) {
                    var rt = T.offsets
                      , st = rt.reference
                      , at = rt.popper
                      , ut = ["bottom", "top"].indexOf(W) !== -1
                      , dt = ut ? "left" : "top"
                      , _t = ut ? "width" : "height"
                      , Tt = {
                        start: ot({}, dt, st[dt]),
                        end: ot({}, dt, st[dt] + st[_t] - at[_t])
                    };
                    T.offsets.popper = mt({}, at, Tt[U])
                }
                return T
            }
            o(Cs, "shift");
            function Mr(T) {
                if (!me(T.instance.modifiers, "hide", "preventOverflow"))
                    return T;
                var R = T.offsets.reference
                  , W = Ye(T.instance.modifiers, function(U) {
                    return U.name === "preventOverflow"
                }).boundaries;
                if (R.bottom < W.top || R.left > W.right || R.top > W.bottom || R.right < W.left) {
                    if (T.hide === !0)
                        return T;
                    T.hide = !0,
                    T.attributes["x-out-of-boundaries"] = ""
                } else {
                    if (T.hide === !1)
                        return T;
                    T.hide = !1,
                    T.attributes["x-out-of-boundaries"] = !1
                }
                return T
            }
            o(Mr, "hide");
            function Ri(T) {
                var R = T.placement
                  , W = R.split("-")[0]
                  , U = T.offsets
                  , rt = U.popper
                  , st = U.reference
                  , at = ["left", "right"].indexOf(W) !== -1
                  , ut = ["top", "left"].indexOf(W) === -1;
                return rt[at ? "left" : "top"] = st[W] - (ut ? rt[at ? "width" : "height"] : 0),
                T.placement = re(R),
                T.offsets.popper = bt(rt),
                T
            }
            o(Ri, "inner");
            var en = {
                shift: {
                    order: 100,
                    enabled: !0,
                    fn: Cs
                },
                offset: {
                    order: 200,
                    enabled: !0,
                    fn: yn,
                    offset: 0
                },
                preventOverflow: {
                    order: 300,
                    enabled: !0,
                    fn: ws,
                    priority: ["left", "right", "top", "bottom"],
                    padding: 5,
                    boundariesElement: "scrollParent"
                },
                keepTogether: {
                    order: 400,
                    enabled: !0,
                    fn: hi
                },
                arrow: {
                    order: 500,
                    enabled: !0,
                    fn: Kn,
                    element: "[x-arrow]"
                },
                flip: {
                    order: 600,
                    enabled: !0,
                    fn: Ge,
                    behavior: "flip",
                    padding: 5,
                    boundariesElement: "viewport",
                    flipVariations: !1,
                    flipVariationsByContent: !1
                },
                inner: {
                    order: 700,
                    enabled: !1,
                    fn: Ri
                },
                hide: {
                    order: 800,
                    enabled: !0,
                    fn: Mr
                },
                computeStyle: {
                    order: 850,
                    enabled: !0,
                    fn: St,
                    gpuAcceleration: !0,
                    x: "bottom",
                    y: "right"
                },
                applyStyle: {
                    order: 900,
                    enabled: !0,
                    fn: xs,
                    onLoad: Fe,
                    gpuAcceleration: void 0
                }
            }
              , As = {
                placement: "bottom",
                positionFixed: !1,
                eventsEnabled: !0,
                removeOnDestroy: !1,
                onCreate: o(function() {}, "onCreate"),
                onUpdate: o(function() {}, "onUpdate"),
                modifiers: en
            }
              , nn = (function() {
                function T(R, W) {
                    var U = this
                      , rt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                    Y(this, T),
                    this.scheduleUpdate = function() {
                        return requestAnimationFrame(U.update)
                    }
                    ,
                    this.update = a(this.update.bind(this)),
                    this.options = mt({}, T.Defaults, rt),
                    this.state = {
                        isDestroyed: !1,
                        isCreated: !1,
                        scrollParents: []
                    },
                    this.reference = R && R.jquery ? R[0] : R,
                    this.popper = W && W.jquery ? W[0] : W,
                    this.options.modifiers = {},
                    Object.keys(mt({}, T.Defaults.modifiers, rt.modifiers)).forEach(function(at) {
                        U.options.modifiers[at] = mt({}, T.Defaults.modifiers[at] || {}, rt.modifiers ? rt.modifiers[at] : {})
                    }),
                    this.modifiers = Object.keys(this.options.modifiers).map(function(at) {
                        return mt({
                            name: at
                        }, U.options.modifiers[at])
                    }).sort(function(at, ut) {
                        return at.order - ut.order
                    }),
                    this.modifiers.forEach(function(at) {
                        at.enabled && l(at.onLoad) && at.onLoad(U.reference, U.popper, U.options, at, U.state)
                    }),
                    this.update();
                    var st = this.options.eventsEnabled;
                    st && this.enableEventListeners(),
                    this.state.eventsEnabled = st
                }
                return o(T, "Popper"),
                Q(T, [{
                    key: "update",
                    value: o(function() {
                        return xr.call(this)
                    }, "update$$1")
                }, {
                    key: "destroy",
                    value: o(function() {
                        return wr.call(this)
                    }, "destroy$$1")
                }, {
                    key: "enableEventListeners",
                    value: o(function() {
                        return Cr.call(this)
                    }, "enableEventListeners$$1")
                }, {
                    key: "disableEventListeners",
                    value: o(function() {
                        return Xe.call(this)
                    }, "disableEventListeners$$1")
                }]),
                T
            }
            )();
            return nn.Utils = (typeof window < "u" ? window : global).PopperUtils,
            nn.placements = tn,
            nn.Defaults = As,
            nn
        }
        ))
    }
    );
    var Gd = Kr( (ea, Xd) => {
        (function(n, t) {
            typeof ea == "object" && typeof Xd < "u" ? t(ea, Ws(), Yd()) : typeof define == "function" && define.amd ? define(["exports", "jquery", "popper.js"], t) : (n = typeof globalThis < "u" ? globalThis : n || self,
            t(n.bootstrap = {}, n.jQuery, n.Popper))
        }
        )(ea, (function(n, t, e) {
            "use strict";
            function s(X) {
                return X && typeof X == "object" && "default"in X ? X : {
                    default: X
                }
            }
            o(s, "_interopDefaultLegacy");
            var r = s(t)
              , a = s(e);
            function l(X, V) {
                for (var P = 0; P < V.length; P++) {
                    var v = V[P];
                    v.enumerable = v.enumerable || !1,
                    v.configurable = !0,
                    "value"in v && (v.writable = !0),
                    Object.defineProperty(X, v.key, v)
                }
            }
            o(l, "_defineProperties");
            function u(X, V, P) {
                return V && l(X.prototype, V),
                P && l(X, P),
                X
            }
            o(u, "_createClass");
            function d() {
                return d = Object.assign || function(X) {
                    for (var V = 1; V < arguments.length; V++) {
                        var P = arguments[V];
                        for (var v in P)
                            Object.prototype.hasOwnProperty.call(P, v) && (X[v] = P[v])
                    }
                    return X
                }
                ,
                d.apply(this, arguments)
            }
            o(d, "_extends");
            function p(X, V) {
                X.prototype = Object.create(V.prototype),
                X.prototype.constructor = X,
                X.__proto__ = V
            }
            o(p, "_inheritsLoose");
            var b = "transitionend"
              , E = 1e6
              , x = 1e3;
            function w(X) {
                return X === null || typeof X > "u" ? "" + X : {}.toString.call(X).match(/\s([a-z]+)/i)[1].toLowerCase()
            }
            o(w, "toType");
            function C() {
                return {
                    bindType: b,
                    delegateType: b,
                    handle: o(function(V) {
                        if (r.default(V.target).is(this))
                            return V.handleObj.handler.apply(this, arguments)
                    }, "handle")
                }
            }
            o(C, "getSpecialTransitionEndEvent");
            function I(X) {
                var V = this
                  , P = !1;
                return r.default(this).one(k.TRANSITION_END, function() {
                    P = !0
                }),
                setTimeout(function() {
                    P || k.triggerTransitionEnd(V)
                }, X),
                this
            }
            o(I, "transitionEndEmulator");
            function L() {
                r.default.fn.emulateTransitionEnd = I,
                r.default.event.special[k.TRANSITION_END] = C()
            }
            o(L, "setTransitionEndSupport");
            var k = {
                TRANSITION_END: "bsTransitionEnd",
                getUID: o(function(V) {
                    do
                        V += ~~(Math.random() * E);
                    while (document.getElementById(V));
                    return V
                }, "getUID"),
                getSelectorFromElement: o(function(V) {
                    var P = V.getAttribute("data-target");
                    if (!P || P === "#") {
                        var v = V.getAttribute("href");
                        P = v && v !== "#" ? v.trim() : ""
                    }
                    try {
                        return document.querySelector(P) ? P : null
                    } catch {
                        return null
                    }
                }, "getSelectorFromElement"),
                getTransitionDurationFromElement: o(function(V) {
                    if (!V)
                        return 0;
                    var P = r.default(V).css("transition-duration")
                      , v = r.default(V).css("transition-delay")
                      , A = parseFloat(P)
                      , O = parseFloat(v);
                    return !A && !O ? 0 : (P = P.split(",")[0],
                    v = v.split(",")[0],
                    (parseFloat(P) + parseFloat(v)) * x)
                }, "getTransitionDurationFromElement"),
                reflow: o(function(V) {
                    return V.offsetHeight
                }, "reflow"),
                triggerTransitionEnd: o(function(V) {
                    r.default(V).trigger(b)
                }, "triggerTransitionEnd"),
                supportsTransitionEnd: o(function() {
                    return !!b
                }, "supportsTransitionEnd"),
                isElement: o(function(V) {
                    return (V[0] || V).nodeType
                }, "isElement"),
                typeCheckConfig: o(function(V, P, v) {
                    for (var A in v)
                        if (Object.prototype.hasOwnProperty.call(v, A)) {
                            var O = v[A]
                              , J = P[A]
                              , et = J && k.isElement(J) ? "element" : w(J);
                            if (!new RegExp(O).test(et))
                                throw new Error(V.toUpperCase() + ": " + ('Option "' + A + '" provided type "' + et + '" ') + ('but expected type "' + O + '".'))
                        }
                }, "typeCheckConfig"),
                findShadowRoot: o(function(V) {
                    if (!document.documentElement.attachShadow)
                        return null;
                    if (typeof V.getRootNode == "function") {
                        var P = V.getRootNode();
                        return P instanceof ShadowRoot ? P : null
                    }
                    return V instanceof ShadowRoot ? V : V.parentNode ? k.findShadowRoot(V.parentNode) : null
                }, "findShadowRoot"),
                jQueryDetection: o(function() {
                    if (typeof r.default > "u")
                        throw new TypeError("Bootstrap's JavaScript requires jQuery. jQuery must be included before Bootstrap's JavaScript.");
                    var V = r.default.fn.jquery.split(" ")[0].split(".")
                      , P = 1
                      , v = 2
                      , A = 9
                      , O = 1
                      , J = 4;
                    if (V[0] < v && V[1] < A || V[0] === P && V[1] === A && V[2] < O || V[0] >= J)
                        throw new Error("Bootstrap's JavaScript requires at least jQuery v1.9.1 but less than v4.0.0")
                }, "jQueryDetection")
            };
            k.jQueryDetection(),
            L();
            var F = "alert"
              , z = "4.6.0"
              , j = "bs.alert"
              , H = "." + j
              , f = ".data-api"
              , Y = r.default.fn[F]
              , Q = '[data-dismiss="alert"]'
              , ot = "close" + H
              , mt = "closed" + H
              , bt = "click" + H + f
              , ft = "alert"
              , $t = "fade"
              , Ut = "show"
              , wt = (function() {
                function X(P) {
                    this._element = P
                }
                o(X, "Alert");
                var V = X.prototype;
                return V.close = o(function(v) {
                    var A = this._element;
                    v && (A = this._getRootElement(v));
                    var O = this._triggerCloseEvent(A);
                    O.isDefaultPrevented() || this._removeElement(A)
                }, "close"),
                V.dispose = o(function() {
                    r.default.removeData(this._element, j),
                    this._element = null
                }, "dispose"),
                V._getRootElement = o(function(v) {
                    var A = k.getSelectorFromElement(v)
                      , O = !1;
                    return A && (O = document.querySelector(A)),
                    O || (O = r.default(v).closest("." + ft)[0]),
                    O
                }, "_getRootElement"),
                V._triggerCloseEvent = o(function(v) {
                    var A = r.default.Event(ot);
                    return r.default(v).trigger(A),
                    A
                }, "_triggerCloseEvent"),
                V._removeElement = o(function(v) {
                    var A = this;
                    if (r.default(v).removeClass(Ut),
                    !r.default(v).hasClass($t)) {
                        this._destroyElement(v);
                        return
                    }
                    var O = k.getTransitionDurationFromElement(v);
                    r.default(v).one(k.TRANSITION_END, function(J) {
                        return A._destroyElement(v, J)
                    }).emulateTransitionEnd(O)
                }, "_removeElement"),
                V._destroyElement = o(function(v) {
                    r.default(v).detach().trigger(mt).remove()
                }, "_destroyElement"),
                X._jQueryInterface = o(function(v) {
                    return this.each(function() {
                        var A = r.default(this)
                          , O = A.data(j);
                        O || (O = new X(this),
                        A.data(j, O)),
                        v === "close" && O[v](this)
                    })
                }, "_jQueryInterface"),
                X._handleDismiss = o(function(v) {
                    return function(A) {
                        A && A.preventDefault(),
                        v.close(this)
                    }
                }, "_handleDismiss"),
                u(X, null, [{
                    key: "VERSION",
                    get: o(function() {
                        return z
                    }, "get")
                }]),
                X
            }
            )();
            r.default(document).on(bt, Q, wt._handleDismiss(new wt)),
            r.default.fn[F] = wt._jQueryInterface,
            r.default.fn[F].Constructor = wt,
            r.default.fn[F].noConflict = function() {
                return r.default.fn[F] = Y,
                wt._jQueryInterface
            }
            ;
            var Nt = "button"
              , Xt = "4.6.0"
              , pe = "bs.button"
              , Ne = "." + pe
              , xe = ".data-api"
              , ci = r.default.fn[Nt]
              , re = "active"
              , Ke = "btn"
              , Ye = "focus"
              , Li = '[data-toggle^="button"]'
              , Di = '[data-toggle="buttons"]'
              , xr = '[data-toggle="button"]'
              , Un = '[data-toggle="buttons"] .btn'
              , ye = 'input:not([type="hidden"])'
              , wr = ".active"
              , ui = ".btn"
              , Qi = "click" + Ne + xe
              , Ts = "focus" + Ne + xe + " " + ("blur" + Ne + xe)
              , Cr = "load" + Ne + xe
              , Ei = (function() {
                function X(P) {
                    this._element = P,
                    this.shouldAvoidTriggerChange = !1
                }
                o(X, "Button");
                var V = X.prototype;
                return V.toggle = o(function() {
                    var v = !0
                      , A = !0
                      , O = r.default(this._element).closest(Di)[0];
                    if (O) {
                        var J = this._element.querySelector(ye);
                        if (J) {
                            if (J.type === "radio")
                                if (J.checked && this._element.classList.contains(re))
                                    v = !1;
                                else {
                                    var et = O.querySelector(wr);
                                    et && r.default(et).removeClass(re)
                                }
                            v && ((J.type === "checkbox" || J.type === "radio") && (J.checked = !this._element.classList.contains(re)),
                            this.shouldAvoidTriggerChange || r.default(J).trigger("change")),
                            J.focus(),
                            A = !1
                        }
                    }
                    this._element.hasAttribute("disabled") || this._element.classList.contains("disabled") || (A && this._element.setAttribute("aria-pressed", !this._element.classList.contains(re)),
                    v && r.default(this._element).toggleClass(re))
                }, "toggle"),
                V.dispose = o(function() {
                    r.default.removeData(this._element, pe),
                    this._element = null
                }, "dispose"),
                X._jQueryInterface = o(function(v, A) {
                    return this.each(function() {
                        var O = r.default(this)
                          , J = O.data(pe);
                        J || (J = new X(this),
                        O.data(pe, J)),
                        J.shouldAvoidTriggerChange = A,
                        v === "toggle" && J[v]()
                    })
                }, "_jQueryInterface"),
                u(X, null, [{
                    key: "VERSION",
                    get: o(function() {
                        return Xt
                    }, "get")
                }]),
                X
            }
            )();
            r.default(document).on(Qi, Li, function(X) {
                var V = X.target
                  , P = V;
                if (r.default(V).hasClass(Ke) || (V = r.default(V).closest(ui)[0]),
                !V || V.hasAttribute("disabled") || V.classList.contains("disabled"))
                    X.preventDefault();
                else {
                    var v = V.querySelector(ye);
                    if (v && (v.hasAttribute("disabled") || v.classList.contains("disabled"))) {
                        X.preventDefault();
                        return
                    }
                    (P.tagName === "INPUT" || V.tagName !== "LABEL") && Ei._jQueryInterface.call(r.default(V), "toggle", P.tagName === "INPUT")
                }
            }).on(Ts, Li, function(X) {
                var V = r.default(X.target).closest(ui)[0];
                r.default(V).toggleClass(Ye, /^focus(in)?$/.test(X.type))
            }),
            r.default(window).on(Cr, function() {
                for (var X = [].slice.call(document.querySelectorAll(Un)), V = 0, P = X.length; V < P; V++) {
                    var v = X[V]
                      , A = v.querySelector(ye);
                    A.checked || A.hasAttribute("checked") ? v.classList.add(re) : v.classList.remove(re)
                }
                X = [].slice.call(document.querySelectorAll(xr));
                for (var O = 0, J = X.length; O < J; O++) {
                    var et = X[O];
                    et.getAttribute("aria-pressed") === "true" ? et.classList.add(re) : et.classList.remove(re)
                }
            }),
            r.default.fn[Nt] = Ei._jQueryInterface,
            r.default.fn[Nt].Constructor = Ei,
            r.default.fn[Nt].noConflict = function() {
                return r.default.fn[Nt] = ci,
                Ei._jQueryInterface
            }
            ;
            var Xe = "carousel"
              , Re = "4.6.0"
              , Si = "bs.carousel"
              , _e = "." + Si
              , xs = ".data-api"
              , Fe = r.default.fn[Xe]
              , Ji = 37
              , Zi = 39
              , St = 500
              , me = 40
              , Kn = {
                interval: 5e3,
                keyboard: !0,
                slide: !1,
                pause: "hover",
                wrap: !0,
                touch: !0
            }
              , Ar = {
                interval: "(number|boolean)",
                keyboard: "boolean",
                slide: "(boolean|string)",
                pause: "(string|boolean)",
                wrap: "boolean",
                touch: "boolean"
            }
              , tn = "next"
              , Ti = "prev"
              , Yn = "left"
              , xi = "right"
              , Ge = "slide" + _e
              , hi = "slid" + _e
              , Pi = "keydown" + _e
              , kr = "mouseenter" + _e
              , yn = "mouseleave" + _e
              , ws = "touchstart" + _e
              , Cs = "touchmove" + _e
              , Mr = "touchend" + _e
              , Ri = "pointerdown" + _e
              , en = "pointerup" + _e
              , As = "dragstart" + _e
              , nn = "load" + _e + xs
              , T = "click" + _e + xs
              , R = "carousel"
              , W = "active"
              , U = "slide"
              , rt = "carousel-item-right"
              , st = "carousel-item-left"
              , at = "carousel-item-next"
              , ut = "carousel-item-prev"
              , dt = "pointer-event"
              , _t = ".active"
              , Tt = ".active.carousel-item"
              , yt = ".carousel-item"
              , Lt = ".carousel-item img"
              , Mt = ".carousel-item-next, .carousel-item-prev"
              , Dt = ".carousel-indicators"
              , ne = "[data-slide], [data-slide-to]"
              , Ve = '[data-ride="carousel"]'
              , Qe = {
                TOUCH: "touch",
                PEN: "pen"
            }
              , se = (function() {
                function X(P, v) {
                    this._items = null,
                    this._interval = null,
                    this._activeElement = null,
                    this._isPaused = !1,
                    this._isSliding = !1,
                    this.touchTimeout = null,
                    this.touchStartX = 0,
                    this.touchDeltaX = 0,
                    this._config = this._getConfig(v),
                    this._element = P,
                    this._indicatorsElement = this._element.querySelector(Dt),
                    this._touchSupported = "ontouchstart"in document.documentElement || navigator.maxTouchPoints > 0,
                    this._pointerEvent = !!(window.PointerEvent || window.MSPointerEvent),
                    this._addEventListeners()
                }
                o(X, "Carousel");
                var V = X.prototype;
                return V.next = o(function() {
                    this._isSliding || this._slide(tn)
                }, "next"),
                V.nextWhenVisible = o(function() {
                    var v = r.default(this._element);
                    !document.hidden && v.is(":visible") && v.css("visibility") !== "hidden" && this.next()
                }, "nextWhenVisible"),
                V.prev = o(function() {
                    this._isSliding || this._slide(Ti)
                }, "prev"),
                V.pause = o(function(v) {
                    v || (this._isPaused = !0),
                    this._element.querySelector(Mt) && (k.triggerTransitionEnd(this._element),
                    this.cycle(!0)),
                    clearInterval(this._interval),
                    this._interval = null
                }, "pause"),
                V.cycle = o(function(v) {
                    v || (this._isPaused = !1),
                    this._interval && (clearInterval(this._interval),
                    this._interval = null),
                    this._config.interval && !this._isPaused && (this._updateInterval(),
                    this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval))
                }, "cycle"),
                V.to = o(function(v) {
                    var A = this;
                    this._activeElement = this._element.querySelector(Tt);
                    var O = this._getItemIndex(this._activeElement);
                    if (!(v > this._items.length - 1 || v < 0)) {
                        if (this._isSliding) {
                            r.default(this._element).one(hi, function() {
                                return A.to(v)
                            });
                            return
                        }
                        if (O === v) {
                            this.pause(),
                            this.cycle();
                            return
                        }
                        var J = v > O ? tn : Ti;
                        this._slide(J, this._items[v])
                    }
                }, "to"),
                V.dispose = o(function() {
                    r.default(this._element).off(_e),
                    r.default.removeData(this._element, Si),
                    this._items = null,
                    this._config = null,
                    this._element = null,
                    this._interval = null,
                    this._isPaused = null,
                    this._isSliding = null,
                    this._activeElement = null,
                    this._indicatorsElement = null
                }, "dispose"),
                V._getConfig = o(function(v) {
                    return v = d({}, Kn, v),
                    k.typeCheckConfig(Xe, v, Ar),
                    v
                }, "_getConfig"),
                V._handleSwipe = o(function() {
                    var v = Math.abs(this.touchDeltaX);
                    if (!(v <= me)) {
                        var A = v / this.touchDeltaX;
                        this.touchDeltaX = 0,
                        A > 0 && this.prev(),
                        A < 0 && this.next()
                    }
                }, "_handleSwipe"),
                V._addEventListeners = o(function() {
                    var v = this;
                    this._config.keyboard && r.default(this._element).on(Pi, function(A) {
                        return v._keydown(A)
                    }),
                    this._config.pause === "hover" && r.default(this._element).on(kr, function(A) {
                        return v.pause(A)
                    }).on(yn, function(A) {
                        return v.cycle(A)
                    }),
                    this._config.touch && this._addTouchEventListeners()
                }, "_addEventListeners"),
                V._addTouchEventListeners = o(function() {
                    var v = this;
                    if (this._touchSupported) {
                        var A = o(function(ct) {
                            v._pointerEvent && Qe[ct.originalEvent.pointerType.toUpperCase()] ? v.touchStartX = ct.originalEvent.clientX : v._pointerEvent || (v.touchStartX = ct.originalEvent.touches[0].clientX)
                        }, "start")
                          , O = o(function(ct) {
                            ct.originalEvent.touches && ct.originalEvent.touches.length > 1 ? v.touchDeltaX = 0 : v.touchDeltaX = ct.originalEvent.touches[0].clientX - v.touchStartX
                        }, "move")
                          , J = o(function(ct) {
                            v._pointerEvent && Qe[ct.originalEvent.pointerType.toUpperCase()] && (v.touchDeltaX = ct.originalEvent.clientX - v.touchStartX),
                            v._handleSwipe(),
                            v._config.pause === "hover" && (v.pause(),
                            v.touchTimeout && clearTimeout(v.touchTimeout),
                            v.touchTimeout = setTimeout(function(Ot) {
                                return v.cycle(Ot)
                            }, St + v._config.interval))
                        }, "end");
                        r.default(this._element.querySelectorAll(Lt)).on(As, function(et) {
                            return et.preventDefault()
                        }),
                        this._pointerEvent ? (r.default(this._element).on(Ri, function(et) {
                            return A(et)
                        }),
                        r.default(this._element).on(en, function(et) {
                            return J(et)
                        }),
                        this._element.classList.add(dt)) : (r.default(this._element).on(ws, function(et) {
                            return A(et)
                        }),
                        r.default(this._element).on(Cs, function(et) {
                            return O(et)
                        }),
                        r.default(this._element).on(Mr, function(et) {
                            return J(et)
                        }))
                    }
                }, "_addTouchEventListeners"),
                V._keydown = o(function(v) {
                    if (!/input|textarea/i.test(v.target.tagName))
                        switch (v.which) {
                        case Ji:
                            v.preventDefault(),
                            this.prev();
                            break;
                        case Zi:
                            v.preventDefault(),
                            this.next();
                            break
                        }
                }, "_keydown"),
                V._getItemIndex = o(function(v) {
                    return this._items = v && v.parentNode ? [].slice.call(v.parentNode.querySelectorAll(yt)) : [],
                    this._items.indexOf(v)
                }, "_getItemIndex"),
                V._getItemByDirection = o(function(v, A) {
                    var O = v === tn
                      , J = v === Ti
                      , et = this._getItemIndex(A)
                      , ct = this._items.length - 1
                      , Ot = J && et === 0 || O && et === ct;
                    if (Ot && !this._config.wrap)
                        return A;
                    var Yt = v === Ti ? -1 : 1
                      , Qt = (et + Yt) % this._items.length;
                    return Qt === -1 ? this._items[this._items.length - 1] : this._items[Qt]
                }, "_getItemByDirection"),
                V._triggerSlideEvent = o(function(v, A) {
                    var O = this._getItemIndex(v)
                      , J = this._getItemIndex(this._element.querySelector(Tt))
                      , et = r.default.Event(Ge, {
                        relatedTarget: v,
                        direction: A,
                        from: J,
                        to: O
                    });
                    return r.default(this._element).trigger(et),
                    et
                }, "_triggerSlideEvent"),
                V._setActiveIndicatorElement = o(function(v) {
                    if (this._indicatorsElement) {
                        var A = [].slice.call(this._indicatorsElement.querySelectorAll(_t));
                        r.default(A).removeClass(W);
                        var O = this._indicatorsElement.children[this._getItemIndex(v)];
                        O && r.default(O).addClass(W)
                    }
                }, "_setActiveIndicatorElement"),
                V._updateInterval = o(function() {
                    var v = this._activeElement || this._element.querySelector(Tt);
                    if (v) {
                        var A = parseInt(v.getAttribute("data-interval"), 10);
                        A ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval,
                        this._config.interval = A) : this._config.interval = this._config.defaultInterval || this._config.interval
                    }
                }, "_updateInterval"),
                V._slide = o(function(v, A) {
                    var O = this, J = this._element.querySelector(Tt), et = this._getItemIndex(J), ct = A || J && this._getItemByDirection(v, J), Ot = this._getItemIndex(ct), Yt = !!this._interval, Qt, Se, qi;
                    if (v === tn ? (Qt = st,
                    Se = at,
                    qi = Yn) : (Qt = rt,
                    Se = ut,
                    qi = xi),
                    ct && r.default(ct).hasClass(W)) {
                        this._isSliding = !1;
                        return
                    }
                    var Mi = this._triggerSlideEvent(ct, qi);
                    if (!Mi.isDefaultPrevented() && !(!J || !ct)) {
                        this._isSliding = !0,
                        Yt && this.pause(),
                        this._setActiveIndicatorElement(ct),
                        this._activeElement = ct;
                        var js = r.default.Event(hi, {
                            relatedTarget: ct,
                            direction: qi,
                            from: et,
                            to: Ot
                        });
                        if (r.default(this._element).hasClass(U)) {
                            r.default(ct).addClass(Se),
                            k.reflow(ct),
                            r.default(J).addClass(Qt),
                            r.default(ct).addClass(Qt);
                            var Rl = k.getTransitionDurationFromElement(J);
                            r.default(J).one(k.TRANSITION_END, function() {
                                r.default(ct).removeClass(Qt + " " + Se).addClass(W),
                                r.default(J).removeClass(W + " " + Se + " " + Qt),
                                O._isSliding = !1,
                                setTimeout(function() {
                                    return r.default(O._element).trigger(js)
                                }, 0)
                            }).emulateTransitionEnd(Rl)
                        } else
                            r.default(J).removeClass(W),
                            r.default(ct).addClass(W),
                            this._isSliding = !1,
                            r.default(this._element).trigger(js);
                        Yt && this.cycle()
                    }
                }, "_slide"),
                X._jQueryInterface = o(function(v) {
                    return this.each(function() {
                        var A = r.default(this).data(Si)
                          , O = d({}, Kn, r.default(this).data());
                        typeof v == "object" && (O = d({}, O, v));
                        var J = typeof v == "string" ? v : O.slide;
                        if (A || (A = new X(this,O),
                        r.default(this).data(Si, A)),
                        typeof v == "number")
                            A.to(v);
                        else if (typeof J == "string") {
                            if (typeof A[J] > "u")
                                throw new TypeError('No method named "' + J + '"');
                            A[J]()
                        } else
                            O.interval && O.ride && (A.pause(),
                            A.cycle())
                    })
                }, "_jQueryInterface"),
                X._dataApiClickHandler = o(function(v) {
                    var A = k.getSelectorFromElement(this);
                    if (A) {
                        var O = r.default(A)[0];
                        if (!(!O || !r.default(O).hasClass(R))) {
                            var J = d({}, r.default(O).data(), r.default(this).data())
                              , et = this.getAttribute("data-slide-to");
                            et && (J.interval = !1),
                            X._jQueryInterface.call(r.default(O), J),
                            et && r.default(O).data(Si).to(et),
                            v.preventDefault()
                        }
                    }
                }, "_dataApiClickHandler"),
                u(X, null, [{
                    key: "VERSION",
                    get: o(function() {
                        return Re
                    }, "get")
                }, {
                    key: "Default",
                    get: o(function() {
                        return Kn
                    }, "get")
                }]),
                X
            }
            )();
            r.default(document).on(T, ne, se._dataApiClickHandler),
            r.default(window).on(nn, function() {
                for (var X = [].slice.call(document.querySelectorAll(Ve)), V = 0, P = X.length; V < P; V++) {
                    var v = r.default(X[V]);
                    se._jQueryInterface.call(v, v.data())
                }
            }),
            r.default.fn[Xe] = se._jQueryInterface,
            r.default.fn[Xe].Constructor = se,
            r.default.fn[Xe].noConflict = function() {
                return r.default.fn[Xe] = Fe,
                se._jQueryInterface
            }
            ;
            var we = "collapse"
              , Xn = "4.6.0"
              , Be = "bs.collapse"
              , Ii = "." + Be
              , No = ".data-api"
              , fl = r.default.fn[we]
              , sn = {
                toggle: !0,
                parent: ""
            }
              , Fo = {
                toggle: "boolean",
                parent: "(string|element)"
            }
              , Vo = "show" + Ii
              , Bo = "shown" + Ii
              , Ho = "hide" + Ii
              , pl = "hidden" + Ii
              , Or = "click" + Ii + No
              , rn = "show"
              , Gn = "collapse"
              , Qn = "collapsing"
              , ks = "collapsed"
              , Ms = "width"
              , jo = "height"
              , Oe = ".show, .collapsing"
              , on = '[data-toggle="collapse"]'
              , Ni = (function() {
                function X(P, v) {
                    this._isTransitioning = !1,
                    this._element = P,
                    this._config = this._getConfig(v),
                    this._triggerArray = [].slice.call(document.querySelectorAll('[data-toggle="collapse"][href="#' + P.id + '"],' + ('[data-toggle="collapse"][data-target="#' + P.id + '"]')));
                    for (var A = [].slice.call(document.querySelectorAll(on)), O = 0, J = A.length; O < J; O++) {
                        var et = A[O]
                          , ct = k.getSelectorFromElement(et)
                          , Ot = [].slice.call(document.querySelectorAll(ct)).filter(function(Yt) {
                            return Yt === P
                        });
                        ct !== null && Ot.length > 0 && (this._selector = ct,
                        this._triggerArray.push(et))
                    }
                    this._parent = this._config.parent ? this._getParent() : null,
                    this._config.parent || this._addAriaAndCollapsedClass(this._element, this._triggerArray),
                    this._config.toggle && this.toggle()
                }
                o(X, "Collapse");
                var V = X.prototype;
                return V.toggle = o(function() {
                    r.default(this._element).hasClass(rn) ? this.hide() : this.show()
                }, "toggle"),
                V.show = o(function() {
                    var v = this;
                    if (!(this._isTransitioning || r.default(this._element).hasClass(rn))) {
                        var A, O;
                        if (this._parent && (A = [].slice.call(this._parent.querySelectorAll(Oe)).filter(function(Se) {
                            return typeof v._config.parent == "string" ? Se.getAttribute("data-parent") === v._config.parent : Se.classList.contains(Gn)
                        }),
                        A.length === 0 && (A = null)),
                        !(A && (O = r.default(A).not(this._selector).data(Be),
                        O && O._isTransitioning))) {
                            var J = r.default.Event(Vo);
                            if (r.default(this._element).trigger(J),
                            !J.isDefaultPrevented()) {
                                A && (X._jQueryInterface.call(r.default(A).not(this._selector), "hide"),
                                O || r.default(A).data(Be, null));
                                var et = this._getDimension();
                                r.default(this._element).removeClass(Gn).addClass(Qn),
                                this._element.style[et] = 0,
                                this._triggerArray.length && r.default(this._triggerArray).removeClass(ks).attr("aria-expanded", !0),
                                this.setTransitioning(!0);
                                var ct = o(function() {
                                    r.default(v._element).removeClass(Qn).addClass(Gn + " " + rn),
                                    v._element.style[et] = "",
                                    v.setTransitioning(!1),
                                    r.default(v._element).trigger(Bo)
                                }, "complete")
                                  , Ot = et[0].toUpperCase() + et.slice(1)
                                  , Yt = "scroll" + Ot
                                  , Qt = k.getTransitionDurationFromElement(this._element);
                                r.default(this._element).one(k.TRANSITION_END, ct).emulateTransitionEnd(Qt),
                                this._element.style[et] = this._element[Yt] + "px"
                            }
                        }
                    }
                }, "show"),
                V.hide = o(function() {
                    var v = this;
                    if (!(this._isTransitioning || !r.default(this._element).hasClass(rn))) {
                        var A = r.default.Event(Ho);
                        if (r.default(this._element).trigger(A),
                        !A.isDefaultPrevented()) {
                            var O = this._getDimension();
                            this._element.style[O] = this._element.getBoundingClientRect()[O] + "px",
                            k.reflow(this._element),
                            r.default(this._element).addClass(Qn).removeClass(Gn + " " + rn);
                            var J = this._triggerArray.length;
                            if (J > 0)
                                for (var et = 0; et < J; et++) {
                                    var ct = this._triggerArray[et]
                                      , Ot = k.getSelectorFromElement(ct);
                                    if (Ot !== null) {
                                        var Yt = r.default([].slice.call(document.querySelectorAll(Ot)));
                                        Yt.hasClass(rn) || r.default(ct).addClass(ks).attr("aria-expanded", !1)
                                    }
                                }
                            this.setTransitioning(!0);
                            var Qt = o(function() {
                                v.setTransitioning(!1),
                                r.default(v._element).removeClass(Qn).addClass(Gn).trigger(pl)
                            }, "complete");
                            this._element.style[O] = "";
                            var Se = k.getTransitionDurationFromElement(this._element);
                            r.default(this._element).one(k.TRANSITION_END, Qt).emulateTransitionEnd(Se)
                        }
                    }
                }, "hide"),
                V.setTransitioning = o(function(v) {
                    this._isTransitioning = v
                }, "setTransitioning"),
                V.dispose = o(function() {
                    r.default.removeData(this._element, Be),
                    this._config = null,
                    this._parent = null,
                    this._element = null,
                    this._triggerArray = null,
                    this._isTransitioning = null
                }, "dispose"),
                V._getConfig = o(function(v) {
                    return v = d({}, sn, v),
                    v.toggle = !!v.toggle,
                    k.typeCheckConfig(we, v, Fo),
                    v
                }, "_getConfig"),
                V._getDimension = o(function() {
                    var v = r.default(this._element).hasClass(Ms);
                    return v ? Ms : jo
                }, "_getDimension"),
                V._getParent = o(function() {
                    var v = this, A;
                    k.isElement(this._config.parent) ? (A = this._config.parent,
                    typeof this._config.parent.jquery < "u" && (A = this._config.parent[0])) : A = document.querySelector(this._config.parent);
                    var O = '[data-toggle="collapse"][data-parent="' + this._config.parent + '"]'
                      , J = [].slice.call(A.querySelectorAll(O));
                    return r.default(J).each(function(et, ct) {
                        v._addAriaAndCollapsedClass(X._getTargetFromElement(ct), [ct])
                    }),
                    A
                }, "_getParent"),
                V._addAriaAndCollapsedClass = o(function(v, A) {
                    var O = r.default(v).hasClass(rn);
                    A.length && r.default(A).toggleClass(ks, !O).attr("aria-expanded", O)
                }, "_addAriaAndCollapsedClass"),
                X._getTargetFromElement = o(function(v) {
                    var A = k.getSelectorFromElement(v);
                    return A ? document.querySelector(A) : null
                }, "_getTargetFromElement"),
                X._jQueryInterface = o(function(v) {
                    return this.each(function() {
                        var A = r.default(this)
                          , O = A.data(Be)
                          , J = d({}, sn, A.data(), typeof v == "object" && v ? v : {});
                        if (!O && J.toggle && typeof v == "string" && /show|hide/.test(v) && (J.toggle = !1),
                        O || (O = new X(this,J),
                        A.data(Be, O)),
                        typeof v == "string") {
                            if (typeof O[v] > "u")
                                throw new TypeError('No method named "' + v + '"');
                            O[v]()
                        }
                    })
                }, "_jQueryInterface"),
                u(X, null, [{
                    key: "VERSION",
                    get: o(function() {
                        return Xn
                    }, "get")
                }, {
                    key: "Default",
                    get: o(function() {
                        return sn
                    }, "get")
                }]),
                X
            }
            )();
            r.default(document).on(Or, on, function(X) {
                X.currentTarget.tagName === "A" && X.preventDefault();
                var V = r.default(this)
                  , P = k.getSelectorFromElement(this)
                  , v = [].slice.call(document.querySelectorAll(P));
                r.default(v).each(function() {
                    var A = r.default(this)
                      , O = A.data(Be)
                      , J = O ? "toggle" : V.data();
                    Ni._jQueryInterface.call(A, J)
                })
            }),
            r.default.fn[we] = Ni._jQueryInterface,
            r.default.fn[we].Constructor = Ni,
            r.default.fn[we].noConflict = function() {
                return r.default.fn[we] = fl,
                Ni._jQueryInterface
            }
            ;
            var _n = "dropdown"
              , gl = "4.6.0"
              , an = "bs.dropdown"
              , di = "." + an
              , En = ".data-api"
              , Wo = r.default.fn[_n]
              , Jn = 27
              , $o = 32
              , He = 9
              , Os = 38
              , ln = 40
              , ml = 3
              , vl = new RegExp(Os + "|" + ln + "|" + Jn)
              , Fi = "hide" + di
              , Vi = "hidden" + di
              , Lr = "show" + di
              , bl = "shown" + di
              , Zn = "click" + di
              , Ls = "click" + di + En
              , Ds = "keydown" + di + En
              , qo = "keyup" + di + En
              , ts = "disabled"
              , Je = "show"
              , zo = "dropup"
              , yl = "dropright"
              , _l = "dropleft"
              , Ps = "dropdown-menu-right"
              , El = "position-static"
              , Rs = '[data-toggle="dropdown"]'
              , Sl = ".dropdown form"
              , Dr = ".dropdown-menu"
              , Tl = ".navbar-nav"
              , xl = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)"
              , wl = "top-start"
              , Uo = "top-end"
              , Pr = "bottom-start"
              , Ko = "bottom-end"
              , Rr = "right-start"
              , Yo = "left-start"
              , Xo = {
                offset: 0,
                flip: !0,
                boundary: "scrollParent",
                reference: "toggle",
                display: "dynamic",
                popperConfig: null
            }
              , Ir = {
                offset: "(number|string|function)",
                flip: "boolean",
                boundary: "(string|element)",
                reference: "(string|element)",
                display: "string",
                popperConfig: "(null|object)"
            }
              , Bi = (function() {
                function X(P, v) {
                    this._element = P,
                    this._popper = null,
                    this._config = this._getConfig(v),
                    this._menu = this._getMenuElement(),
                    this._inNavbar = this._detectNavbar(),
                    this._addEventListeners()
                }
                o(X, "Dropdown");
                var V = X.prototype;
                return V.toggle = o(function() {
                    if (!(this._element.disabled || r.default(this._element).hasClass(ts))) {
                        var v = r.default(this._menu).hasClass(Je);
                        X._clearMenus(),
                        !v && this.show(!0)
                    }
                }, "toggle"),
                V.show = o(function(v) {
                    if (v === void 0 && (v = !1),
                    !(this._element.disabled || r.default(this._element).hasClass(ts) || r.default(this._menu).hasClass(Je))) {
                        var A = {
                            relatedTarget: this._element
                        }
                          , O = r.default.Event(Lr, A)
                          , J = X._getParentFromElement(this._element);
                        if (r.default(J).trigger(O),
                        !O.isDefaultPrevented()) {
                            if (!this._inNavbar && v) {
                                if (typeof a.default > "u")
                                    throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
                                var et = this._element;
                                this._config.reference === "parent" ? et = J : k.isElement(this._config.reference) && (et = this._config.reference,
                                typeof this._config.reference.jquery < "u" && (et = this._config.reference[0])),
                                this._config.boundary !== "scrollParent" && r.default(J).addClass(El),
                                this._popper = new a.default(et,this._menu,this._getPopperConfig())
                            }
                            "ontouchstart"in document.documentElement && r.default(J).closest(Tl).length === 0 && r.default(document.body).children().on("mouseover", null, r.default.noop),
                            this._element.focus(),
                            this._element.setAttribute("aria-expanded", !0),
                            r.default(this._menu).toggleClass(Je),
                            r.default(J).toggleClass(Je).trigger(r.default.Event(bl, A))
                        }
                    }
                }, "show"),
                V.hide = o(function() {
                    if (!(this._element.disabled || r.default(this._element).hasClass(ts) || !r.default(this._menu).hasClass(Je))) {
                        var v = {
                            relatedTarget: this._element
                        }
                          , A = r.default.Event(Fi, v)
                          , O = X._getParentFromElement(this._element);
                        r.default(O).trigger(A),
                        !A.isDefaultPrevented() && (this._popper && this._popper.destroy(),
                        r.default(this._menu).toggleClass(Je),
                        r.default(O).toggleClass(Je).trigger(r.default.Event(Vi, v)))
                    }
                }, "hide"),
                V.dispose = o(function() {
                    r.default.removeData(this._element, an),
                    r.default(this._element).off(di),
                    this._element = null,
                    this._menu = null,
                    this._popper !== null && (this._popper.destroy(),
                    this._popper = null)
                }, "dispose"),
                V.update = o(function() {
                    this._inNavbar = this._detectNavbar(),
                    this._popper !== null && this._popper.scheduleUpdate()
                }, "update"),
                V._addEventListeners = o(function() {
                    var v = this;
                    r.default(this._element).on(Zn, function(A) {
                        A.preventDefault(),
                        A.stopPropagation(),
                        v.toggle()
                    })
                }, "_addEventListeners"),
                V._getConfig = o(function(v) {
                    return v = d({}, this.constructor.Default, r.default(this._element).data(), v),
                    k.typeCheckConfig(_n, v, this.constructor.DefaultType),
                    v
                }, "_getConfig"),
                V._getMenuElement = o(function() {
                    if (!this._menu) {
                        var v = X._getParentFromElement(this._element);
                        v && (this._menu = v.querySelector(Dr))
                    }
                    return this._menu
                }, "_getMenuElement"),
                V._getPlacement = o(function() {
                    var v = r.default(this._element.parentNode)
                      , A = Pr;
                    return v.hasClass(zo) ? A = r.default(this._menu).hasClass(Ps) ? Uo : wl : v.hasClass(yl) ? A = Rr : v.hasClass(_l) ? A = Yo : r.default(this._menu).hasClass(Ps) && (A = Ko),
                    A
                }, "_getPlacement"),
                V._detectNavbar = o(function() {
                    return r.default(this._element).closest(".navbar").length > 0
                }, "_detectNavbar"),
                V._getOffset = o(function() {
                    var v = this
                      , A = {};
                    return typeof this._config.offset == "function" ? A.fn = function(O) {
                        return O.offsets = d({}, O.offsets, v._config.offset(O.offsets, v._element) || {}),
                        O
                    }
                    : A.offset = this._config.offset,
                    A
                }, "_getOffset"),
                V._getPopperConfig = o(function() {
                    var v = {
                        placement: this._getPlacement(),
                        modifiers: {
                            offset: this._getOffset(),
                            flip: {
                                enabled: this._config.flip
                            },
                            preventOverflow: {
                                boundariesElement: this._config.boundary
                            }
                        }
                    };
                    return this._config.display === "static" && (v.modifiers.applyStyle = {
                        enabled: !1
                    }),
                    d({}, v, this._config.popperConfig)
                }, "_getPopperConfig"),
                X._jQueryInterface = o(function(v) {
                    return this.each(function() {
                        var A = r.default(this).data(an)
                          , O = typeof v == "object" ? v : null;
                        if (A || (A = new X(this,O),
                        r.default(this).data(an, A)),
                        typeof v == "string") {
                            if (typeof A[v] > "u")
                                throw new TypeError('No method named "' + v + '"');
                            A[v]()
                        }
                    })
                }, "_jQueryInterface"),
                X._clearMenus = o(function(v) {
                    if (!(v && (v.which === ml || v.type === "keyup" && v.which !== He)))
                        for (var A = [].slice.call(document.querySelectorAll(Rs)), O = 0, J = A.length; O < J; O++) {
                            var et = X._getParentFromElement(A[O])
                              , ct = r.default(A[O]).data(an)
                              , Ot = {
                                relatedTarget: A[O]
                            };
                            if (v && v.type === "click" && (Ot.clickEvent = v),
                            !!ct) {
                                var Yt = ct._menu;
                                if (r.default(et).hasClass(Je) && !(v && (v.type === "click" && /input|textarea/i.test(v.target.tagName) || v.type === "keyup" && v.which === He) && r.default.contains(et, v.target))) {
                                    var Qt = r.default.Event(Fi, Ot);
                                    r.default(et).trigger(Qt),
                                    !Qt.isDefaultPrevented() && ("ontouchstart"in document.documentElement && r.default(document.body).children().off("mouseover", null, r.default.noop),
                                    A[O].setAttribute("aria-expanded", "false"),
                                    ct._popper && ct._popper.destroy(),
                                    r.default(Yt).removeClass(Je),
                                    r.default(et).removeClass(Je).trigger(r.default.Event(Vi, Ot)))
                                }
                            }
                        }
                }, "_clearMenus"),
                X._getParentFromElement = o(function(v) {
                    var A, O = k.getSelectorFromElement(v);
                    return O && (A = document.querySelector(O)),
                    A || v.parentNode
                }, "_getParentFromElement"),
                X._dataApiKeydownHandler = o(function(v) {
                    if (!(/input|textarea/i.test(v.target.tagName) ? v.which === $o || v.which !== Jn && (v.which !== ln && v.which !== Os || r.default(v.target).closest(Dr).length) : !vl.test(v.which)) && !(this.disabled || r.default(this).hasClass(ts))) {
                        var A = X._getParentFromElement(this)
                          , O = r.default(A).hasClass(Je);
                        if (!(!O && v.which === Jn)) {
                            if (v.preventDefault(),
                            v.stopPropagation(),
                            !O || v.which === Jn || v.which === $o) {
                                v.which === Jn && r.default(A.querySelector(Rs)).trigger("focus"),
                                r.default(this).trigger("click");
                                return
                            }
                            var J = [].slice.call(A.querySelectorAll(xl)).filter(function(ct) {
                                return r.default(ct).is(":visible")
                            });
                            if (J.length !== 0) {
                                var et = J.indexOf(v.target);
                                v.which === Os && et > 0 && et--,
                                v.which === ln && et < J.length - 1 && et++,
                                et < 0 && (et = 0),
                                J[et].focus()
                            }
                        }
                    }
                }, "_dataApiKeydownHandler"),
                u(X, null, [{
                    key: "VERSION",
                    get: o(function() {
                        return gl
                    }, "get")
                }, {
                    key: "Default",
                    get: o(function() {
                        return Xo
                    }, "get")
                }, {
                    key: "DefaultType",
                    get: o(function() {
                        return Ir
                    }, "get")
                }]),
                X
            }
            )();
            r.default(document).on(Ds, Rs, Bi._dataApiKeydownHandler).on(Ds, Dr, Bi._dataApiKeydownHandler).on(Ls + " " + qo, Bi._clearMenus).on(Ls, Rs, function(X) {
                X.preventDefault(),
                X.stopPropagation(),
                Bi._jQueryInterface.call(r.default(this), "toggle")
            }).on(Ls, Sl, function(X) {
                X.stopPropagation()
            }),
            r.default.fn[_n] = Bi._jQueryInterface,
            r.default.fn[_n].Constructor = Bi,
            r.default.fn[_n].noConflict = function() {
                return r.default.fn[_n] = Wo,
                Bi._jQueryInterface
            }
            ;
            var Sn = "modal"
              , Cl = "4.6.0"
              , wi = "bs.modal"
              , Le = "." + wi
              , Nr = ".data-api"
              , Al = r.default.fn[Sn]
              , Go = 27
              , Fr = {
                backdrop: !0,
                keyboard: !0,
                focus: !0,
                show: !0
            }
              , c = {
                backdrop: "(boolean|string)",
                keyboard: "boolean",
                focus: "boolean",
                show: "boolean"
            }
              , h = "hide" + Le
              , g = "hidePrevented" + Le
              , m = "hidden" + Le
              , y = "show" + Le
              , _ = "shown" + Le
              , S = "focusin" + Le
              , N = "resize" + Le
              , D = "click.dismiss" + Le
              , q = "keydown.dismiss" + Le
              , tt = "mouseup.dismiss" + Le
              , it = "mousedown.dismiss" + Le
              , G = "click" + Le + Nr
              , lt = "modal-dialog-scrollable"
              , kt = "modal-scrollbar-measure"
              , Wt = "modal-backdrop"
              , Pt = "modal-open"
              , le = "fade"
              , ce = "show"
              , Ze = "modal-static"
              , fi = ".modal-dialog"
              , Bt = ".modal-body"
              , cn = '[data-toggle="modal"]'
              , qt = '[data-dismiss="modal"]'
              , oe = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top"
              , Tn = ".sticky-top"
              , un = (function() {
                function X(P, v) {
                    this._config = this._getConfig(v),
                    this._element = P,
                    this._dialog = P.querySelector(fi),
                    this._backdrop = null,
                    this._isShown = !1,
                    this._isBodyOverflowing = !1,
                    this._ignoreBackdropClick = !1,
                    this._isTransitioning = !1,
                    this._scrollbarWidth = 0
                }
                o(X, "Modal");
                var V = X.prototype;
                return V.toggle = o(function(v) {
                    return this._isShown ? this.hide() : this.show(v)
                }, "toggle"),
                V.show = o(function(v) {
                    var A = this;
                    if (!(this._isShown || this._isTransitioning)) {
                        r.default(this._element).hasClass(le) && (this._isTransitioning = !0);
                        var O = r.default.Event(y, {
                            relatedTarget: v
                        });
                        r.default(this._element).trigger(O),
                        !(this._isShown || O.isDefaultPrevented()) && (this._isShown = !0,
                        this._checkScrollbar(),
                        this._setScrollbar(),
                        this._adjustDialog(),
                        this._setEscapeEvent(),
                        this._setResizeEvent(),
                        r.default(this._element).on(D, qt, function(J) {
                            return A.hide(J)
                        }),
                        r.default(this._dialog).on(it, function() {
                            r.default(A._element).one(tt, function(J) {
                                r.default(J.target).is(A._element) && (A._ignoreBackdropClick = !0)
                            })
                        }),
                        this._showBackdrop(function() {
                            return A._showElement(v)
                        }))
                    }
                }, "show"),
                V.hide = o(function(v) {
                    var A = this;
                    if (v && v.preventDefault(),
                    !(!this._isShown || this._isTransitioning)) {
                        var O = r.default.Event(h);
                        if (r.default(this._element).trigger(O),
                        !(!this._isShown || O.isDefaultPrevented())) {
                            this._isShown = !1;
                            var J = r.default(this._element).hasClass(le);
                            if (J && (this._isTransitioning = !0),
                            this._setEscapeEvent(),
                            this._setResizeEvent(),
                            r.default(document).off(S),
                            r.default(this._element).removeClass(ce),
                            r.default(this._element).off(D),
                            r.default(this._dialog).off(it),
                            J) {
                                var et = k.getTransitionDurationFromElement(this._element);
                                r.default(this._element).one(k.TRANSITION_END, function(ct) {
                                    return A._hideModal(ct)
                                }).emulateTransitionEnd(et)
                            } else
                                this._hideModal()
                        }
                    }
                }, "hide"),
                V.dispose = o(function() {
                    [window, this._element, this._dialog].forEach(function(v) {
                        return r.default(v).off(Le)
                    }),
                    r.default(document).off(S),
                    r.default.removeData(this._element, wi),
                    this._config = null,
                    this._element = null,
                    this._dialog = null,
                    this._backdrop = null,
                    this._isShown = null,
                    this._isBodyOverflowing = null,
                    this._ignoreBackdropClick = null,
                    this._isTransitioning = null,
                    this._scrollbarWidth = null
                }, "dispose"),
                V.handleUpdate = o(function() {
                    this._adjustDialog()
                }, "handleUpdate"),
                V._getConfig = o(function(v) {
                    return v = d({}, Fr, v),
                    k.typeCheckConfig(Sn, v, c),
                    v
                }, "_getConfig"),
                V._triggerBackdropTransition = o(function() {
                    var v = this
                      , A = r.default.Event(g);
                    if (r.default(this._element).trigger(A),
                    !A.isDefaultPrevented()) {
                        var O = this._element.scrollHeight > document.documentElement.clientHeight;
                        O || (this._element.style.overflowY = "hidden"),
                        this._element.classList.add(Ze);
                        var J = k.getTransitionDurationFromElement(this._dialog);
                        r.default(this._element).off(k.TRANSITION_END),
                        r.default(this._element).one(k.TRANSITION_END, function() {
                            v._element.classList.remove(Ze),
                            O || r.default(v._element).one(k.TRANSITION_END, function() {
                                v._element.style.overflowY = ""
                            }).emulateTransitionEnd(v._element, J)
                        }).emulateTransitionEnd(J),
                        this._element.focus()
                    }
                }, "_triggerBackdropTransition"),
                V._showElement = o(function(v) {
                    var A = this
                      , O = r.default(this._element).hasClass(le)
                      , J = this._dialog ? this._dialog.querySelector(Bt) : null;
                    (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) && document.body.appendChild(this._element),
                    this._element.style.display = "block",
                    this._element.removeAttribute("aria-hidden"),
                    this._element.setAttribute("aria-modal", !0),
                    this._element.setAttribute("role", "dialog"),
                    r.default(this._dialog).hasClass(lt) && J ? J.scrollTop = 0 : this._element.scrollTop = 0,
                    O && k.reflow(this._element),
                    r.default(this._element).addClass(ce),
                    this._config.focus && this._enforceFocus();
                    var et = r.default.Event(_, {
                        relatedTarget: v
                    })
                      , ct = o(function() {
                        A._config.focus && A._element.focus(),
                        A._isTransitioning = !1,
                        r.default(A._element).trigger(et)
                    }, "transitionComplete");
                    if (O) {
                        var Ot = k.getTransitionDurationFromElement(this._dialog);
                        r.default(this._dialog).one(k.TRANSITION_END, ct).emulateTransitionEnd(Ot)
                    } else
                        ct()
                }, "_showElement"),
                V._enforceFocus = o(function() {
                    var v = this;
                    r.default(document).off(S).on(S, function(A) {
                        document !== A.target && v._element !== A.target && r.default(v._element).has(A.target).length === 0 && v._element.focus()
                    })
                }, "_enforceFocus"),
                V._setEscapeEvent = o(function() {
                    var v = this;
                    this._isShown ? r.default(this._element).on(q, function(A) {
                        v._config.keyboard && A.which === Go ? (A.preventDefault(),
                        v.hide()) : !v._config.keyboard && A.which === Go && v._triggerBackdropTransition()
                    }) : this._isShown || r.default(this._element).off(q)
                }, "_setEscapeEvent"),
                V._setResizeEvent = o(function() {
                    var v = this;
                    this._isShown ? r.default(window).on(N, function(A) {
                        return v.handleUpdate(A)
                    }) : r.default(window).off(N)
                }, "_setResizeEvent"),
                V._hideModal = o(function() {
                    var v = this;
                    this._element.style.display = "none",
                    this._element.setAttribute("aria-hidden", !0),
                    this._element.removeAttribute("aria-modal"),
                    this._element.removeAttribute("role"),
                    this._isTransitioning = !1,
                    this._showBackdrop(function() {
                        r.default(document.body).removeClass(Pt),
                        v._resetAdjustments(),
                        v._resetScrollbar(),
                        r.default(v._element).trigger(m)
                    })
                }, "_hideModal"),
                V._removeBackdrop = o(function() {
                    this._backdrop && (r.default(this._backdrop).remove(),
                    this._backdrop = null)
                }, "_removeBackdrop"),
                V._showBackdrop = o(function(v) {
                    var A = this
                      , O = r.default(this._element).hasClass(le) ? le : "";
                    if (this._isShown && this._config.backdrop) {
                        if (this._backdrop = document.createElement("div"),
                        this._backdrop.className = Wt,
                        O && this._backdrop.classList.add(O),
                        r.default(this._backdrop).appendTo(document.body),
                        r.default(this._element).on(D, function(Ot) {
                            if (A._ignoreBackdropClick) {
                                A._ignoreBackdropClick = !1;
                                return
                            }
                            Ot.target === Ot.currentTarget && (A._config.backdrop === "static" ? A._triggerBackdropTransition() : A.hide())
                        }),
                        O && k.reflow(this._backdrop),
                        r.default(this._backdrop).addClass(ce),
                        !v)
                            return;
                        if (!O) {
                            v();
                            return
                        }
                        var J = k.getTransitionDurationFromElement(this._backdrop);
                        r.default(this._backdrop).one(k.TRANSITION_END, v).emulateTransitionEnd(J)
                    } else if (!this._isShown && this._backdrop) {
                        r.default(this._backdrop).removeClass(ce);
                        var et = o(function() {
                            A._removeBackdrop(),
                            v && v()
                        }, "callbackRemove");
                        if (r.default(this._element).hasClass(le)) {
                            var ct = k.getTransitionDurationFromElement(this._backdrop);
                            r.default(this._backdrop).one(k.TRANSITION_END, et).emulateTransitionEnd(ct)
                        } else
                            et()
                    } else
                        v && v()
                }, "_showBackdrop"),
                V._adjustDialog = o(function() {
                    var v = this._element.scrollHeight > document.documentElement.clientHeight;
                    !this._isBodyOverflowing && v && (this._element.style.paddingLeft = this._scrollbarWidth + "px"),
                    this._isBodyOverflowing && !v && (this._element.style.paddingRight = this._scrollbarWidth + "px")
                }, "_adjustDialog"),
                V._resetAdjustments = o(function() {
                    this._element.style.paddingLeft = "",
                    this._element.style.paddingRight = ""
                }, "_resetAdjustments"),
                V._checkScrollbar = o(function() {
                    var v = document.body.getBoundingClientRect();
                    this._isBodyOverflowing = Math.round(v.left + v.right) < window.innerWidth,
                    this._scrollbarWidth = this._getScrollbarWidth()
                }, "_checkScrollbar"),
                V._setScrollbar = o(function() {
                    var v = this;
                    if (this._isBodyOverflowing) {
                        var A = [].slice.call(document.querySelectorAll(oe))
                          , O = [].slice.call(document.querySelectorAll(Tn));
                        r.default(A).each(function(ct, Ot) {
                            var Yt = Ot.style.paddingRight
                              , Qt = r.default(Ot).css("padding-right");
                            r.default(Ot).data("padding-right", Yt).css("padding-right", parseFloat(Qt) + v._scrollbarWidth + "px")
                        }),
                        r.default(O).each(function(ct, Ot) {
                            var Yt = Ot.style.marginRight
                              , Qt = r.default(Ot).css("margin-right");
                            r.default(Ot).data("margin-right", Yt).css("margin-right", parseFloat(Qt) - v._scrollbarWidth + "px")
                        });
                        var J = document.body.style.paddingRight
                          , et = r.default(document.body).css("padding-right");
                        r.default(document.body).data("padding-right", J).css("padding-right", parseFloat(et) + this._scrollbarWidth + "px")
                    }
                    r.default(document.body).addClass(Pt)
                }, "_setScrollbar"),
                V._resetScrollbar = o(function() {
                    var v = [].slice.call(document.querySelectorAll(oe));
                    r.default(v).each(function(J, et) {
                        var ct = r.default(et).data("padding-right");
                        r.default(et).removeData("padding-right"),
                        et.style.paddingRight = ct || ""
                    });
                    var A = [].slice.call(document.querySelectorAll("" + Tn));
                    r.default(A).each(function(J, et) {
                        var ct = r.default(et).data("margin-right");
                        typeof ct < "u" && r.default(et).css("margin-right", ct).removeData("margin-right")
                    });
                    var O = r.default(document.body).data("padding-right");
                    r.default(document.body).removeData("padding-right"),
                    document.body.style.paddingRight = O || ""
                }, "_resetScrollbar"),
                V._getScrollbarWidth = o(function() {
                    var v = document.createElement("div");
                    v.className = kt,
                    document.body.appendChild(v);
                    var A = v.getBoundingClientRect().width - v.clientWidth;
                    return document.body.removeChild(v),
                    A
                }, "_getScrollbarWidth"),
                X._jQueryInterface = o(function(v, A) {
                    return this.each(function() {
                        var O = r.default(this).data(wi)
                          , J = d({}, Fr, r.default(this).data(), typeof v == "object" && v ? v : {});
                        if (O || (O = new X(this,J),
                        r.default(this).data(wi, O)),
                        typeof v == "string") {
                            if (typeof O[v] > "u")
                                throw new TypeError('No method named "' + v + '"');
                            O[v](A)
                        } else
                            J.show && O.show(A)
                    })
                }, "_jQueryInterface"),
                u(X, null, [{
                    key: "VERSION",
                    get: o(function() {
                        return Cl
                    }, "get")
                }, {
                    key: "Default",
                    get: o(function() {
                        return Fr
                    }, "get")
                }]),
                X
            }
            )();
            r.default(document).on(G, cn, function(X) {
                var V = this, P, v = k.getSelectorFromElement(this);
                v && (P = document.querySelector(v));
                var A = r.default(P).data(wi) ? "toggle" : d({}, r.default(P).data(), r.default(this).data());
                (this.tagName === "A" || this.tagName === "AREA") && X.preventDefault();
                var O = r.default(P).one(y, function(J) {
                    J.isDefaultPrevented() || O.one(m, function() {
                        r.default(V).is(":visible") && V.focus()
                    })
                });
                un._jQueryInterface.call(r.default(P), A, this)
            }),
            r.default.fn[Sn] = un._jQueryInterface,
            r.default.fn[Sn].Constructor = un,
            r.default.fn[Sn].noConflict = function() {
                return r.default.fn[Sn] = Al,
                un._jQueryInterface
            }
            ;
            var pi = ["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]
              , es = /^aria-[\w-]*$/i
              , gi = {
                "*": ["class", "dir", "id", "lang", "role", es],
                a: ["target", "href", "title", "rel"],
                area: [],
                b: [],
                br: [],
                col: [],
                code: [],
                div: [],
                em: [],
                hr: [],
                h1: [],
                h2: [],
                h3: [],
                h4: [],
                h5: [],
                h6: [],
                i: [],
                img: ["src", "srcset", "alt", "title", "width", "height"],
                li: [],
                ol: [],
                p: [],
                pre: [],
                s: [],
                small: [],
                span: [],
                sub: [],
                sup: [],
                strong: [],
                u: [],
                ul: []
            }
              , Hi = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/gi
              , ji = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;
            function je(X, V) {
                var P = X.nodeName.toLowerCase();
                if (V.indexOf(P) !== -1)
                    return pi.indexOf(P) !== -1 ? !!(X.nodeValue.match(Hi) || X.nodeValue.match(ji)) : !0;
                for (var v = V.filter(function(J) {
                    return J instanceof RegExp
                }), A = 0, O = v.length; A < O; A++)
                    if (P.match(v[A]))
                        return !0;
                return !1
            }
            o(je, "allowedAttribute");
            function Is(X, V, P) {
                if (X.length === 0)
                    return X;
                if (P && typeof P == "function")
                    return P(X);
                for (var v = new window.DOMParser, A = v.parseFromString(X, "text/html"), O = Object.keys(V), J = [].slice.call(A.body.querySelectorAll("*")), et = o(function(Se, qi) {
                    var Mi = J[Se]
                      , js = Mi.nodeName.toLowerCase();
                    if (O.indexOf(Mi.nodeName.toLowerCase()) === -1)
                        return Mi.parentNode.removeChild(Mi),
                        "continue";
                    var Rl = [].slice.call(Mi.attributes)
                      , Xm = [].concat(V["*"] || [], V[js] || []);
                    Rl.forEach(function(qd) {
                        je(qd, Xm) || Mi.removeAttribute(qd.nodeName)
                    })
                }, "_loop"), ct = 0, Ot = J.length; ct < Ot; ct++)
                    var Yt = et(ct);
                return A.body.innerHTML
            }
            o(Is, "sanitizeHtml");
            var Ce = "tooltip"
              , Ci = "4.6.0"
              , Ns = "bs.tooltip"
              , ti = "." + Ns
              , kl = r.default.fn[Ce]
              , Kt = "bs-tooltip"
              , Fs = new RegExp("(^|\\s)" + Kt + "\\S+","g")
              , ei = ["sanitize", "whiteList", "sanitizeFn"]
              , xn = {
                animation: "boolean",
                template: "string",
                title: "(string|element|function)",
                trigger: "string",
                delay: "(number|object)",
                html: "boolean",
                selector: "(string|boolean)",
                placement: "(string|function)",
                offset: "(number|string|function)",
                container: "(string|element|boolean)",
                fallbackPlacement: "(string|array)",
                boundary: "(string|element)",
                customClass: "(string|function)",
                sanitize: "boolean",
                sanitizeFn: "(null|function)",
                whiteList: "object",
                popperConfig: "(null|object)"
            }
              , Ml = {
                AUTO: "auto",
                TOP: "top",
                RIGHT: "right",
                BOTTOM: "bottom",
                LEFT: "left"
            }
              , Ol = {
                animation: !0,
                template: '<div class="tooltip" role="tooltip"><div class="arrow"></div><div class="tooltip-inner"></div></div>',
                trigger: "hover focus",
                title: "",
                delay: 0,
                html: !1,
                selector: !1,
                placement: "top",
                offset: 0,
                container: !1,
                fallbackPlacement: "flip",
                boundary: "scrollParent",
                customClass: "",
                sanitize: !0,
                sanitizeFn: null,
                whiteList: gi,
                popperConfig: null
            }
              , wn = "show"
              , Ai = "out"
              , Vr = {
                HIDE: "hide" + ti,
                HIDDEN: "hidden" + ti,
                SHOW: "show" + ti,
                SHOWN: "shown" + ti,
                INSERTED: "inserted" + ti,
                CLICK: "click" + ti,
                FOCUSIN: "focusin" + ti,
                FOCUSOUT: "focusout" + ti,
                MOUSEENTER: "mouseenter" + ti,
                MOUSELEAVE: "mouseleave" + ti
            }
              , We = "fade"
              , Cn = "show"
              , is = ".tooltip-inner"
              , Vs = ".arrow"
              , Wi = "hover"
              , ns = "focus"
              , Ll = "click"
              , Bs = "manual"
              , ki = (function() {
                function X(P, v) {
                    if (typeof a.default > "u")
                        throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
                    this._isEnabled = !0,
                    this._timeout = 0,
                    this._hoverState = "",
                    this._activeTrigger = {},
                    this._popper = null,
                    this.element = P,
                    this.config = this._getConfig(v),
                    this.tip = null,
                    this._setListeners()
                }
                o(X, "Tooltip");
                var V = X.prototype;
                return V.enable = o(function() {
                    this._isEnabled = !0
                }, "enable"),
                V.disable = o(function() {
                    this._isEnabled = !1
                }, "disable"),
                V.toggleEnabled = o(function() {
                    this._isEnabled = !this._isEnabled
                }, "toggleEnabled"),
                V.toggle = o(function(v) {
                    if (this._isEnabled)
                        if (v) {
                            var A = this.constructor.DATA_KEY
                              , O = r.default(v.currentTarget).data(A);
                            O || (O = new this.constructor(v.currentTarget,this._getDelegateConfig()),
                            r.default(v.currentTarget).data(A, O)),
                            O._activeTrigger.click = !O._activeTrigger.click,
                            O._isWithActiveTrigger() ? O._enter(null, O) : O._leave(null, O)
                        } else {
                            if (r.default(this.getTipElement()).hasClass(Cn)) {
                                this._leave(null, this);
                                return
                            }
                            this._enter(null, this)
                        }
                }, "toggle"),
                V.dispose = o(function() {
                    clearTimeout(this._timeout),
                    r.default.removeData(this.element, this.constructor.DATA_KEY),
                    r.default(this.element).off(this.constructor.EVENT_KEY),
                    r.default(this.element).closest(".modal").off("hide.bs.modal", this._hideModalHandler),
                    this.tip && r.default(this.tip).remove(),
                    this._isEnabled = null,
                    this._timeout = null,
                    this._hoverState = null,
                    this._activeTrigger = null,
                    this._popper && this._popper.destroy(),
                    this._popper = null,
                    this.element = null,
                    this.config = null,
                    this.tip = null
                }, "dispose"),
                V.show = o(function() {
                    var v = this;
                    if (r.default(this.element).css("display") === "none")
                        throw new Error("Please use show on visible elements");
                    var A = r.default.Event(this.constructor.Event.SHOW);
                    if (this.isWithContent() && this._isEnabled) {
                        r.default(this.element).trigger(A);
                        var O = k.findShadowRoot(this.element)
                          , J = r.default.contains(O !== null ? O : this.element.ownerDocument.documentElement, this.element);
                        if (A.isDefaultPrevented() || !J)
                            return;
                        var et = this.getTipElement()
                          , ct = k.getUID(this.constructor.NAME);
                        et.setAttribute("id", ct),
                        this.element.setAttribute("aria-describedby", ct),
                        this.setContent(),
                        this.config.animation && r.default(et).addClass(We);
                        var Ot = typeof this.config.placement == "function" ? this.config.placement.call(this, et, this.element) : this.config.placement
                          , Yt = this._getAttachment(Ot);
                        this.addAttachmentClass(Yt);
                        var Qt = this._getContainer();
                        r.default(et).data(this.constructor.DATA_KEY, this),
                        r.default.contains(this.element.ownerDocument.documentElement, this.tip) || r.default(et).appendTo(Qt),
                        r.default(this.element).trigger(this.constructor.Event.INSERTED),
                        this._popper = new a.default(this.element,et,this._getPopperConfig(Yt)),
                        r.default(et).addClass(Cn),
                        r.default(et).addClass(this.config.customClass),
                        "ontouchstart"in document.documentElement && r.default(document.body).children().on("mouseover", null, r.default.noop);
                        var Se = o(function() {
                            v.config.animation && v._fixTransition();
                            var js = v._hoverState;
                            v._hoverState = null,
                            r.default(v.element).trigger(v.constructor.Event.SHOWN),
                            js === Ai && v._leave(null, v)
                        }, "complete");
                        if (r.default(this.tip).hasClass(We)) {
                            var qi = k.getTransitionDurationFromElement(this.tip);
                            r.default(this.tip).one(k.TRANSITION_END, Se).emulateTransitionEnd(qi)
                        } else
                            Se()
                    }
                }, "show"),
                V.hide = o(function(v) {
                    var A = this
                      , O = this.getTipElement()
                      , J = r.default.Event(this.constructor.Event.HIDE)
                      , et = o(function() {
                        A._hoverState !== wn && O.parentNode && O.parentNode.removeChild(O),
                        A._cleanTipClass(),
                        A.element.removeAttribute("aria-describedby"),
                        r.default(A.element).trigger(A.constructor.Event.HIDDEN),
                        A._popper !== null && A._popper.destroy(),
                        v && v()
                    }, "complete");
                    if (r.default(this.element).trigger(J),
                    !J.isDefaultPrevented()) {
                        if (r.default(O).removeClass(Cn),
                        "ontouchstart"in document.documentElement && r.default(document.body).children().off("mouseover", null, r.default.noop),
                        this._activeTrigger[Ll] = !1,
                        this._activeTrigger[ns] = !1,
                        this._activeTrigger[Wi] = !1,
                        r.default(this.tip).hasClass(We)) {
                            var ct = k.getTransitionDurationFromElement(O);
                            r.default(O).one(k.TRANSITION_END, et).emulateTransitionEnd(ct)
                        } else
                            et();
                        this._hoverState = ""
                    }
                }, "hide"),
                V.update = o(function() {
                    this._popper !== null && this._popper.scheduleUpdate()
                }, "update"),
                V.isWithContent = o(function() {
                    return !!this.getTitle()
                }, "isWithContent"),
                V.addAttachmentClass = o(function(v) {
                    r.default(this.getTipElement()).addClass(Kt + "-" + v)
                }, "addAttachmentClass"),
                V.getTipElement = o(function() {
                    return this.tip = this.tip || r.default(this.config.template)[0],
                    this.tip
                }, "getTipElement"),
                V.setContent = o(function() {
                    var v = this.getTipElement();
                    this.setElementContent(r.default(v.querySelectorAll(is)), this.getTitle()),
                    r.default(v).removeClass(We + " " + Cn)
                }, "setContent"),
                V.setElementContent = o(function(v, A) {
                    if (typeof A == "object" && (A.nodeType || A.jquery)) {
                        this.config.html ? r.default(A).parent().is(v) || v.empty().append(A) : v.text(r.default(A).text());
                        return
                    }
                    this.config.html ? (this.config.sanitize && (A = Is(A, this.config.whiteList, this.config.sanitizeFn)),
                    v.html(A)) : v.text(A)
                }, "setElementContent"),
                V.getTitle = o(function() {
                    var v = this.element.getAttribute("data-original-title");
                    return v || (v = typeof this.config.title == "function" ? this.config.title.call(this.element) : this.config.title),
                    v
                }, "getTitle"),
                V._getPopperConfig = o(function(v) {
                    var A = this
                      , O = {
                        placement: v,
                        modifiers: {
                            offset: this._getOffset(),
                            flip: {
                                behavior: this.config.fallbackPlacement
                            },
                            arrow: {
                                element: Vs
                            },
                            preventOverflow: {
                                boundariesElement: this.config.boundary
                            }
                        },
                        onCreate: o(function(et) {
                            et.originalPlacement !== et.placement && A._handlePopperPlacementChange(et)
                        }, "onCreate"),
                        onUpdate: o(function(et) {
                            return A._handlePopperPlacementChange(et)
                        }, "onUpdate")
                    };
                    return d({}, O, this.config.popperConfig)
                }, "_getPopperConfig"),
                V._getOffset = o(function() {
                    var v = this
                      , A = {};
                    return typeof this.config.offset == "function" ? A.fn = function(O) {
                        return O.offsets = d({}, O.offsets, v.config.offset(O.offsets, v.element) || {}),
                        O
                    }
                    : A.offset = this.config.offset,
                    A
                }, "_getOffset"),
                V._getContainer = o(function() {
                    return this.config.container === !1 ? document.body : k.isElement(this.config.container) ? r.default(this.config.container) : r.default(document).find(this.config.container)
                }, "_getContainer"),
                V._getAttachment = o(function(v) {
                    return Ml[v.toUpperCase()]
                }, "_getAttachment"),
                V._setListeners = o(function() {
                    var v = this
                      , A = this.config.trigger.split(" ");
                    A.forEach(function(O) {
                        if (O === "click")
                            r.default(v.element).on(v.constructor.Event.CLICK, v.config.selector, function(ct) {
                                return v.toggle(ct)
                            });
                        else if (O !== Bs) {
                            var J = O === Wi ? v.constructor.Event.MOUSEENTER : v.constructor.Event.FOCUSIN
                              , et = O === Wi ? v.constructor.Event.MOUSELEAVE : v.constructor.Event.FOCUSOUT;
                            r.default(v.element).on(J, v.config.selector, function(ct) {
                                return v._enter(ct)
                            }).on(et, v.config.selector, function(ct) {
                                return v._leave(ct)
                            })
                        }
                    }),
                    this._hideModalHandler = function() {
                        v.element && v.hide()
                    }
                    ,
                    r.default(this.element).closest(".modal").on("hide.bs.modal", this._hideModalHandler),
                    this.config.selector ? this.config = d({}, this.config, {
                        trigger: "manual",
                        selector: ""
                    }) : this._fixTitle()
                }, "_setListeners"),
                V._fixTitle = o(function() {
                    var v = typeof this.element.getAttribute("data-original-title");
                    (this.element.getAttribute("title") || v !== "string") && (this.element.setAttribute("data-original-title", this.element.getAttribute("title") || ""),
                    this.element.setAttribute("title", ""))
                }, "_fixTitle"),
                V._enter = o(function(v, A) {
                    var O = this.constructor.DATA_KEY;
                    if (A = A || r.default(v.currentTarget).data(O),
                    A || (A = new this.constructor(v.currentTarget,this._getDelegateConfig()),
                    r.default(v.currentTarget).data(O, A)),
                    v && (A._activeTrigger[v.type === "focusin" ? ns : Wi] = !0),
                    r.default(A.getTipElement()).hasClass(Cn) || A._hoverState === wn) {
                        A._hoverState = wn;
                        return
                    }
                    if (clearTimeout(A._timeout),
                    A._hoverState = wn,
                    !A.config.delay || !A.config.delay.show) {
                        A.show();
                        return
                    }
                    A._timeout = setTimeout(function() {
                        A._hoverState === wn && A.show()
                    }, A.config.delay.show)
                }, "_enter"),
                V._leave = o(function(v, A) {
                    var O = this.constructor.DATA_KEY;
                    if (A = A || r.default(v.currentTarget).data(O),
                    A || (A = new this.constructor(v.currentTarget,this._getDelegateConfig()),
                    r.default(v.currentTarget).data(O, A)),
                    v && (A._activeTrigger[v.type === "focusout" ? ns : Wi] = !1),
                    !A._isWithActiveTrigger()) {
                        if (clearTimeout(A._timeout),
                        A._hoverState = Ai,
                        !A.config.delay || !A.config.delay.hide) {
                            A.hide();
                            return
                        }
                        A._timeout = setTimeout(function() {
                            A._hoverState === Ai && A.hide()
                        }, A.config.delay.hide)
                    }
                }, "_leave"),
                V._isWithActiveTrigger = o(function() {
                    for (var v in this._activeTrigger)
                        if (this._activeTrigger[v])
                            return !0;
                    return !1
                }, "_isWithActiveTrigger"),
                V._getConfig = o(function(v) {
                    var A = r.default(this.element).data();
                    return Object.keys(A).forEach(function(O) {
                        ei.indexOf(O) !== -1 && delete A[O]
                    }),
                    v = d({}, this.constructor.Default, A, typeof v == "object" && v ? v : {}),
                    typeof v.delay == "number" && (v.delay = {
                        show: v.delay,
                        hide: v.delay
                    }),
                    typeof v.title == "number" && (v.title = v.title.toString()),
                    typeof v.content == "number" && (v.content = v.content.toString()),
                    k.typeCheckConfig(Ce, v, this.constructor.DefaultType),
                    v.sanitize && (v.template = Is(v.template, v.whiteList, v.sanitizeFn)),
                    v
                }, "_getConfig"),
                V._getDelegateConfig = o(function() {
                    var v = {};
                    if (this.config)
                        for (var A in this.config)
                            this.constructor.Default[A] !== this.config[A] && (v[A] = this.config[A]);
                    return v
                }, "_getDelegateConfig"),
                V._cleanTipClass = o(function() {
                    var v = r.default(this.getTipElement())
                      , A = v.attr("class").match(Fs);
                    A !== null && A.length && v.removeClass(A.join(""))
                }, "_cleanTipClass"),
                V._handlePopperPlacementChange = o(function(v) {
                    this.tip = v.instance.popper,
                    this._cleanTipClass(),
                    this.addAttachmentClass(this._getAttachment(v.placement))
                }, "_handlePopperPlacementChange"),
                V._fixTransition = o(function() {
                    var v = this.getTipElement()
                      , A = this.config.animation;
                    v.getAttribute("x-placement") === null && (r.default(v).removeClass(We),
                    this.config.animation = !1,
                    this.hide(),
                    this.show(),
                    this.config.animation = A)
                }, "_fixTransition"),
                X._jQueryInterface = o(function(v) {
                    return this.each(function() {
                        var A = r.default(this)
                          , O = A.data(Ns)
                          , J = typeof v == "object" && v;
                        if (!(!O && /dispose|hide/.test(v)) && (O || (O = new X(this,J),
                        A.data(Ns, O)),
                        typeof v == "string")) {
                            if (typeof O[v] > "u")
                                throw new TypeError('No method named "' + v + '"');
                            O[v]()
                        }
                    })
                }, "_jQueryInterface"),
                u(X, null, [{
                    key: "VERSION",
                    get: o(function() {
                        return Ci
                    }, "get")
                }, {
                    key: "Default",
                    get: o(function() {
                        return Ol
                    }, "get")
                }, {
                    key: "NAME",
                    get: o(function() {
                        return Ce
                    }, "get")
                }, {
                    key: "DATA_KEY",
                    get: o(function() {
                        return Ns
                    }, "get")
                }, {
                    key: "Event",
                    get: o(function() {
                        return Vr
                    }, "get")
                }, {
                    key: "EVENT_KEY",
                    get: o(function() {
                        return ti
                    }, "get")
                }, {
                    key: "DefaultType",
                    get: o(function() {
                        return xn
                    }, "get")
                }]),
                X
            }
            )();
            r.default.fn[Ce] = ki._jQueryInterface,
            r.default.fn[Ce].Constructor = ki,
            r.default.fn[Ce].noConflict = function() {
                return r.default.fn[Ce] = kl,
                ki._jQueryInterface
            }
            ;
            var $i = "popover"
              , Dl = "4.6.0"
              , An = "bs.popover"
              , $e = "." + An
              , M = r.default.fn[$i]
              , B = "bs-popover"
              , K = new RegExp("(^|\\s)" + B + "\\S+","g")
              , Z = d({}, ki.Default, {
                placement: "right",
                trigger: "click",
                content: "",
                template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'
            })
              , nt = d({}, ki.DefaultType, {
                content: "(string|element|function)"
            })
              , ht = "fade"
              , pt = "show"
              , Et = ".popover-header"
              , gt = ".popover-body"
              , Ft = {
                HIDE: "hide" + $e,
                HIDDEN: "hidden" + $e,
                SHOW: "show" + $e,
                SHOWN: "shown" + $e,
                INSERTED: "inserted" + $e,
                CLICK: "click" + $e,
                FOCUSIN: "focusin" + $e,
                FOCUSOUT: "focusout" + $e,
                MOUSEENTER: "mouseenter" + $e,
                MOUSELEAVE: "mouseleave" + $e
            }
              , Ct = (function(X) {
                p(V, X);
                function V() {
                    return X.apply(this, arguments) || this
                }
                o(V, "Popover");
                var P = V.prototype;
                return P.isWithContent = o(function() {
                    return this.getTitle() || this._getContent()
                }, "isWithContent"),
                P.addAttachmentClass = o(function(A) {
                    r.default(this.getTipElement()).addClass(B + "-" + A)
                }, "addAttachmentClass"),
                P.getTipElement = o(function() {
                    return this.tip = this.tip || r.default(this.config.template)[0],
                    this.tip
                }, "getTipElement"),
                P.setContent = o(function() {
                    var A = r.default(this.getTipElement());
                    this.setElementContent(A.find(Et), this.getTitle());
                    var O = this._getContent();
                    typeof O == "function" && (O = O.call(this.element)),
                    this.setElementContent(A.find(gt), O),
                    A.removeClass(ht + " " + pt)
                }, "setContent"),
                P._getContent = o(function() {
                    return this.element.getAttribute("data-content") || this.config.content
                }, "_getContent"),
                P._cleanTipClass = o(function() {
                    var A = r.default(this.getTipElement())
                      , O = A.attr("class").match(K);
                    O !== null && O.length > 0 && A.removeClass(O.join(""))
                }, "_cleanTipClass"),
                V._jQueryInterface = o(function(A) {
                    return this.each(function() {
                        var O = r.default(this).data(An)
                          , J = typeof A == "object" ? A : null;
                        if (!(!O && /dispose|hide/.test(A)) && (O || (O = new V(this,J),
                        r.default(this).data(An, O)),
                        typeof A == "string")) {
                            if (typeof O[A] > "u")
                                throw new TypeError('No method named "' + A + '"');
                            O[A]()
                        }
                    })
                }, "_jQueryInterface"),
                u(V, null, [{
                    key: "VERSION",
                    get: o(function() {
                        return Dl
                    }, "get")
                }, {
                    key: "Default",
                    get: o(function() {
                        return Z
                    }, "get")
                }, {
                    key: "NAME",
                    get: o(function() {
                        return $i
                    }, "get")
                }, {
                    key: "DATA_KEY",
                    get: o(function() {
                        return An
                    }, "get")
                }, {
                    key: "Event",
                    get: o(function() {
                        return Ft
                    }, "get")
                }, {
                    key: "EVENT_KEY",
                    get: o(function() {
                        return $e
                    }, "get")
                }, {
                    key: "DefaultType",
                    get: o(function() {
                        return nt
                    }, "get")
                }]),
                V
            }
            )(ki);
            r.default.fn[$i] = Ct._jQueryInterface,
            r.default.fn[$i].Constructor = Ct,
            r.default.fn[$i].noConflict = function() {
                return r.default.fn[$i] = M,
                Ct._jQueryInterface
            }
            ;
            var At = "scrollspy"
              , Vt = "4.6.0"
              , xt = "bs.scrollspy"
              , Gt = "." + xt
              , De = ".data-api"
              , Ee = r.default.fn[At]
              , Ie = {
                offset: 10,
                method: "auto",
                target: ""
            }
              , mi = {
                offset: "number",
                method: "string",
                target: "(string|element)"
            }
              , kn = "activate" + Gt
              , Ae = "scroll" + Gt
              , vm = "load" + Gt + De
              , bm = "dropdown-item"
              , ss = "active"
              , ym = '[data-spy="scroll"]'
              , Pd = ".nav, .list-group"
              , Pl = ".nav-link"
              , _m = ".nav-item"
              , Rd = ".list-group-item"
              , Em = ".dropdown"
              , Sm = ".dropdown-item"
              , Tm = ".dropdown-toggle"
              , xm = "offset"
              , Id = "position"
              , Br = (function() {
                function X(P, v) {
                    var A = this;
                    this._element = P,
                    this._scrollElement = P.tagName === "BODY" ? window : P,
                    this._config = this._getConfig(v),
                    this._selector = this._config.target + " " + Pl + "," + (this._config.target + " " + Rd + ",") + (this._config.target + " " + Sm),
                    this._offsets = [],
                    this._targets = [],
                    this._activeTarget = null,
                    this._scrollHeight = 0,
                    r.default(this._scrollElement).on(Ae, function(O) {
                        return A._process(O)
                    }),
                    this.refresh(),
                    this._process()
                }
                o(X, "ScrollSpy");
                var V = X.prototype;
                return V.refresh = o(function() {
                    var v = this
                      , A = this._scrollElement === this._scrollElement.window ? xm : Id
                      , O = this._config.method === "auto" ? A : this._config.method
                      , J = O === Id ? this._getScrollTop() : 0;
                    this._offsets = [],
                    this._targets = [],
                    this._scrollHeight = this._getScrollHeight();
                    var et = [].slice.call(document.querySelectorAll(this._selector));
                    et.map(function(ct) {
                        var Ot, Yt = k.getSelectorFromElement(ct);
                        if (Yt && (Ot = document.querySelector(Yt)),
                        Ot) {
                            var Qt = Ot.getBoundingClientRect();
                            if (Qt.width || Qt.height)
                                return [r.default(Ot)[O]().top + J, Yt]
                        }
                        return null
                    }).filter(function(ct) {
                        return ct
                    }).sort(function(ct, Ot) {
                        return ct[0] - Ot[0]
                    }).forEach(function(ct) {
                        v._offsets.push(ct[0]),
                        v._targets.push(ct[1])
                    })
                }, "refresh"),
                V.dispose = o(function() {
                    r.default.removeData(this._element, xt),
                    r.default(this._scrollElement).off(Gt),
                    this._element = null,
                    this._scrollElement = null,
                    this._config = null,
                    this._selector = null,
                    this._offsets = null,
                    this._targets = null,
                    this._activeTarget = null,
                    this._scrollHeight = null
                }, "dispose"),
                V._getConfig = o(function(v) {
                    if (v = d({}, Ie, typeof v == "object" && v ? v : {}),
                    typeof v.target != "string" && k.isElement(v.target)) {
                        var A = r.default(v.target).attr("id");
                        A || (A = k.getUID(At),
                        r.default(v.target).attr("id", A)),
                        v.target = "#" + A
                    }
                    return k.typeCheckConfig(At, v, mi),
                    v
                }, "_getConfig"),
                V._getScrollTop = o(function() {
                    return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop
                }, "_getScrollTop"),
                V._getScrollHeight = o(function() {
                    return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight)
                }, "_getScrollHeight"),
                V._getOffsetHeight = o(function() {
                    return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height
                }, "_getOffsetHeight"),
                V._process = o(function() {
                    var v = this._getScrollTop() + this._config.offset
                      , A = this._getScrollHeight()
                      , O = this._config.offset + A - this._getOffsetHeight();
                    if (this._scrollHeight !== A && this.refresh(),
                    v >= O) {
                        var J = this._targets[this._targets.length - 1];
                        this._activeTarget !== J && this._activate(J);
                        return
                    }
                    if (this._activeTarget && v < this._offsets[0] && this._offsets[0] > 0) {
                        this._activeTarget = null,
                        this._clear();
                        return
                    }
                    for (var et = this._offsets.length; et--; ) {
                        var ct = this._activeTarget !== this._targets[et] && v >= this._offsets[et] && (typeof this._offsets[et + 1] > "u" || v < this._offsets[et + 1]);
                        ct && this._activate(this._targets[et])
                    }
                }, "_process"),
                V._activate = o(function(v) {
                    this._activeTarget = v,
                    this._clear();
                    var A = this._selector.split(",").map(function(J) {
                        return J + '[data-target="' + v + '"],' + J + '[href="' + v + '"]'
                    })
                      , O = r.default([].slice.call(document.querySelectorAll(A.join(","))));
                    O.hasClass(bm) ? (O.closest(Em).find(Tm).addClass(ss),
                    O.addClass(ss)) : (O.addClass(ss),
                    O.parents(Pd).prev(Pl + ", " + Rd).addClass(ss),
                    O.parents(Pd).prev(_m).children(Pl).addClass(ss)),
                    r.default(this._scrollElement).trigger(kn, {
                        relatedTarget: v
                    })
                }, "_activate"),
                V._clear = o(function() {
                    [].slice.call(document.querySelectorAll(this._selector)).filter(function(v) {
                        return v.classList.contains(ss)
                    }).forEach(function(v) {
                        return v.classList.remove(ss)
                    })
                }, "_clear"),
                X._jQueryInterface = o(function(v) {
                    return this.each(function() {
                        var A = r.default(this).data(xt)
                          , O = typeof v == "object" && v;
                        if (A || (A = new X(this,O),
                        r.default(this).data(xt, A)),
                        typeof v == "string") {
                            if (typeof A[v] > "u")
                                throw new TypeError('No method named "' + v + '"');
                            A[v]()
                        }
                    })
                }, "_jQueryInterface"),
                u(X, null, [{
                    key: "VERSION",
                    get: o(function() {
                        return Vt
                    }, "get")
                }, {
                    key: "Default",
                    get: o(function() {
                        return Ie
                    }, "get")
                }]),
                X
            }
            )();
            r.default(window).on(vm, function() {
                for (var X = [].slice.call(document.querySelectorAll(ym)), V = X.length, P = V; P--; ) {
                    var v = r.default(X[P]);
                    Br._jQueryInterface.call(v, v.data())
                }
            }),
            r.default.fn[At] = Br._jQueryInterface,
            r.default.fn[At].Constructor = Br,
            r.default.fn[At].noConflict = function() {
                return r.default.fn[At] = Ee,
                Br._jQueryInterface
            }
            ;
            var Hr = "tab"
              , wm = "4.6.0"
              , Qo = "bs.tab"
              , jr = "." + Qo
              , Cm = ".data-api"
              , Am = r.default.fn[Hr]
              , km = "hide" + jr
              , Mm = "hidden" + jr
              , Om = "show" + jr
              , Lm = "shown" + jr
              , Dm = "click" + jr + Cm
              , Pm = "dropdown-menu"
              , Wr = "active"
              , Rm = "disabled"
              , Nd = "fade"
              , Fd = "show"
              , Im = ".dropdown"
              , Nm = ".nav, .list-group"
              , Vd = ".active"
              , Bd = "> li > .active"
              , Fm = '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]'
              , Vm = ".dropdown-toggle"
              , Bm = "> .dropdown-menu .active"
              , $r = (function() {
                function X(P) {
                    this._element = P
                }
                o(X, "Tab");
                var V = X.prototype;
                return V.show = o(function() {
                    var v = this;
                    if (!(this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && r.default(this._element).hasClass(Wr) || r.default(this._element).hasClass(Rm))) {
                        var A, O, J = r.default(this._element).closest(Nm)[0], et = k.getSelectorFromElement(this._element);
                        if (J) {
                            var ct = J.nodeName === "UL" || J.nodeName === "OL" ? Bd : Vd;
                            O = r.default.makeArray(r.default(J).find(ct)),
                            O = O[O.length - 1]
                        }
                        var Ot = r.default.Event(km, {
                            relatedTarget: this._element
                        })
                          , Yt = r.default.Event(Om, {
                            relatedTarget: O
                        });
                        if (O && r.default(O).trigger(Ot),
                        r.default(this._element).trigger(Yt),
                        !(Yt.isDefaultPrevented() || Ot.isDefaultPrevented())) {
                            et && (A = document.querySelector(et)),
                            this._activate(this._element, J);
                            var Qt = o(function() {
                                var qi = r.default.Event(Mm, {
                                    relatedTarget: v._element
                                })
                                  , Mi = r.default.Event(Lm, {
                                    relatedTarget: O
                                });
                                r.default(O).trigger(qi),
                                r.default(v._element).trigger(Mi)
                            }, "complete");
                            A ? this._activate(A, A.parentNode, Qt) : Qt()
                        }
                    }
                }, "show"),
                V.dispose = o(function() {
                    r.default.removeData(this._element, Qo),
                    this._element = null
                }, "dispose"),
                V._activate = o(function(v, A, O) {
                    var J = this
                      , et = A && (A.nodeName === "UL" || A.nodeName === "OL") ? r.default(A).find(Bd) : r.default(A).children(Vd)
                      , ct = et[0]
                      , Ot = O && ct && r.default(ct).hasClass(Nd)
                      , Yt = o(function() {
                        return J._transitionComplete(v, ct, O)
                    }, "complete");
                    if (ct && Ot) {
                        var Qt = k.getTransitionDurationFromElement(ct);
                        r.default(ct).removeClass(Fd).one(k.TRANSITION_END, Yt).emulateTransitionEnd(Qt)
                    } else
                        Yt()
                }, "_activate"),
                V._transitionComplete = o(function(v, A, O) {
                    if (A) {
                        r.default(A).removeClass(Wr);
                        var J = r.default(A.parentNode).find(Bm)[0];
                        J && r.default(J).removeClass(Wr),
                        A.getAttribute("role") === "tab" && A.setAttribute("aria-selected", !1)
                    }
                    if (r.default(v).addClass(Wr),
                    v.getAttribute("role") === "tab" && v.setAttribute("aria-selected", !0),
                    k.reflow(v),
                    v.classList.contains(Nd) && v.classList.add(Fd),
                    v.parentNode && r.default(v.parentNode).hasClass(Pm)) {
                        var et = r.default(v).closest(Im)[0];
                        if (et) {
                            var ct = [].slice.call(et.querySelectorAll(Vm));
                            r.default(ct).addClass(Wr)
                        }
                        v.setAttribute("aria-expanded", !0)
                    }
                    O && O()
                }, "_transitionComplete"),
                X._jQueryInterface = o(function(v) {
                    return this.each(function() {
                        var A = r.default(this)
                          , O = A.data(Qo);
                        if (O || (O = new X(this),
                        A.data(Qo, O)),
                        typeof v == "string") {
                            if (typeof O[v] > "u")
                                throw new TypeError('No method named "' + v + '"');
                            O[v]()
                        }
                    })
                }, "_jQueryInterface"),
                u(X, null, [{
                    key: "VERSION",
                    get: o(function() {
                        return wm
                    }, "get")
                }]),
                X
            }
            )();
            r.default(document).on(Dm, Fm, function(X) {
                X.preventDefault(),
                $r._jQueryInterface.call(r.default(this), "show")
            }),
            r.default.fn[Hr] = $r._jQueryInterface,
            r.default.fn[Hr].Constructor = $r,
            r.default.fn[Hr].noConflict = function() {
                return r.default.fn[Hr] = Am,
                $r._jQueryInterface
            }
            ;
            var Hs = "toast"
              , Hm = "4.6.0"
              , Jo = "bs.toast"
              , qr = "." + Jo
              , jm = r.default.fn[Hs]
              , Hd = "click.dismiss" + qr
              , Wm = "hide" + qr
              , $m = "hidden" + qr
              , qm = "show" + qr
              , zm = "shown" + qr
              , Um = "fade"
              , jd = "hide"
              , zr = "show"
              , Wd = "showing"
              , Km = {
                animation: "boolean",
                autohide: "boolean",
                delay: "number"
            }
              , $d = {
                animation: !0,
                autohide: !0,
                delay: 500
            }
              , Ym = '[data-dismiss="toast"]'
              , Zo = (function() {
                function X(P, v) {
                    this._element = P,
                    this._config = this._getConfig(v),
                    this._timeout = null,
                    this._setListeners()
                }
                o(X, "Toast");
                var V = X.prototype;
                return V.show = o(function() {
                    var v = this
                      , A = r.default.Event(qm);
                    if (r.default(this._element).trigger(A),
                    !A.isDefaultPrevented()) {
                        this._clearTimeout(),
                        this._config.animation && this._element.classList.add(Um);
                        var O = o(function() {
                            v._element.classList.remove(Wd),
                            v._element.classList.add(zr),
                            r.default(v._element).trigger(zm),
                            v._config.autohide && (v._timeout = setTimeout(function() {
                                v.hide()
                            }, v._config.delay))
                        }, "complete");
                        if (this._element.classList.remove(jd),
                        k.reflow(this._element),
                        this._element.classList.add(Wd),
                        this._config.animation) {
                            var J = k.getTransitionDurationFromElement(this._element);
                            r.default(this._element).one(k.TRANSITION_END, O).emulateTransitionEnd(J)
                        } else
                            O()
                    }
                }, "show"),
                V.hide = o(function() {
                    if (this._element.classList.contains(zr)) {
                        var v = r.default.Event(Wm);
                        r.default(this._element).trigger(v),
                        !v.isDefaultPrevented() && this._close()
                    }
                }, "hide"),
                V.dispose = o(function() {
                    this._clearTimeout(),
                    this._element.classList.contains(zr) && this._element.classList.remove(zr),
                    r.default(this._element).off(Hd),
                    r.default.removeData(this._element, Jo),
                    this._element = null,
                    this._config = null
                }, "dispose"),
                V._getConfig = o(function(v) {
                    return v = d({}, $d, r.default(this._element).data(), typeof v == "object" && v ? v : {}),
                    k.typeCheckConfig(Hs, v, this.constructor.DefaultType),
                    v
                }, "_getConfig"),
                V._setListeners = o(function() {
                    var v = this;
                    r.default(this._element).on(Hd, Ym, function() {
                        return v.hide()
                    })
                }, "_setListeners"),
                V._close = o(function() {
                    var v = this
                      , A = o(function() {
                        v._element.classList.add(jd),
                        r.default(v._element).trigger($m)
                    }, "complete");
                    if (this._element.classList.remove(zr),
                    this._config.animation) {
                        var O = k.getTransitionDurationFromElement(this._element);
                        r.default(this._element).one(k.TRANSITION_END, A).emulateTransitionEnd(O)
                    } else
                        A()
                }, "_close"),
                V._clearTimeout = o(function() {
                    clearTimeout(this._timeout),
                    this._timeout = null
                }, "_clearTimeout"),
                X._jQueryInterface = o(function(v) {
                    return this.each(function() {
                        var A = r.default(this)
                          , O = A.data(Jo)
                          , J = typeof v == "object" && v;
                        if (O || (O = new X(this,J),
                        A.data(Jo, O)),
                        typeof v == "string") {
                            if (typeof O[v] > "u")
                                throw new TypeError('No method named "' + v + '"');
                            O[v](this)
                        }
                    })
                }, "_jQueryInterface"),
                u(X, null, [{
                    key: "VERSION",
                    get: o(function() {
                        return Hm
                    }, "get")
                }, {
                    key: "DefaultType",
                    get: o(function() {
                        return Km
                    }, "get")
                }, {
                    key: "Default",
                    get: o(function() {
                        return $d
                    }, "get")
                }]),
                X
            }
            )();
            r.default.fn[Hs] = Zo._jQueryInterface,
            r.default.fn[Hs].Constructor = Zo,
            r.default.fn[Hs].noConflict = function() {
                return r.default.fn[Hs] = jm,
                Zo._jQueryInterface
            }
            ,
            n.Alert = wt,
            n.Button = Ei,
            n.Carousel = se,
            n.Collapse = Ni,
            n.Dropdown = Bi,
            n.Modal = un,
            n.Popover = Ct,
            n.Scrollspy = Br,
            n.Tab = $r,
            n.Toast = Zo,
            n.Tooltip = ki,
            n.Util = k,
            Object.defineProperty(n, "__esModule", {
                value: !0
            })
        }
        ))
    }
    );
    var Rn, ba = ii( () => {
        Rn = {
            logger: typeof console < "u" ? console : void 0,
            WebSocket: typeof WebSocket < "u" ? WebSocket : void 0
        }
    }
    );
    var Zt, Qs = ii( () => {
        ba();
        Zt = {
            log(...n) {
                this.enabled && (n.push(Date.now()),
                Rn.logger.log("[ActionCable]", ...n))
            }
        }
    }
    );
    var eo, ya, io, _a, Tc = ii( () => {
        Qs();
        eo = o( () => new Date().getTime(), "now"),
        ya = o(n => (eo() - n) / 1e3, "secondsSince"),
        io = class {
            static{o(this, "ConnectionMonitor")
            }constructor(t) {
                this.visibilityDidChange = this.visibilityDidChange.bind(this),
                this.connection = t,
                this.reconnectAttempts = 0
            }
            start() {
                this.isRunning() || (this.startedAt = eo(),
                delete this.stoppedAt,
                this.startPolling(),
                addEventListener("visibilitychange", this.visibilityDidChange),
                Zt.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`))
            }
            stop() {
                this.isRunning() && (this.stoppedAt = eo(),
                this.stopPolling(),
                removeEventListener("visibilitychange", this.visibilityDidChange),
                Zt.log("ConnectionMonitor stopped"))
            }
            isRunning() {
                return this.startedAt && !this.stoppedAt
            }
            recordMessage() {
                this.pingedAt = eo()
            }
            recordConnect() {
                this.reconnectAttempts = 0,
                delete this.disconnectedAt,
                Zt.log("ConnectionMonitor recorded connect")
            }
            recordDisconnect() {
                this.disconnectedAt = eo(),
                Zt.log("ConnectionMonitor recorded disconnect")
            }
            startPolling() {
                this.stopPolling(),
                this.poll()
            }
            stopPolling() {
                clearTimeout(this.pollTimeout)
            }
            poll() {
                this.pollTimeout = setTimeout( () => {
                    this.reconnectIfStale(),
                    this.poll()
                }
                , this.getPollInterval())
            }
            getPollInterval() {
                let {staleThreshold: t, reconnectionBackoffRate: e} = this.constructor
                  , s = Math.pow(1 + e, Math.min(this.reconnectAttempts, 10))
                  , a = (this.reconnectAttempts === 0 ? 1 : e) * Math.random();
                return t * 1e3 * s * (1 + a)
            }
            reconnectIfStale() {
                this.connectionIsStale() && (Zt.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${ya(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`),
                this.reconnectAttempts++,
                this.disconnectedRecently() ? Zt.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${ya(this.disconnectedAt)} s`) : (Zt.log("ConnectionMonitor reopening"),
                this.connection.reopen()))
            }
            get refreshedAt() {
                return this.pingedAt ? this.pingedAt : this.startedAt
            }
            connectionIsStale() {
                return ya(this.refreshedAt) > this.constructor.staleThreshold
            }
            disconnectedRecently() {
                return this.disconnectedAt && ya(this.disconnectedAt) < this.constructor.staleThreshold
            }
            visibilityDidChange() {
                document.visibilityState === "visible" && setTimeout( () => {
                    (this.connectionIsStale() || !this.connection.isOpen()) && (Zt.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`),
                    this.connection.reopen())
                }
                , 200)
            }
        }
        ;
        io.staleThreshold = 6;
        io.reconnectionBackoffRate = .15;
        _a = io
    }
    );
    var no, xc = ii( () => {
        no = {
            message_types: {
                welcome: "welcome",
                disconnect: "disconnect",
                ping: "ping",
                confirmation: "confirm_subscription",
                rejection: "reject_subscription"
            },
            disconnect_reasons: {
                unauthorized: "unauthorized",
                invalid_request: "invalid_request",
                server_restart: "server_restart",
                remote: "remote"
            },
            default_mount_path: "/cable",
            protocols: ["actioncable-v1-json", "actioncable-unsupported"]
        }
    }
    );
    var so, wc, hb, Lf, ro, Ea, Cc = ii( () => {
        ba();
        Tc();
        xc();
        Qs();
        ({message_types: so, protocols: wc} = no),
        hb = wc.slice(0, wc.length - 1),
        Lf = [].indexOf,
        ro = class {
            static{o(this, "Connection")
            }constructor(t) {
                this.open = this.open.bind(this),
                this.consumer = t,
                this.subscriptions = this.consumer.subscriptions,
                this.monitor = new _a(this),
                this.disconnected = !0
            }
            send(t) {
                return this.isOpen() ? (this.webSocket.send(JSON.stringify(t)),
                !0) : !1
            }
            open() {
                if (this.isActive())
                    return Zt.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`),
                    !1;
                {
                    let t = [...wc, ...this.consumer.subprotocols || []];
                    return Zt.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${t}`),
                    this.webSocket && this.uninstallEventHandlers(),
                    this.webSocket = new Rn.WebSocket(this.consumer.url,t),
                    this.installEventHandlers(),
                    this.monitor.start(),
                    !0
                }
            }
            close({allowReconnect: t}={
                allowReconnect: !0
            }) {
                if (t || this.monitor.stop(),
                this.isOpen())
                    return this.webSocket.close()
            }
            reopen() {
                if (Zt.log(`Reopening WebSocket, current state is ${this.getState()}`),
                this.isActive())
                    try {
                        return this.close()
                    } catch (t) {
                        Zt.log("Failed to reopen WebSocket", t)
                    } finally {
                        Zt.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`),
                        setTimeout(this.open, this.constructor.reopenDelay)
                    }
                else
                    return this.open()
            }
            getProtocol() {
                if (this.webSocket)
                    return this.webSocket.protocol
            }
            isOpen() {
                return this.isState("open")
            }
            isActive() {
                return this.isState("open", "connecting")
            }
            triedToReconnect() {
                return this.monitor.reconnectAttempts > 0
            }
            isProtocolSupported() {
                return Lf.call(hb, this.getProtocol()) >= 0
            }
            isState(...t) {
                return Lf.call(t, this.getState()) >= 0
            }
            getState() {
                if (this.webSocket) {
                    for (let t in Rn.WebSocket)
                        if (Rn.WebSocket[t] === this.webSocket.readyState)
                            return t.toLowerCase()
                }
                return null
            }
            installEventHandlers() {
                for (let t in this.events) {
                    let e = this.events[t].bind(this);
                    this.webSocket[`on${t}`] = e
                }
            }
            uninstallEventHandlers() {
                for (let t in this.events)
                    this.webSocket[`on${t}`] = function() {}
            }
        }
        ;
        ro.reopenDelay = 500;
        ro.prototype.events = {
            message(n) {
                if (!this.isProtocolSupported())
                    return;
                let {identifier: t, message: e, reason: s, reconnect: r, type: a} = JSON.parse(n.data);
                switch (this.monitor.recordMessage(),
                a) {
                case so.welcome:
                    return this.triedToReconnect() && (this.reconnectAttempted = !0),
                    this.monitor.recordConnect(),
                    this.subscriptions.reload();
                case so.disconnect:
                    return Zt.log(`Disconnecting. Reason: ${s}`),
                    this.close({
                        allowReconnect: r
                    });
                case so.ping:
                    return null;
                case so.confirmation:
                    return this.subscriptions.confirmSubscription(t),
                    this.reconnectAttempted ? (this.reconnectAttempted = !1,
                    this.subscriptions.notify(t, "connected", {
                        reconnected: !0
                    })) : this.subscriptions.notify(t, "connected", {
                        reconnected: !1
                    });
                case so.rejection:
                    return this.subscriptions.reject(t);
                default:
                    return this.subscriptions.notify(t, "received", e)
                }
            },
            open() {
                if (Zt.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`),
                this.disconnected = !1,
                !this.isProtocolSupported())
                    return Zt.log("Protocol is unsupported. Stopping monitor and disconnecting."),
                    this.close({
                        allowReconnect: !1
                    })
            },
            close(n) {
                if (Zt.log("WebSocket onclose event"),
                !this.disconnected)
                    return this.disconnected = !0,
                    this.monitor.recordDisconnect(),
                    this.subscriptions.notifyAll("disconnected", {
                        willAttemptReconnect: this.monitor.isRunning()
                    })
            },
            error() {
                Zt.log("WebSocket onerror event")
            }
        };
        Ea = ro
    }
    );
    var db, cs, Ac = ii( () => {
        db = o(function(n, t) {
            if (t != null)
                for (let e in t) {
                    let s = t[e];
                    n[e] = s
                }
            return n
        }, "extend"),
        cs = class {
            static{o(this, "Subscription")
            }constructor(t, e={}, s) {
                this.consumer = t,
                this.identifier = JSON.stringify(e),
                db(this, s)
            }
            perform(t, e={}) {
                return e.action = t,
                this.send(e)
            }
            send(t) {
                return this.consumer.send({
                    command: "message",
                    identifier: this.identifier,
                    data: JSON.stringify(t)
                })
            }
            unsubscribe() {
                return this.consumer.subscriptions.remove(this)
            }
        }
    }
    );
    var kc, Sa, Mc = ii( () => {
        Qs();
        kc = class {
            static{o(this, "SubscriptionGuarantor")
            }constructor(t) {
                this.subscriptions = t,
                this.pendingSubscriptions = []
            }
            guarantee(t) {
                this.pendingSubscriptions.indexOf(t) == -1 ? (Zt.log(`SubscriptionGuarantor guaranteeing ${t.identifier}`),
                this.pendingSubscriptions.push(t)) : Zt.log(`SubscriptionGuarantor already guaranteeing ${t.identifier}`),
                this.startGuaranteeing()
            }
            forget(t) {
                Zt.log(`SubscriptionGuarantor forgetting ${t.identifier}`),
                this.pendingSubscriptions = this.pendingSubscriptions.filter(e => e !== t)
            }
            startGuaranteeing() {
                this.stopGuaranteeing(),
                this.retrySubscribing()
            }
            stopGuaranteeing() {
                clearTimeout(this.retryTimeout)
            }
            retrySubscribing() {
                this.retryTimeout = setTimeout( () => {
                    this.subscriptions && typeof this.subscriptions.subscribe == "function" && this.pendingSubscriptions.map(t => {
                        Zt.log(`SubscriptionGuarantor resubscribing ${t.identifier}`),
                        this.subscriptions.subscribe(t)
                    }
                    )
                }
                , 500)
            }
        }
        ,
        Sa = kc
    }
    );
    var us, Oc = ii( () => {
        Ac();
        Mc();
        Qs();
        us = class {
            static{o(this, "Subscriptions")
            }constructor(t) {
                this.consumer = t,
                this.guarantor = new Sa(this),
                this.subscriptions = []
            }
            create(t, e) {
                let s = t
                  , r = typeof s == "object" ? s : {
                    channel: s
                }
                  , a = new cs(this.consumer,r,e);
                return this.add(a)
            }
            add(t) {
                return this.subscriptions.push(t),
                this.consumer.ensureActiveConnection(),
                this.notify(t, "initialized"),
                this.subscribe(t),
                t
            }
            remove(t) {
                return this.forget(t),
                this.findAll(t.identifier).length || this.sendCommand(t, "unsubscribe"),
                t
            }
            reject(t) {
                return this.findAll(t).map(e => (this.forget(e),
                this.notify(e, "rejected"),
                e))
            }
            forget(t) {
                return this.guarantor.forget(t),
                this.subscriptions = this.subscriptions.filter(e => e !== t),
                t
            }
            findAll(t) {
                return this.subscriptions.filter(e => e.identifier === t)
            }
            reload() {
                return this.subscriptions.map(t => this.subscribe(t))
            }
            notifyAll(t, ...e) {
                return this.subscriptions.map(s => this.notify(s, t, ...e))
            }
            notify(t, e, ...s) {
                let r;
                return typeof t == "string" ? r = this.findAll(t) : r = [t],
                r.map(a => typeof a[e] == "function" ? a[e](...s) : void 0)
            }
            subscribe(t) {
                this.sendCommand(t, "subscribe") && this.guarantor.guarantee(t)
            }
            confirmSubscription(t) {
                Zt.log(`Subscription confirmed ${t}`),
                this.findAll(t).map(e => this.guarantor.forget(e))
            }
            sendCommand(t, e) {
                let {identifier: s} = t;
                return this.consumer.send({
                    command: e,
                    identifier: s
                })
            }
        }
    }
    );
    function Lc(n) {
        if (typeof n == "function" && (n = n()),
        n && !/^wss?:/i.test(n)) {
            let t = document.createElement("a");
            return t.href = n,
            t.href = t.href,
            t.protocol = t.protocol.replace("http", "ws"),
            t.href
        } else
            return n
    }
    var Js, Df = ii( () => {
        Cc();
        Oc();
        Js = class {
            static{o(this, "Consumer")
            }constructor(t) {
                this._url = t,
                this.subscriptions = new us(this),
                this.connection = new Ea(this),
                this.subprotocols = []
            }
            get url() {
                return Lc(this._url)
            }
            send(t) {
                return this.connection.send(t)
            }
            connect() {
                return this.connection.open()
            }
            disconnect() {
                return this.connection.close({
                    allowReconnect: !1
                })
            }
            ensureActiveConnection() {
                if (!this.connection.isActive())
                    return this.connection.open()
            }
            addSubProtocol(t) {
                this.subprotocols = [...this.subprotocols, t]
            }
        }
        ;
        o(Lc, "createWebSocketURL")
    }
    );
    var Rf = {};
    Rt(Rf, {
        Connection: () => Ea,
        ConnectionMonitor: () => _a,
        Consumer: () => Js,
        INTERNAL: () => no,
        Subscription: () => cs,
        SubscriptionGuarantor: () => Sa,
        Subscriptions: () => us,
        adapters: () => Rn,
        createConsumer: () => fb,
        createWebSocketURL: () => Lc,
        getConfig: () => Pf,
        logger: () => Zt
    });
    function fb(n=Pf("url") || no.default_mount_path) {
        return new Js(n)
    }
    function Pf(n) {
        let t = document.head.querySelector(`meta[name='action-cable-${n}']`);
        if (t)
            return t.getAttribute("content")
    }
    var If = ii( () => {
        Cc();
        Tc();
        Df();
        xc();
        Ac();
        Oc();
        Mc();
        ba();
        Qs();
        o(fb, "createConsumer");
        o(Pf, "getConfig")
    }
    );
    var CT = {};
    var um, hm = ii( () => {
        um = Yr(Ws());
        document.addEventListener("turbo:load", function() {
            navigator.cookieEnabled || (0,
            um.default)(".js-cookie-notice").show()
        })
    }
    );
    var AT = {};
    var Tr, dm = ii( () => {
        Tr = Yr(Ws());
        document.addEventListener("turbo:load", function() {
            (0,
            Tr.default)(".js-modal-trigger").on("click", function(n) {
                n.preventDefault();
                let t = (0,
                Tr.default)(this)
                  , e = t.data("title")
                  , s = t.data("body")
                  , r = t.data("picture")
                  , a = t.data("sdgpicture")
                  , l = t.data("picture-alt-text")
                  , u = t.data("sdgpicture-alt-text");
                (0,
                Tr.default)("#modal").on("show.bs.modal", function() {
                    let d = (0,
                    Tr.default)(this);
                    d.find(".modal-picture").attr("src", ""),
                    d.find(".modal-sdg-picture").attr("src", ""),
                    d.find(".modal-body").html(s),
                    d.find(".modal-title").html(e),
                    d.find(".modal-picture").attr("src", r),
                    d.find(".modal-picture").attr("alt", l),
                    d.find(".modal-sdg-picture").attr("src", a),
                    d.find(".modal-sdg-picture").attr("alt", u)
                }),
                (0,
                Tr.default)("#modal").modal("toggle")
            })
        })
    }
    );
    var fm = Kr( () => {
        document.addEventListener("turbo:load", function() {
            $("#close_menu").on("click", function() {
                $("#zettelBox .collapse").collapse("hide")
            }),
            $("#zettelBox").on("show.bs.collapse", function() {
                $(".mainline").addClass("mobile-full-height"),
                $("#zettelNav").addClass("open")
            }),
            $("#zettelBox").on("hide.bs.collapse", function() {
                $(".mainline").removeClass("mobile-full-height"),
                $("#zettelNav").removeClass("open")
            })
        })
    }
    );
    var kT = {};
    var pm, gm = ii( () => {
        pm = Yr(Ws());
        document.addEventListener("turbo:load", function() {
            function n(s) {
                return s.hostname.split(".")[0]
            }
            o(n, "getLinkSubdomain");
            function t() {
                this.jar = {};
                let s = document.cookie.split("; ");
                for (i = s.length - 1; i >= 0; i--) {
                    let r = s[i].split("=");
                    this.jar[r[0]] = r[1]
                }
            }
            o(t, "CookieReader"),
            t.prototype.get = function(s) {
                return this.jar[s]
            }
            ;
            let e = (0,
            pm.default)(".cookie-cart-counter");
            if (e.length) {
                let s = n(e.find("a")[0])
                  , a = new t().get(s + "_line_item_count");
                typeof a < "u" && a > 0 && e.find("span").removeClass("hide").html(a)
            }
        })
    }
    );
    var mm = Kr( () => {
        document.addEventListener("turbo:load", function() {
            $('[data-toggle="tooltip"]').tooltip()
        })
    }
    );
    var Kd = Yr(Ws());
    window.$ = window.jQuery = Kd.default;
    var vC = Yr(Gd());
    var Sc = {};
    Rt(Sc, {
        FetchEnctype: () => On,
        FetchMethod: () => ni,
        FetchRequest: () => Dn,
        FetchResponse: () => Ks,
        FrameElement: () => bi,
        FrameLoadingStyle: () => os,
        FrameRenderer: () => Xs,
        PageRenderer: () => Gs,
        PageSnapshot: () => vi,
        StreamActions: () => Ec,
        StreamElement: () => pa,
        StreamSourceElement: () => ga,
        cache: () => Sf,
        clearCache: () => Af,
        config: () => ve,
        connectStreamSource: () => Zr,
        disconnectStreamSource: () => to,
        fetch: () => bc,
        fetchEnctypeFromString: () => vf,
        fetchMethodFromString: () => ma,
        isSafe: () => va,
        navigator: () => Tf,
        registerAdapter: () => xf,
        renderStreamMessage: () => Cf,
        session: () => de,
        setConfirmMethod: () => Mf,
        setFormMode: () => Of,
        setProgressBarDelay: () => kf,
        start: () => _c,
        visit: () => wf
    });
    (function(n) {
        if (typeof n.requestSubmit == "function")
            return;
        n.requestSubmit = function(s) {
            s ? (t(s, this),
            s.click()) : (s = document.createElement("input"),
            s.type = "submit",
            s.hidden = !0,
            this.appendChild(s),
            s.click(),
            this.removeChild(s))
        }
        ;
        function t(s, r) {
            s instanceof HTMLElement || e(TypeError, "parameter 1 is not of type 'HTMLElement'"),
            s.type == "submit" || e(TypeError, "The specified element is not a submit button"),
            s.form == r || e(DOMException, "The specified element is not owned by this form element", "NotFoundError")
        }
        o(t, "validateSubmitter");
        function e(s, r, a) {
            throw new s("Failed to execute 'requestSubmit' on 'HTMLFormElement': " + r + ".",a)
        }
        o(e, "raise")
    }
    )(HTMLFormElement.prototype);
    var rf = new WeakMap;
    function ev(n) {
        let t = n instanceof Element ? n : n instanceof Node ? n.parentElement : null
          , e = t ? t.closest("input, button") : null;
        return e?.type == "submit" ? e : null
    }
    o(ev, "findSubmitterFromClickTarget");
    function iv(n) {
        let t = ev(n.target);
        t && t.form && rf.set(t.form, t)
    }
    o(iv, "clickCaptured");
    (function() {
        if ("submitter"in Event.prototype)
            return;
        let n = window.Event.prototype;
        if ("SubmitEvent"in window) {
            let t = window.SubmitEvent.prototype;
            if (/Apple Computer/.test(navigator.vendor) && !("submitter"in t))
                n = t;
            else
                return
        }
        addEventListener("click", iv, !0),
        Object.defineProperty(n, "submitter", {
            get() {
                if (this.type == "submit" && this.target instanceof HTMLFormElement)
                    return rf.get(this.target)
            }
        })
    }
    )();
    var os = {
        eager: "eager",
        lazy: "lazy"
    }
      , bi = class n extends HTMLElement {
        static{o(this, "FrameElement")
        }static delegateConstructor = void 0;
        loaded = Promise.resolve();
        static get observedAttributes() {
            return ["disabled", "loading", "src"]
        }
        constructor() {
            super(),
            this.delegate = new n.delegateConstructor(this)
        }
        connectedCallback() {
            this.delegate.connect()
        }
        disconnectedCallback() {
            this.delegate.disconnect()
        }
        reload() {
            return this.delegate.sourceURLReloaded()
        }
        attributeChangedCallback(t) {
            t == "loading" ? this.delegate.loadingStyleChanged() : t == "src" ? this.delegate.sourceURLChanged() : t == "disabled" && this.delegate.disabledChanged()
        }
        get src() {
            return this.getAttribute("src")
        }
        set src(t) {
            t ? this.setAttribute("src", t) : this.removeAttribute("src")
        }
        get refresh() {
            return this.getAttribute("refresh")
        }
        set refresh(t) {
            t ? this.setAttribute("refresh", t) : this.removeAttribute("refresh")
        }
        get shouldReloadWithMorph() {
            return this.src && this.refresh === "morph"
        }
        get loading() {
            return nv(this.getAttribute("loading") || "")
        }
        set loading(t) {
            t ? this.setAttribute("loading", t) : this.removeAttribute("loading")
        }
        get disabled() {
            return this.hasAttribute("disabled")
        }
        set disabled(t) {
            t ? this.setAttribute("disabled", "") : this.removeAttribute("disabled")
        }
        get autoscroll() {
            return this.hasAttribute("autoscroll")
        }
        set autoscroll(t) {
            t ? this.setAttribute("autoscroll", "") : this.removeAttribute("autoscroll")
        }
        get complete() {
            return !this.delegate.isLoading
        }
        get isActive() {
            return this.ownerDocument === document && !this.isPreview
        }
        get isPreview() {
            return this.ownerDocument?.documentElement?.hasAttribute("data-turbo-preview")
        }
    }
    ;
    function nv(n) {
        switch (n.toLowerCase()) {
        case "lazy":
            return os.lazy;
        default:
            return os.eager
        }
    }
    o(nv, "frameLoadingStyleFromString");
    var sv = {
        enabled: !0,
        progressBarDelay: 500,
        unvisitableExtensions: new Set([".7z", ".aac", ".apk", ".avi", ".bmp", ".bz2", ".css", ".csv", ".deb", ".dmg", ".doc", ".docx", ".exe", ".gif", ".gz", ".heic", ".heif", ".ico", ".iso", ".jpeg", ".jpg", ".js", ".json", ".m4a", ".mkv", ".mov", ".mp3", ".mp4", ".mpeg", ".mpg", ".msi", ".ogg", ".ogv", ".pdf", ".pkg", ".png", ".ppt", ".pptx", ".rar", ".rtf", ".svg", ".tar", ".tif", ".tiff", ".txt", ".wav", ".webm", ".webp", ".wma", ".wmv", ".xls", ".xlsx", ".xml", ".zip"])
    };
    function Gr(n) {
        if (n.getAttribute("data-turbo-eval") == "false")
            return n;
        {
            let t = document.createElement("script")
              , e = hf();
            return e && (t.nonce = e),
            t.textContent = n.textContent,
            t.async = !1,
            rv(t, n),
            t
        }
    }
    o(Gr, "activateScriptElement");
    function rv(n, t) {
        for (let {name: e, value: s} of t.attributes)
            n.setAttribute(e, s)
    }
    o(rv, "copyElementAttributes");
    function ov(n) {
        let t = document.createElement("template");
        return t.innerHTML = n,
        t.content
    }
    o(ov, "createDocumentFragment");
    function ue(n, {target: t, cancelable: e, detail: s}={}) {
        let r = new CustomEvent(n,{
            cancelable: e,
            bubbles: !0,
            composed: !0,
            detail: s
        });
        return t && t.isConnected ? t.dispatchEvent(r) : document.documentElement.dispatchEvent(r),
        r
    }
    o(ue, "dispatch");
    function Qd(n) {
        n.preventDefault(),
        n.stopImmediatePropagation()
    }
    o(Qd, "cancelEvent");
    function Xr() {
        return document.visibilityState === "hidden" ? af() : of()
    }
    o(Xr, "nextRepaint");
    function of() {
        return new Promise(n => requestAnimationFrame( () => n()))
    }
    o(of, "nextAnimationFrame");
    function af() {
        return new Promise(n => setTimeout( () => n(), 0))
    }
    o(af, "nextEventLoopTick");
    function av() {
        return Promise.resolve()
    }
    o(av, "nextMicrotask");
    function lf(n="") {
        return new DOMParser().parseFromString(n, "text/html")
    }
    o(lf, "parseHTMLDocument");
    function cf(n, ...t) {
        let e = lv(n, t).replace(/^\n/, "").split(`
`)
          , s = e[0].match(/^\s+/)
          , r = s ? s[0].length : 0;
        return e.map(a => a.slice(r)).join(`
`)
    }
    o(cf, "unindent");
    function lv(n, t) {
        return n.reduce( (e, s, r) => {
            let a = t[r] == null ? "" : t[r];
            return e + s + a
        }
        , "")
    }
    o(lv, "interpolate");
    function Ln() {
        return Array.from({
            length: 36
        }).map( (n, t) => t == 8 || t == 13 || t == 18 || t == 23 ? "-" : t == 14 ? "4" : t == 19 ? (Math.floor(Math.random() * 4) + 8).toString(16) : Math.floor(Math.random() * 15).toString(16)).join("")
    }
    o(Ln, "uuid");
    function sa(n, ...t) {
        for (let e of t.map(s => s?.getAttribute(n)))
            if (typeof e == "string")
                return e;
        return null
    }
    o(sa, "getAttribute");
    function cv(n, ...t) {
        return t.some(e => e && e.hasAttribute(n))
    }
    o(cv, "hasAttribute");
    function ra(...n) {
        for (let t of n)
            t.localName == "turbo-frame" && t.setAttribute("busy", ""),
            t.setAttribute("aria-busy", "true")
    }
    o(ra, "markAsBusy");
    function oa(...n) {
        for (let t of n)
            t.localName == "turbo-frame" && t.removeAttribute("busy"),
            t.removeAttribute("aria-busy")
    }
    o(oa, "clearBusyState");
    function uv(n, t=2e3) {
        return new Promise(e => {
            let s = o( () => {
                n.removeEventListener("error", s),
                n.removeEventListener("load", s),
                e()
            }
            , "onComplete");
            n.addEventListener("load", s, {
                once: !0
            }),
            n.addEventListener("error", s, {
                once: !0
            }),
            setTimeout(e, t)
        }
        )
    }
    o(uv, "waitForLoad");
    function uf(n) {
        switch (n) {
        case "replace":
            return history.replaceState;
        case "advance":
        case "restore":
            return history.pushState
        }
    }
    o(uf, "getHistoryMethodForAction");
    function hv(n) {
        return n == "advance" || n == "replace" || n == "restore"
    }
    o(hv, "isAction");
    function as(...n) {
        let t = sa("data-turbo-action", ...n);
        return hv(t) ? t : null
    }
    o(as, "getVisitAction");
    function gc(n) {
        return document.querySelector(`meta[name="${n}"]`)
    }
    o(gc, "getMetaElement");
    function aa(n) {
        let t = gc(n);
        return t && t.content
    }
    o(aa, "getMetaContent");
    function hf() {
        let n = gc("csp-nonce");
        if (n) {
            let {nonce: t, content: e} = n;
            return t == "" ? e : t
        }
    }
    o(hf, "getCspNonce");
    function dv(n, t) {
        let e = gc(n);
        return e || (e = document.createElement("meta"),
        e.setAttribute("name", n),
        document.head.appendChild(e)),
        e.setAttribute("content", t),
        e
    }
    o(dv, "setMetaContent");
    function zs(n, t) {
        if (n instanceof Element)
            return n.closest(t) || zs(n.assignedSlot || n.getRootNode()?.host, t)
    }
    o(zs, "findClosestRecursively");
    function mc(n) {
        return !!n && n.closest("[inert], :disabled, [hidden], details:not([open]), dialog:not([open])") == null && typeof n.focus == "function"
    }
    o(mc, "elementIsFocusable");
    function df(n) {
        return Array.from(n.querySelectorAll("[autofocus]")).find(mc)
    }
    o(df, "queryAutofocusableElement");
    async function fv(n, t) {
        let e = t();
        n(),
        await of();
        let s = t();
        return [e, s]
    }
    o(fv, "around");
    function ff(n) {
        if (n === "_blank")
            return !1;
        if (n) {
            for (let t of document.getElementsByName(n))
                if (t instanceof HTMLIFrameElement)
                    return !1;
            return !0
        } else
            return !0
    }
    o(ff, "doesNotTargetIFrame");
    function pf(n) {
        return zs(n, "a[href]:not([target^=_]):not([download])")
    }
    o(pf, "findLinkFromClickTarget");
    function gf(n) {
        return Te(n.getAttribute("href") || "")
    }
    o(gf, "getLocationForLink");
    function pv(n, t) {
        let e = null;
        return (...s) => {
            let r = o( () => n.apply(this, s), "callback");
            clearTimeout(e),
            e = setTimeout(r, t)
        }
    }
    o(pv, "debounce");
    var gv = {
        "aria-disabled": {
            beforeSubmit: o(n => {
                n.setAttribute("aria-disabled", "true"),
                n.addEventListener("click", Qd)
            }
            , "beforeSubmit"),
            afterSubmit: o(n => {
                n.removeAttribute("aria-disabled"),
                n.removeEventListener("click", Qd)
            }
            , "afterSubmit")
        },
        disabled: {
            beforeSubmit: o(n => n.disabled = !0, "beforeSubmit"),
            afterSubmit: o(n => n.disabled = !1, "afterSubmit")
        }
    }
      , Vl = class {
        static{o(this, "Config")
        }#t = null;
        constructor(t) {
            Object.assign(this, t)
        }
        get submitter() {
            return this.#t
        }
        set submitter(t) {
            this.#t = gv[t] || t
        }
    }
      , mv = new Vl({
        mode: "on",
        submitter: "disabled"
    })
      , ve = {
        drive: sv,
        forms: mv
    };
    function Te(n) {
        return new URL(n.toString(),document.baseURI)
    }
    o(Te, "expandURL");
    function ls(n) {
        let t;
        if (n.hash)
            return n.hash.slice(1);
        if (t = n.href.match(/#(.*)$/))
            return t[1]
    }
    o(ls, "getAnchor");
    function vc(n, t) {
        let e = t?.getAttribute("formaction") || n.getAttribute("action") || n.action;
        return Te(e)
    }
    o(vc, "getAction$1");
    function vv(n) {
        return (Ev(n).match(/\.[^.]*$/) || [])[0] || ""
    }
    o(vv, "getExtension");
    function bv(n, t) {
        let e = Sv(t);
        return n.href === Te(e).href || n.href.startsWith(e)
    }
    o(bv, "isPrefixedBy");
    function Mn(n, t) {
        return bv(n, t) && !ve.drive.unvisitableExtensions.has(vv(n))
    }
    o(Mn, "locationIsVisitable");
    function Bl(n) {
        let t = ls(n);
        return t != null ? n.href.slice(0, -(t.length + 1)) : n.href
    }
    o(Bl, "getRequestURL");
    function ia(n) {
        return Bl(n)
    }
    o(ia, "toCacheKey");
    function yv(n, t) {
        return Te(n).href == Te(t).href
    }
    o(yv, "urlsAreEqual");
    function _v(n) {
        return n.pathname.split("/").slice(1)
    }
    o(_v, "getPathComponents");
    function Ev(n) {
        return _v(n).slice(-1)[0]
    }
    o(Ev, "getLastPathComponent");
    function Sv(n) {
        return Tv(n.origin + n.pathname)
    }
    o(Sv, "getPrefix");
    function Tv(n) {
        return n.endsWith("/") ? n : n + "/"
    }
    o(Tv, "addTrailingSlash");
    var Ks = class {
        static{o(this, "FetchResponse")
        }constructor(t) {
            this.response = t
        }
        get succeeded() {
            return this.response.ok
        }
        get failed() {
            return !this.succeeded
        }
        get clientError() {
            return this.statusCode >= 400 && this.statusCode <= 499
        }
        get serverError() {
            return this.statusCode >= 500 && this.statusCode <= 599
        }
        get redirected() {
            return this.response.redirected
        }
        get location() {
            return Te(this.response.url)
        }
        get isHTML() {
            return this.contentType && this.contentType.match(/^(?:text\/([^\s;,]+\b)?html|application\/xhtml\+xml)\b/)
        }
        get statusCode() {
            return this.response.status
        }
        get contentType() {
            return this.header("Content-Type")
        }
        get responseText() {
            return this.response.clone().text()
        }
        get responseHTML() {
            return this.isHTML ? this.response.clone().text() : Promise.resolve(void 0)
        }
        header(t) {
            return this.response.headers.get(t)
        }
    }
      , Hl = class extends Set {
        static{o(this, "LimitedSet")
        }constructor(t) {
            super(),
            this.maxSize = t
        }
        add(t) {
            if (this.size >= this.maxSize) {
                let s = this.values().next().value;
                this.delete(s)
            }
            super.add(t)
        }
    }
      , mf = new Hl(20)
      , xv = window.fetch;
    function bc(n, t={}) {
        let e = new Headers(t.headers || {})
          , s = Ln();
        return mf.add(s),
        e.append("X-Turbo-Request-Id", s),
        xv(n, {
            ...t,
            headers: e
        })
    }
    o(bc, "fetchWithTurboHeaders");
    function ma(n) {
        switch (n.toLowerCase()) {
        case "get":
            return ni.get;
        case "post":
            return ni.post;
        case "put":
            return ni.put;
        case "patch":
            return ni.patch;
        case "delete":
            return ni.delete
        }
    }
    o(ma, "fetchMethodFromString");
    var ni = {
        get: "get",
        post: "post",
        put: "put",
        patch: "patch",
        delete: "delete"
    };
    function vf(n) {
        switch (n.toLowerCase()) {
        case On.multipart:
            return On.multipart;
        case On.plain:
            return On.plain;
        default:
            return On.urlEncoded
        }
    }
    o(vf, "fetchEnctypeFromString");
    var On = {
        urlEncoded: "application/x-www-form-urlencoded",
        multipart: "multipart/form-data",
        plain: "text/plain"
    }
      , Dn = class {
        static{o(this, "FetchRequest")
        }abortController = new AbortController;
        #t = o(t => {}
        , "#resolveRequestPromise");
        constructor(t, e, s, r=new URLSearchParams, a=null, l=On.urlEncoded) {
            let[u,d] = Jd(Te(s), e, r, l);
            this.delegate = t,
            this.url = u,
            this.target = a,
            this.fetchOptions = {
                credentials: "same-origin",
                redirect: "follow",
                method: e.toUpperCase(),
                headers: {
                    ...this.defaultHeaders
                },
                body: d,
                signal: this.abortSignal,
                referrer: this.delegate.referrer?.href
            },
            this.enctype = l
        }
        get method() {
            return this.fetchOptions.method
        }
        set method(t) {
            let e = this.isSafe ? this.url.searchParams : this.fetchOptions.body || new FormData
              , s = ma(t) || ni.get;
            this.url.search = "";
            let[r,a] = Jd(this.url, s, e, this.enctype);
            this.url = r,
            this.fetchOptions.body = a,
            this.fetchOptions.method = s.toUpperCase()
        }
        get headers() {
            return this.fetchOptions.headers
        }
        set headers(t) {
            this.fetchOptions.headers = t
        }
        get body() {
            return this.isSafe ? this.url.searchParams : this.fetchOptions.body
        }
        set body(t) {
            this.fetchOptions.body = t
        }
        get location() {
            return this.url
        }
        get params() {
            return this.url.searchParams
        }
        get entries() {
            return this.body ? Array.from(this.body.entries()) : []
        }
        cancel() {
            this.abortController.abort()
        }
        async perform() {
            let {fetchOptions: t} = this;
            this.delegate.prepareRequest(this);
            let e = await this.#e(t);
            try {
                this.delegate.requestStarted(this),
                e.detail.fetchRequest ? this.response = e.detail.fetchRequest.response : this.response = bc(this.url.href, t);
                let s = await this.response;
                return await this.receive(s)
            } catch (s) {
                if (s.name !== "AbortError")
                    throw this.#i(s) && this.delegate.requestErrored(this, s),
                    s
            } finally {
                this.delegate.requestFinished(this)
            }
        }
        async receive(t) {
            let e = new Ks(t);
            return ue("turbo:before-fetch-response", {
                cancelable: !0,
                detail: {
                    fetchResponse: e
                },
                target: this.target
            }).defaultPrevented ? this.delegate.requestPreventedHandlingResponse(this, e) : e.succeeded ? this.delegate.requestSucceededWithResponse(this, e) : this.delegate.requestFailedWithResponse(this, e),
            e
        }
        get defaultHeaders() {
            return {
                Accept: "text/html, application/xhtml+xml"
            }
        }
        get isSafe() {
            return va(this.method)
        }
        get abortSignal() {
            return this.abortController.signal
        }
        acceptResponseType(t) {
            this.headers.Accept = [t, this.headers.Accept].join(", ")
        }
        async #e(t) {
            let e = new Promise(r => this.#t = r)
              , s = ue("turbo:before-fetch-request", {
                cancelable: !0,
                detail: {
                    fetchOptions: t,
                    url: this.url,
                    resume: this.#t
                },
                target: this.target
            });
            return this.url = s.detail.url,
            s.defaultPrevented && await e,
            s
        }
        #i(t) {
            return !ue("turbo:fetch-request-error", {
                target: this.target,
                cancelable: !0,
                detail: {
                    request: this,
                    error: t
                }
            }).defaultPrevented
        }
    }
    ;
    function va(n) {
        return ma(n) == ni.get
    }
    o(va, "isSafe");
    function Jd(n, t, e, s) {
        let r = Array.from(e).length > 0 ? new URLSearchParams(bf(e)) : n.searchParams;
        return va(t) ? [wv(n, r), null] : s == On.urlEncoded ? [n, r] : [n, e]
    }
    o(Jd, "buildResourceAndBody");
    function bf(n) {
        let t = [];
        for (let[e,s] of n)
            s instanceof File || t.push([e, s]);
        return t
    }
    o(bf, "entriesExcludingFiles");
    function wv(n, t) {
        let e = new URLSearchParams(bf(t));
        return n.search = e.toString(),
        n
    }
    o(wv, "mergeIntoURLSearchParams");
    var jl = class {
        static{o(this, "AppearanceObserver")
        }started = !1;
        constructor(t, e) {
            this.delegate = t,
            this.element = e,
            this.intersectionObserver = new IntersectionObserver(this.intersect)
        }
        start() {
            this.started || (this.started = !0,
            this.intersectionObserver.observe(this.element))
        }
        stop() {
            this.started && (this.started = !1,
            this.intersectionObserver.unobserve(this.element))
        }
        intersect = o(t => {
            t.slice(-1)[0]?.isIntersecting && this.delegate.elementAppearedInViewport(this.element)
        }
        , "intersect")
    }
      , Pn = class {
        static{o(this, "StreamMessage")
        }static contentType = "text/vnd.turbo-stream.html";
        static wrap(t) {
            return typeof t == "string" ? new this(ov(t)) : t
        }
        constructor(t) {
            this.fragment = Cv(t)
        }
    }
    ;
    function Cv(n) {
        for (let t of n.querySelectorAll("turbo-stream")) {
            let e = document.importNode(t, !0);
            for (let s of e.templateElement.content.querySelectorAll("script"))
                s.replaceWith(Gr(s));
            t.replaceWith(e)
        }
        return n
    }
    o(Cv, "importStreamElements");
    var Av = 100
      , Wl = class {
        static{o(this, "PrefetchCache")
        }#t = null;
        #e = null;
        get(t) {
            if (this.#e && this.#e.url === t && this.#e.expire > Date.now())
                return this.#e.request
        }
        setLater(t, e, s) {
            this.clear(),
            this.#t = setTimeout( () => {
                e.perform(),
                this.set(t, e, s),
                this.#t = null
            }
            , Av)
        }
        set(t, e, s) {
            this.#e = {
                url: t,
                request: e,
                expire: new Date(new Date().getTime() + s)
            }
        }
        clear() {
            this.#t && clearTimeout(this.#t),
            this.#e = null
        }
    }
      , kv = 10 * 1e3
      , qs = new Wl
      , $s = {
        initialized: "initialized",
        requesting: "requesting",
        waiting: "waiting",
        receiving: "receiving",
        stopping: "stopping",
        stopped: "stopped"
    }
      , la = class n {
        static{o(this, "FormSubmission")
        }state = $s.initialized;
        static confirmMethod(t) {
            return Promise.resolve(confirm(t))
        }
        constructor(t, e, s, r=!1) {
            let a = Rv(e, s)
              , l = Pv(Dv(e, s), a)
              , u = Mv(e, s)
              , d = Iv(e, s);
            this.delegate = t,
            this.formElement = e,
            this.submitter = s,
            this.fetchRequest = new Dn(this,a,l,u,e,d),
            this.mustRedirect = r
        }
        get method() {
            return this.fetchRequest.method
        }
        set method(t) {
            this.fetchRequest.method = t
        }
        get action() {
            return this.fetchRequest.url.toString()
        }
        set action(t) {
            this.fetchRequest.url = Te(t)
        }
        get body() {
            return this.fetchRequest.body
        }
        get enctype() {
            return this.fetchRequest.enctype
        }
        get isSafe() {
            return this.fetchRequest.isSafe
        }
        get location() {
            return this.fetchRequest.url
        }
        async start() {
            let {initialized: t, requesting: e} = $s
              , s = sa("data-turbo-confirm", this.submitter, this.formElement);
            if (!(typeof s == "string" && !await (typeof ve.forms.confirm == "function" ? ve.forms.confirm : n.confirmMethod)(s, this.formElement, this.submitter)) && this.state == t)
                return this.state = e,
                this.fetchRequest.perform()
        }
        stop() {
            let {stopping: t, stopped: e} = $s;
            if (this.state != t && this.state != e)
                return this.state = t,
                this.fetchRequest.cancel(),
                !0
        }
        prepareRequest(t) {
            if (!t.isSafe) {
                let e = Ov(aa("csrf-param")) || aa("csrf-token");
                e && (t.headers["X-CSRF-Token"] = e)
            }
            this.requestAcceptsTurboStreamResponse(t) && t.acceptResponseType(Pn.contentType)
        }
        requestStarted(t) {
            this.state = $s.waiting,
            this.submitter && ve.forms.submitter.beforeSubmit(this.submitter),
            this.setSubmitsWith(),
            ra(this.formElement),
            ue("turbo:submit-start", {
                target: this.formElement,
                detail: {
                    formSubmission: this
                }
            }),
            this.delegate.formSubmissionStarted(this)
        }
        requestPreventedHandlingResponse(t, e) {
            qs.clear(),
            this.result = {
                success: e.succeeded,
                fetchResponse: e
            }
        }
        requestSucceededWithResponse(t, e) {
            if (e.clientError || e.serverError) {
                this.delegate.formSubmissionFailedWithResponse(this, e);
                return
            }
            if (qs.clear(),
            this.requestMustRedirect(t) && Lv(e)) {
                let s = new Error("Form responses must redirect to another location");
                this.delegate.formSubmissionErrored(this, s)
            } else
                this.state = $s.receiving,
                this.result = {
                    success: !0,
                    fetchResponse: e
                },
                this.delegate.formSubmissionSucceededWithResponse(this, e)
        }
        requestFailedWithResponse(t, e) {
            this.result = {
                success: !1,
                fetchResponse: e
            },
            this.delegate.formSubmissionFailedWithResponse(this, e)
        }
        requestErrored(t, e) {
            this.result = {
                success: !1,
                error: e
            },
            this.delegate.formSubmissionErrored(this, e)
        }
        requestFinished(t) {
            this.state = $s.stopped,
            this.submitter && ve.forms.submitter.afterSubmit(this.submitter),
            this.resetSubmitterText(),
            oa(this.formElement),
            ue("turbo:submit-end", {
                target: this.formElement,
                detail: {
                    formSubmission: this,
                    ...this.result
                }
            }),
            this.delegate.formSubmissionFinished(this)
        }
        setSubmitsWith() {
            if (!(!this.submitter || !this.submitsWith)) {
                if (this.submitter.matches("button"))
                    this.originalSubmitText = this.submitter.innerHTML,
                    this.submitter.innerHTML = this.submitsWith;
                else if (this.submitter.matches("input")) {
                    let t = this.submitter;
                    this.originalSubmitText = t.value,
                    t.value = this.submitsWith
                }
            }
        }
        resetSubmitterText() {
            if (!(!this.submitter || !this.originalSubmitText)) {
                if (this.submitter.matches("button"))
                    this.submitter.innerHTML = this.originalSubmitText;
                else if (this.submitter.matches("input")) {
                    let t = this.submitter;
                    t.value = this.originalSubmitText
                }
            }
        }
        requestMustRedirect(t) {
            return !t.isSafe && this.mustRedirect
        }
        requestAcceptsTurboStreamResponse(t) {
            return !t.isSafe || cv("data-turbo-stream", this.submitter, this.formElement)
        }
        get submitsWith() {
            return this.submitter?.getAttribute("data-turbo-submits-with")
        }
    }
    ;
    function Mv(n, t) {
        let e = new FormData(n)
          , s = t?.getAttribute("name")
          , r = t?.getAttribute("value");
        return s && e.append(s, r || ""),
        e
    }
    o(Mv, "buildFormData");
    function Ov(n) {
        if (n != null) {
            let e = (document.cookie ? document.cookie.split("; ") : []).find(s => s.startsWith(n));
            if (e) {
                let s = e.split("=").slice(1).join("=");
                return s ? decodeURIComponent(s) : void 0
            }
        }
    }
    o(Ov, "getCookieValue");
    function Lv(n) {
        return n.statusCode == 200 && !n.redirected
    }
    o(Lv, "responseSucceededWithoutRedirect");
    function Dv(n, t) {
        let e = typeof n.action == "string" ? n.action : null;
        return t?.hasAttribute("formaction") ? t.getAttribute("formaction") || "" : n.getAttribute("action") || e || ""
    }
    o(Dv, "getFormAction");
    function Pv(n, t) {
        let e = Te(n);
        return va(t) && (e.search = ""),
        e
    }
    o(Pv, "getAction");
    function Rv(n, t) {
        let e = t?.getAttribute("formmethod") || n.getAttribute("method") || "";
        return ma(e.toLowerCase()) || ni.get
    }
    o(Rv, "getMethod");
    function Iv(n, t) {
        return vf(t?.getAttribute("formenctype") || n.enctype)
    }
    o(Iv, "getEnctype");
    var Ys = class {
        static{o(this, "Snapshot")
        }constructor(t) {
            this.element = t
        }
        get activeElement() {
            return this.element.ownerDocument.activeElement
        }
        get children() {
            return [...this.element.children]
        }
        hasAnchor(t) {
            return this.getElementForAnchor(t) != null
        }
        getElementForAnchor(t) {
            return t ? this.element.querySelector(`[id='${t}'], a[name='${t}']`) : null
        }
        get isConnected() {
            return this.element.isConnected
        }
        get firstAutofocusableElement() {
            return df(this.element)
        }
        get permanentElements() {
            return _f(this.element)
        }
        getPermanentElementById(t) {
            return yf(this.element, t)
        }
        getPermanentElementMapForSnapshot(t) {
            let e = {};
            for (let s of this.permanentElements) {
                let {id: r} = s
                  , a = t.getPermanentElementById(r);
                a && (e[r] = [s, a])
            }
            return e
        }
    }
    ;
    function yf(n, t) {
        return n.querySelector(`#${t}[data-turbo-permanent]`)
    }
    o(yf, "getPermanentElementById");
    function _f(n) {
        return n.querySelectorAll("[id][data-turbo-permanent]")
    }
    o(_f, "queryPermanentElementsAll");
    var Qr = class {
        static{o(this, "FormSubmitObserver")
        }started = !1;
        constructor(t, e) {
            this.delegate = t,
            this.eventTarget = e
        }
        start() {
            this.started || (this.eventTarget.addEventListener("submit", this.submitCaptured, !0),
            this.started = !0)
        }
        stop() {
            this.started && (this.eventTarget.removeEventListener("submit", this.submitCaptured, !0),
            this.started = !1)
        }
        submitCaptured = o( () => {
            this.eventTarget.removeEventListener("submit", this.submitBubbled, !1),
            this.eventTarget.addEventListener("submit", this.submitBubbled, !1)
        }
        , "submitCaptured");
        submitBubbled = o(t => {
            if (!t.defaultPrevented) {
                let e = t.target instanceof HTMLFormElement ? t.target : void 0
                  , s = t.submitter || void 0;
                e && Nv(e, s) && Fv(e, s) && this.delegate.willSubmitForm(e, s) && (t.preventDefault(),
                t.stopImmediatePropagation(),
                this.delegate.formSubmitted(e, s))
            }
        }
        , "submitBubbled")
    }
    ;
    function Nv(n, t) {
        return (t?.getAttribute("formmethod") || n.getAttribute("method")) != "dialog"
    }
    o(Nv, "submissionDoesNotDismissDialog");
    function Fv(n, t) {
        let e = t?.getAttribute("formtarget") || n.getAttribute("target");
        return ff(e)
    }
    o(Fv, "submissionDoesNotTargetIFrame");
    var ca = class {
        static{o(this, "View")
        }#t = o(t => {}
        , "#resolveRenderPromise");
        #e = o(t => {}
        , "#resolveInterceptionPromise");
        constructor(t, e) {
            this.delegate = t,
            this.element = e
        }
        scrollToAnchor(t) {
            let e = this.snapshot.getElementForAnchor(t);
            e ? (this.scrollToElement(e),
            this.focusElement(e)) : this.scrollToPosition({
                x: 0,
                y: 0
            })
        }
        scrollToAnchorFromLocation(t) {
            this.scrollToAnchor(ls(t))
        }
        scrollToElement(t) {
            t.scrollIntoView()
        }
        focusElement(t) {
            t instanceof HTMLElement && (t.hasAttribute("tabindex") ? t.focus() : (t.setAttribute("tabindex", "-1"),
            t.focus(),
            t.removeAttribute("tabindex")))
        }
        scrollToPosition({x: t, y: e}) {
            this.scrollRoot.scrollTo(t, e)
        }
        scrollToTop() {
            this.scrollToPosition({
                x: 0,
                y: 0
            })
        }
        get scrollRoot() {
            return window
        }
        async render(t) {
            let {isPreview: e, shouldRender: s, willRender: r, newSnapshot: a} = t
              , l = r;
            if (s)
                try {
                    this.renderPromise = new Promise(b => this.#t = b),
                    this.renderer = t,
                    await this.prepareToRenderSnapshot(t);
                    let u = new Promise(b => this.#e = b)
                      , d = {
                        resume: this.#e,
                        render: this.renderer.renderElement,
                        renderMethod: this.renderer.renderMethod
                    };
                    this.delegate.allowsImmediateRender(a, d) || await u,
                    await this.renderSnapshot(t),
                    this.delegate.viewRenderedSnapshot(a, e, this.renderer.renderMethod),
                    this.delegate.preloadOnLoadLinksForView(this.element),
                    this.finishRenderingSnapshot(t)
                } finally {
                    delete this.renderer,
                    this.#t(void 0),
                    delete this.renderPromise
                }
            else
                l && this.invalidate(t.reloadReason)
        }
        invalidate(t) {
            this.delegate.viewInvalidated(t)
        }
        async prepareToRenderSnapshot(t) {
            this.markAsPreview(t.isPreview),
            await t.prepareToRender()
        }
        markAsPreview(t) {
            t ? this.element.setAttribute("data-turbo-preview", "") : this.element.removeAttribute("data-turbo-preview")
        }
        markVisitDirection(t) {
            this.element.setAttribute("data-turbo-visit-direction", t)
        }
        unmarkVisitDirection() {
            this.element.removeAttribute("data-turbo-visit-direction")
        }
        async renderSnapshot(t) {
            await t.render()
        }
        finishRenderingSnapshot(t) {
            t.finishRendering()
        }
    }
      , $l = class extends ca {
        static{o(this, "FrameView")
        }missing() {
            this.element.innerHTML = '<strong class="turbo-frame-error">Content missing</strong>'
        }
        get snapshot() {
            return new Ys(this.element)
        }
    }
      , ua = class {
        static{o(this, "LinkInterceptor")
        }constructor(t, e) {
            this.delegate = t,
            this.element = e
        }
        start() {
            this.element.addEventListener("click", this.clickBubbled),
            document.addEventListener("turbo:click", this.linkClicked),
            document.addEventListener("turbo:before-visit", this.willVisit)
        }
        stop() {
            this.element.removeEventListener("click", this.clickBubbled),
            document.removeEventListener("turbo:click", this.linkClicked),
            document.removeEventListener("turbo:before-visit", this.willVisit)
        }
        clickBubbled = o(t => {
            this.clickEventIsSignificant(t) ? this.clickEvent = t : delete this.clickEvent
        }
        , "clickBubbled");
        linkClicked = o(t => {
            this.clickEvent && this.clickEventIsSignificant(t) && this.delegate.shouldInterceptLinkClick(t.target, t.detail.url, t.detail.originalEvent) && (this.clickEvent.preventDefault(),
            t.preventDefault(),
            this.delegate.linkClickIntercepted(t.target, t.detail.url, t.detail.originalEvent)),
            delete this.clickEvent
        }
        , "linkClicked");
        willVisit = o(t => {
            delete this.clickEvent
        }
        , "willVisit");
        clickEventIsSignificant(t) {
            let e = t.composed ? t.target?.parentElement : t.target
              , s = pf(e) || e;
            return s instanceof Element && s.closest("turbo-frame, html") == this.element
        }
    }
      , ha = class {
        static{o(this, "LinkClickObserver")
        }started = !1;
        constructor(t, e) {
            this.delegate = t,
            this.eventTarget = e
        }
        start() {
            this.started || (this.eventTarget.addEventListener("click", this.clickCaptured, !0),
            this.started = !0)
        }
        stop() {
            this.started && (this.eventTarget.removeEventListener("click", this.clickCaptured, !0),
            this.started = !1)
        }
        clickCaptured = o( () => {
            this.eventTarget.removeEventListener("click", this.clickBubbled, !1),
            this.eventTarget.addEventListener("click", this.clickBubbled, !1)
        }
        , "clickCaptured");
        clickBubbled = o(t => {
            if (t instanceof MouseEvent && this.clickEventIsSignificant(t)) {
                let e = t.composedPath && t.composedPath()[0] || t.target
                  , s = pf(e);
                if (s && ff(s.target)) {
                    let r = gf(s);
                    this.delegate.willFollowLinkToLocation(s, r, t) && (t.preventDefault(),
                    this.delegate.followedLinkToLocation(s, r))
                }
            }
        }
        , "clickBubbled");
        clickEventIsSignificant(t) {
            return !(t.target && t.target.isContentEditable || t.defaultPrevented || t.which > 1 || t.altKey || t.ctrlKey || t.metaKey || t.shiftKey)
        }
    }
      , da = class {
        static{o(this, "FormLinkClickObserver")
        }constructor(t, e) {
            this.delegate = t,
            this.linkInterceptor = new ha(this,e)
        }
        start() {
            this.linkInterceptor.start()
        }
        stop() {
            this.linkInterceptor.stop()
        }
        canPrefetchRequestToLocation(t, e) {
            return !1
        }
        prefetchAndCacheRequestToLocation(t, e) {}
        willFollowLinkToLocation(t, e, s) {
            return this.delegate.willSubmitFormLinkToLocation(t, e, s) && (t.hasAttribute("data-turbo-method") || t.hasAttribute("data-turbo-stream"))
        }
        followedLinkToLocation(t, e) {
            let s = document.createElement("form")
              , r = "hidden";
            for (let[E,x] of e.searchParams)
                s.append(Object.assign(document.createElement("input"), {
                    type: r,
                    name: E,
                    value: x
                }));
            let a = Object.assign(e, {
                search: ""
            });
            s.setAttribute("data-turbo", "true"),
            s.setAttribute("action", a.href),
            s.setAttribute("hidden", "");
            let l = t.getAttribute("data-turbo-method");
            l && s.setAttribute("method", l);
            let u = t.getAttribute("data-turbo-frame");
            u && s.setAttribute("data-turbo-frame", u);
            let d = as(t);
            d && s.setAttribute("data-turbo-action", d);
            let p = t.getAttribute("data-turbo-confirm");
            p && s.setAttribute("data-turbo-confirm", p),
            t.hasAttribute("data-turbo-stream") && s.setAttribute("data-turbo-stream", ""),
            this.delegate.submittedFormLinkToLocation(t, e, s),
            document.body.appendChild(s),
            s.addEventListener("turbo:submit-end", () => s.remove(), {
                once: !0
            }),
            requestAnimationFrame( () => s.requestSubmit())
        }
    }
      , fa = class {
        static{o(this, "Bardo")
        }static async preservingPermanentElements(t, e, s) {
            let r = new this(t,e);
            r.enter(),
            await s(),
            r.leave()
        }
        constructor(t, e) {
            this.delegate = t,
            this.permanentElementMap = e
        }
        enter() {
            for (let t in this.permanentElementMap) {
                let[e,s] = this.permanentElementMap[t];
                this.delegate.enteringBardo(e, s),
                this.replaceNewPermanentElementWithPlaceholder(s)
            }
        }
        leave() {
            for (let t in this.permanentElementMap) {
                let[e] = this.permanentElementMap[t];
                this.replaceCurrentPermanentElementWithClone(e),
                this.replacePlaceholderWithPermanentElement(e),
                this.delegate.leavingBardo(e)
            }
        }
        replaceNewPermanentElementWithPlaceholder(t) {
            let e = Vv(t);
            t.replaceWith(e)
        }
        replaceCurrentPermanentElementWithClone(t) {
            let e = t.cloneNode(!0);
            t.replaceWith(e)
        }
        replacePlaceholderWithPermanentElement(t) {
            this.getPlaceholderById(t.id)?.replaceWith(t)
        }
        getPlaceholderById(t) {
            return this.placeholders.find(e => e.content == t)
        }
        get placeholders() {
            return [...document.querySelectorAll("meta[name=turbo-permanent-placeholder][content]")]
        }
    }
    ;
    function Vv(n) {
        let t = document.createElement("meta");
        return t.setAttribute("name", "turbo-permanent-placeholder"),
        t.setAttribute("content", n.id),
        t
    }
    o(Vv, "createPlaceholderForPermanentElement");
    var Jr = class {
        static{o(this, "Renderer")
        }#t = null;
        static renderElement(t, e) {}
        constructor(t, e, s, r=!0) {
            this.currentSnapshot = t,
            this.newSnapshot = e,
            this.isPreview = s,
            this.willRender = r,
            this.renderElement = this.constructor.renderElement,
            this.promise = new Promise( (a, l) => this.resolvingFunctions = {
                resolve: a,
                reject: l
            })
        }
        get shouldRender() {
            return !0
        }
        get shouldAutofocus() {
            return !0
        }
        get reloadReason() {}
        prepareToRender() {}
        render() {}
        finishRendering() {
            this.resolvingFunctions && (this.resolvingFunctions.resolve(),
            delete this.resolvingFunctions)
        }
        async preservingPermanentElements(t) {
            await fa.preservingPermanentElements(this, this.permanentElementMap, t)
        }
        focusFirstAutofocusableElement() {
            if (this.shouldAutofocus) {
                let t = this.connectedSnapshot.firstAutofocusableElement;
                t && t.focus()
            }
        }
        enteringBardo(t) {
            this.#t || t.contains(this.currentSnapshot.activeElement) && (this.#t = this.currentSnapshot.activeElement)
        }
        leavingBardo(t) {
            t.contains(this.#t) && this.#t instanceof HTMLElement && (this.#t.focus(),
            this.#t = null)
        }
        get connectedSnapshot() {
            return this.newSnapshot.isConnected ? this.newSnapshot : this.currentSnapshot
        }
        get currentElement() {
            return this.currentSnapshot.element
        }
        get newElement() {
            return this.newSnapshot.element
        }
        get permanentElementMap() {
            return this.currentSnapshot.getPermanentElementMapForSnapshot(this.newSnapshot)
        }
        get renderMethod() {
            return "replace"
        }
    }
      , Xs = class extends Jr {
        static{o(this, "FrameRenderer")
        }static renderElement(t, e) {
            let s = document.createRange();
            s.selectNodeContents(t),
            s.deleteContents();
            let r = e
              , a = r.ownerDocument?.createRange();
            a && (a.selectNodeContents(r),
            t.appendChild(a.extractContents()))
        }
        constructor(t, e, s, r, a, l=!0) {
            super(e, s, r, a, l),
            this.delegate = t
        }
        get shouldRender() {
            return !0
        }
        async render() {
            await Xr(),
            this.preservingPermanentElements( () => {
                this.loadFrameElement()
            }
            ),
            this.scrollFrameIntoView(),
            await Xr(),
            this.focusFirstAutofocusableElement(),
            await Xr(),
            this.activateScriptElements()
        }
        loadFrameElement() {
            this.delegate.willRenderFrame(this.currentElement, this.newElement),
            this.renderElement(this.currentElement, this.newElement)
        }
        scrollFrameIntoView() {
            if (this.currentElement.autoscroll || this.newElement.autoscroll) {
                let t = this.currentElement.firstElementChild
                  , e = Bv(this.currentElement.getAttribute("data-autoscroll-block"), "end")
                  , s = Hv(this.currentElement.getAttribute("data-autoscroll-behavior"), "auto");
                if (t)
                    return t.scrollIntoView({
                        block: e,
                        behavior: s
                    }),
                    !0
            }
            return !1
        }
        activateScriptElements() {
            for (let t of this.newScriptElements) {
                let e = Gr(t);
                t.replaceWith(e)
            }
        }
        get newScriptElements() {
            return this.currentElement.querySelectorAll("script")
        }
    }
    ;
    function Bv(n, t) {
        return n == "end" || n == "start" || n == "center" || n == "nearest" ? n : t
    }
    o(Bv, "readScrollLogicalPosition");
    function Hv(n, t) {
        return n == "auto" || n == "smooth" ? n : t
    }
    o(Hv, "readScrollBehavior");
    var jv = (function() {
        let n = o( () => {}
        , "noOp")
          , t = {
            morphStyle: "outerHTML",
            callbacks: {
                beforeNodeAdded: n,
                afterNodeAdded: n,
                beforeNodeMorphed: n,
                afterNodeMorphed: n,
                beforeNodeRemoved: n,
                afterNodeRemoved: n,
                beforeAttributeUpdated: n
            },
            head: {
                style: "merge",
                shouldPreserve: o(x => x.getAttribute("im-preserve") === "true", "shouldPreserve"),
                shouldReAppend: o(x => x.getAttribute("im-re-append") === "true", "shouldReAppend"),
                shouldRemove: n,
                afterHeadMorphed: n
            },
            restoreFocus: !0
        };
        function e(x, w, C={}) {
            x = b(x);
            let I = E(w)
              , L = p(x, I, C)
              , k = r(L, () => u(L, x, I, F => F.morphStyle === "innerHTML" ? (a(F, x, I),
            Array.from(x.childNodes)) : s(F, x, I)));
            return L.pantry.remove(),
            k
        }
        o(e, "morph");
        function s(x, w, C) {
            let I = E(w)
              , L = Array.from(I.childNodes)
              , k = L.indexOf(w)
              , F = L.length - (k + 1);
            return a(x, I, C, w, w.nextSibling),
            L = Array.from(I.childNodes),
            L.slice(k, L.length - F)
        }
        o(s, "morphOuterHTML");
        function r(x, w) {
            if (!x.config.restoreFocus)
                return w();
            let C = document.activeElement;
            if (!(C instanceof HTMLInputElement || C instanceof HTMLTextAreaElement))
                return w();
            let {id: I, selectionStart: L, selectionEnd: k} = C
              , F = w();
            return I && I !== document.activeElement?.id && (C = x.target.querySelector(`#${I}`),
            C?.focus()),
            C && !C.selectionEnd && k && C.setSelectionRange(L, k),
            F
        }
        o(r, "saveAndRestoreFocus");
        let a = (function() {
            function x(j, H, f, Y=null, Q=null) {
                H instanceof HTMLTemplateElement && f instanceof HTMLTemplateElement && (H = H.content,
                f = f.content),
                Y ||= H.firstChild;
                for (let ot of f.childNodes) {
                    if (Y && Y != Q) {
                        let bt = C(j, ot, Y, Q);
                        if (bt) {
                            bt !== Y && L(j, Y, bt),
                            l(bt, ot, j),
                            Y = bt.nextSibling;
                            continue
                        }
                    }
                    if (ot instanceof Element && j.persistentIds.has(ot.id)) {
                        let bt = k(H, ot.id, Y, j);
                        l(bt, ot, j),
                        Y = bt.nextSibling;
                        continue
                    }
                    let mt = w(H, ot, Y, j);
                    mt && (Y = mt.nextSibling)
                }
                for (; Y && Y != Q; ) {
                    let ot = Y;
                    Y = Y.nextSibling,
                    I(j, ot)
                }
            }
            o(x, "morphChildren");
            function w(j, H, f, Y) {
                if (Y.callbacks.beforeNodeAdded(H) === !1)
                    return null;
                if (Y.idMap.has(H)) {
                    let Q = document.createElement(H.tagName);
                    return j.insertBefore(Q, f),
                    l(Q, H, Y),
                    Y.callbacks.afterNodeAdded(Q),
                    Q
                } else {
                    let Q = document.importNode(H, !0);
                    return j.insertBefore(Q, f),
                    Y.callbacks.afterNodeAdded(Q),
                    Q
                }
            }
            o(w, "createNode");
            let C = (function() {
                function j(Y, Q, ot, mt) {
                    let bt = null
                      , ft = Q.nextSibling
                      , $t = 0
                      , Ut = ot;
                    for (; Ut && Ut != mt; ) {
                        if (f(Ut, Q)) {
                            if (H(Y, Ut, Q))
                                return Ut;
                            bt === null && (Y.idMap.has(Ut) || (bt = Ut))
                        }
                        if (bt === null && ft && f(Ut, ft) && ($t++,
                        ft = ft.nextSibling,
                        $t >= 2 && (bt = void 0)),
                        Ut.contains(document.activeElement))
                            break;
                        Ut = Ut.nextSibling
                    }
                    return bt || null
                }
                o(j, "findBestMatch");
                function H(Y, Q, ot) {
                    let mt = Y.idMap.get(Q)
                      , bt = Y.idMap.get(ot);
                    if (!bt || !mt)
                        return !1;
                    for (let ft of mt)
                        if (bt.has(ft))
                            return !0;
                    return !1
                }
                o(H, "isIdSetMatch");
                function f(Y, Q) {
                    let ot = Y
                      , mt = Q;
                    return ot.nodeType === mt.nodeType && ot.tagName === mt.tagName && (!ot.id || ot.id === mt.id)
                }
                return o(f, "isSoftMatch"),
                j
            }
            )();
            function I(j, H) {
                if (j.idMap.has(H))
                    z(j.pantry, H, null);
                else {
                    if (j.callbacks.beforeNodeRemoved(H) === !1)
                        return;
                    H.parentNode?.removeChild(H),
                    j.callbacks.afterNodeRemoved(H)
                }
            }
            o(I, "removeNode");
            function L(j, H, f) {
                let Y = H;
                for (; Y && Y !== f; ) {
                    let Q = Y;
                    Y = Y.nextSibling,
                    I(j, Q)
                }
                return Y
            }
            o(L, "removeNodesBetween");
            function k(j, H, f, Y) {
                let Q = Y.target.querySelector(`#${H}`) || Y.pantry.querySelector(`#${H}`);
                return F(Q, Y),
                z(j, Q, f),
                Q
            }
            o(k, "moveBeforeById");
            function F(j, H) {
                let f = j.id;
                for (; j = j.parentNode; ) {
                    let Y = H.idMap.get(j);
                    Y && (Y.delete(f),
                    Y.size || H.idMap.delete(j))
                }
            }
            o(F, "removeElementFromAncestorsIdMaps");
            function z(j, H, f) {
                if (j.moveBefore)
                    try {
                        j.moveBefore(H, f)
                    } catch {
                        j.insertBefore(H, f)
                    }
                else
                    j.insertBefore(H, f)
            }
            return o(z, "moveBefore"),
            x
        }
        )()
          , l = (function() {
            function x(F, z, j) {
                return j.ignoreActive && F === document.activeElement ? null : (j.callbacks.beforeNodeMorphed(F, z) === !1 || (F instanceof HTMLHeadElement && j.head.ignore || (F instanceof HTMLHeadElement && j.head.style !== "morph" ? d(F, z, j) : (w(F, z, j),
                k(F, j) || a(j, F, z))),
                j.callbacks.afterNodeMorphed(F, z)),
                F)
            }
            o(x, "morphNode");
            function w(F, z, j) {
                let H = z.nodeType;
                if (H === 1) {
                    let f = F
                      , Y = z
                      , Q = f.attributes
                      , ot = Y.attributes;
                    for (let mt of ot)
                        L(mt.name, f, "update", j) || f.getAttribute(mt.name) !== mt.value && f.setAttribute(mt.name, mt.value);
                    for (let mt = Q.length - 1; 0 <= mt; mt--) {
                        let bt = Q[mt];
                        if (bt && !Y.hasAttribute(bt.name)) {
                            if (L(bt.name, f, "remove", j))
                                continue;
                            f.removeAttribute(bt.name)
                        }
                    }
                    k(f, j) || C(f, Y, j)
                }
                (H === 8 || H === 3) && F.nodeValue !== z.nodeValue && (F.nodeValue = z.nodeValue)
            }
            o(w, "morphAttributes");
            function C(F, z, j) {
                if (F instanceof HTMLInputElement && z instanceof HTMLInputElement && z.type !== "file") {
                    let H = z.value
                      , f = F.value;
                    I(F, z, "checked", j),
                    I(F, z, "disabled", j),
                    z.hasAttribute("value") ? f !== H && (L("value", F, "update", j) || (F.setAttribute("value", H),
                    F.value = H)) : L("value", F, "remove", j) || (F.value = "",
                    F.removeAttribute("value"))
                } else if (F instanceof HTMLOptionElement && z instanceof HTMLOptionElement)
                    I(F, z, "selected", j);
                else if (F instanceof HTMLTextAreaElement && z instanceof HTMLTextAreaElement) {
                    let H = z.value
                      , f = F.value;
                    if (L("value", F, "update", j))
                        return;
                    H !== f && (F.value = H),
                    F.firstChild && F.firstChild.nodeValue !== H && (F.firstChild.nodeValue = H)
                }
            }
            o(C, "syncInputValue");
            function I(F, z, j, H) {
                let f = z[j]
                  , Y = F[j];
                if (f !== Y) {
                    let Q = L(j, F, "update", H);
                    Q || (F[j] = z[j]),
                    f ? Q || F.setAttribute(j, "") : L(j, F, "remove", H) || F.removeAttribute(j)
                }
            }
            o(I, "syncBooleanAttribute");
            function L(F, z, j, H) {
                return F === "value" && H.ignoreActiveValue && z === document.activeElement ? !0 : H.callbacks.beforeAttributeUpdated(F, z, j) === !1
            }
            o(L, "ignoreAttribute");
            function k(F, z) {
                return !!z.ignoreActiveValue && F === document.activeElement && F !== document.body
            }
            return o(k, "ignoreValueOfActiveElement"),
            x
        }
        )();
        function u(x, w, C, I) {
            if (x.head.block) {
                let L = w.querySelector("head")
                  , k = C.querySelector("head");
                if (L && k) {
                    let F = d(L, k, x);
                    return Promise.all(F).then( () => {
                        let z = Object.assign(x, {
                            head: {
                                block: !1,
                                ignore: !0
                            }
                        });
                        return I(z)
                    }
                    )
                }
            }
            return I(x)
        }
        o(u, "withHeadBlocking");
        function d(x, w, C) {
            let I = []
              , L = []
              , k = []
              , F = []
              , z = new Map;
            for (let H of w.children)
                z.set(H.outerHTML, H);
            for (let H of x.children) {
                let f = z.has(H.outerHTML)
                  , Y = C.head.shouldReAppend(H)
                  , Q = C.head.shouldPreserve(H);
                f || Q ? Y ? L.push(H) : (z.delete(H.outerHTML),
                k.push(H)) : C.head.style === "append" ? Y && (L.push(H),
                F.push(H)) : C.head.shouldRemove(H) !== !1 && L.push(H)
            }
            F.push(...z.values());
            let j = [];
            for (let H of F) {
                let f = document.createRange().createContextualFragment(H.outerHTML).firstChild;
                if (C.callbacks.beforeNodeAdded(f) !== !1) {
                    if ("href"in f && f.href || "src"in f && f.src) {
                        let Y, Q = new Promise(function(ot) {
                            Y = ot
                        }
                        );
                        f.addEventListener("load", function() {
                            Y()
                        }),
                        j.push(Q)
                    }
                    x.appendChild(f),
                    C.callbacks.afterNodeAdded(f),
                    I.push(f)
                }
            }
            for (let H of L)
                C.callbacks.beforeNodeRemoved(H) !== !1 && (x.removeChild(H),
                C.callbacks.afterNodeRemoved(H));
            return C.head.afterHeadMorphed(x, {
                added: I,
                kept: k,
                removed: L
            }),
            j
        }
        o(d, "handleHeadElement");
        let p = (function() {
            function x(z, j, H) {
                let {persistentIds: f, idMap: Y} = k(z, j)
                  , Q = w(H)
                  , ot = Q.morphStyle || "outerHTML";
                if (!["innerHTML", "outerHTML"].includes(ot))
                    throw `Do not understand how to morph style ${ot}`;
                return {
                    target: z,
                    newContent: j,
                    config: Q,
                    morphStyle: ot,
                    ignoreActive: Q.ignoreActive,
                    ignoreActiveValue: Q.ignoreActiveValue,
                    restoreFocus: Q.restoreFocus,
                    idMap: Y,
                    persistentIds: f,
                    pantry: C(),
                    callbacks: Q.callbacks,
                    head: Q.head
                }
            }
            o(x, "createMorphContext");
            function w(z) {
                let j = Object.assign({}, t);
                return Object.assign(j, z),
                j.callbacks = Object.assign({}, t.callbacks, z.callbacks),
                j.head = Object.assign({}, t.head, z.head),
                j
            }
            o(w, "mergeDefaults");
            function C() {
                let z = document.createElement("div");
                return z.hidden = !0,
                document.body.insertAdjacentElement("afterend", z),
                z
            }
            o(C, "createPantry");
            function I(z) {
                let j = Array.from(z.querySelectorAll("[id]"));
                return z.id && j.push(z),
                j
            }
            o(I, "findIdElements");
            function L(z, j, H, f) {
                for (let Y of f)
                    if (j.has(Y.id)) {
                        let Q = Y;
                        for (; Q; ) {
                            let ot = z.get(Q);
                            if (ot == null && (ot = new Set,
                            z.set(Q, ot)),
                            ot.add(Y.id),
                            Q === H)
                                break;
                            Q = Q.parentElement
                        }
                    }
            }
            o(L, "populateIdMapWithTree");
            function k(z, j) {
                let H = I(z)
                  , f = I(j)
                  , Y = F(H, f)
                  , Q = new Map;
                L(Q, Y, z, H);
                let ot = j.__idiomorphRoot || j;
                return L(Q, Y, ot, f),
                {
                    persistentIds: Y,
                    idMap: Q
                }
            }
            o(k, "createIdMaps");
            function F(z, j) {
                let H = new Set
                  , f = new Map;
                for (let {id: Q, tagName: ot} of z)
                    f.has(Q) ? H.add(Q) : f.set(Q, ot);
                let Y = new Set;
                for (let {id: Q, tagName: ot} of j)
                    Y.has(Q) ? H.add(Q) : f.get(Q) === ot && Y.add(Q);
                for (let Q of H)
                    Y.delete(Q);
                return Y
            }
            return o(F, "createPersistentIds"),
            x
        }
        )()
          , {normalizeElement: b, normalizeParent: E} = (function() {
            let x = new WeakSet;
            function w(k) {
                return k instanceof Document ? k.documentElement : k
            }
            o(w, "normalizeElement");
            function C(k) {
                if (k == null)
                    return document.createElement("div");
                if (typeof k == "string")
                    return C(L(k));
                if (x.has(k))
                    return k;
                if (k instanceof Node) {
                    if (k.parentNode)
                        return I(k);
                    {
                        let F = document.createElement("div");
                        return F.append(k),
                        F
                    }
                } else {
                    let F = document.createElement("div");
                    for (let z of [...k])
                        F.append(z);
                    return F
                }
            }
            o(C, "normalizeParent");
            function I(k) {
                return {
                    childNodes: [k],
                    querySelectorAll: o(F => {
                        let z = k.querySelectorAll(F);
                        return k.matches(F) ? [k, ...z] : z
                    }
                    , "querySelectorAll"),
                    insertBefore: o( (F, z) => k.parentNode.insertBefore(F, z), "insertBefore"),
                    moveBefore: o( (F, z) => k.parentNode.moveBefore(F, z), "moveBefore"),
                    get __idiomorphRoot() {
                        return k
                    }
                }
            }
            o(I, "createDuckTypedParent");
            function L(k) {
                let F = new DOMParser
                  , z = k.replace(/<svg(\s[^>]*>|>)([\s\S]*?)<\/svg>/gim, "");
                if (z.match(/<\/html>/) || z.match(/<\/head>/) || z.match(/<\/body>/)) {
                    let j = F.parseFromString(k, "text/html");
                    if (z.match(/<\/html>/))
                        return x.add(j),
                        j;
                    {
                        let H = j.firstChild;
                        return H && x.add(H),
                        H
                    }
                } else {
                    let H = F.parseFromString("<body><template>" + k + "</template></body>", "text/html").body.querySelector("template").content;
                    return x.add(H),
                    H
                }
            }
            return o(L, "parseContent"),
            {
                normalizeElement: w,
                normalizeParent: C
            }
        }
        )();
        return {
            morph: e,
            defaults: t
        }
    }
    )();
    function yc(n, t, {callbacks: e, ...s}={}) {
        jv.morph(n, t, {
            ...s,
            callbacks: new ql(e)
        })
    }
    o(yc, "morphElements");
    function Ef(n, t) {
        yc(n, t.childNodes, {
            morphStyle: "innerHTML"
        })
    }
    o(Ef, "morphChildren");
    var ql = class {
        static{o(this, "DefaultIdiomorphCallbacks")
        }#t;
        constructor({beforeNodeMorphed: t}={}) {
            this.#t = t || ( () => !0)
        }
        beforeNodeAdded = o(t => !(t.id && t.hasAttribute("data-turbo-permanent") && document.getElementById(t.id)), "beforeNodeAdded");
        beforeNodeMorphed = o( (t, e) => {
            if (t instanceof Element)
                return !t.hasAttribute("data-turbo-permanent") && this.#t(t, e) ? !ue("turbo:before-morph-element", {
                    cancelable: !0,
                    target: t,
                    detail: {
                        currentElement: t,
                        newElement: e
                    }
                }).defaultPrevented : !1
        }
        , "beforeNodeMorphed");
        beforeAttributeUpdated = o( (t, e, s) => !ue("turbo:before-morph-attribute", {
            cancelable: !0,
            target: e,
            detail: {
                attributeName: t,
                mutationType: s
            }
        }).defaultPrevented, "beforeAttributeUpdated");
        beforeNodeRemoved = o(t => this.beforeNodeMorphed(t), "beforeNodeRemoved");
        afterNodeMorphed = o( (t, e) => {
            t instanceof Element && ue("turbo:morph-element", {
                target: t,
                detail: {
                    currentElement: t,
                    newElement: e
                }
            })
        }
        , "afterNodeMorphed")
    }
      , zl = class extends Xs {
        static{o(this, "MorphingFrameRenderer")
        }static renderElement(t, e) {
            ue("turbo:before-frame-morph", {
                target: t,
                detail: {
                    currentElement: t,
                    newElement: e
                }
            }),
            Ef(t, e)
        }
        async preservingPermanentElements(t) {
            return await t()
        }
    }
      , Ul = class n {
        static{o(this, "ProgressBar")
        }static animationDuration = 300;
        static get defaultCSS() {
            return cf`
      .turbo-progress-bar {
        position: fixed;
        display: block;
        top: 0;
        left: 0;
        height: 3px;
        background: #0076ff;
        z-index: 2147483647;
        transition:
          width ${n.animationDuration}ms ease-out,
          opacity ${n.animationDuration / 2}ms ${n.animationDuration / 2}ms ease-in;
        transform: translate3d(0, 0, 0);
      }
    `
        }
        hiding = !1;
        value = 0;
        visible = !1;
        constructor() {
            this.stylesheetElement = this.createStylesheetElement(),
            this.progressElement = this.createProgressElement(),
            this.installStylesheetElement(),
            this.setValue(0)
        }
        show() {
            this.visible || (this.visible = !0,
            this.installProgressElement(),
            this.startTrickling())
        }
        hide() {
            this.visible && !this.hiding && (this.hiding = !0,
            this.fadeProgressElement( () => {
                this.uninstallProgressElement(),
                this.stopTrickling(),
                this.visible = !1,
                this.hiding = !1
            }
            ))
        }
        setValue(t) {
            this.value = t,
            this.refresh()
        }
        installStylesheetElement() {
            document.head.insertBefore(this.stylesheetElement, document.head.firstChild)
        }
        installProgressElement() {
            this.progressElement.style.width = "0",
            this.progressElement.style.opacity = "1",
            document.documentElement.insertBefore(this.progressElement, document.body),
            this.refresh()
        }
        fadeProgressElement(t) {
            this.progressElement.style.opacity = "0",
            setTimeout(t, n.animationDuration * 1.5)
        }
        uninstallProgressElement() {
            this.progressElement.parentNode && document.documentElement.removeChild(this.progressElement)
        }
        startTrickling() {
            this.trickleInterval || (this.trickleInterval = window.setInterval(this.trickle, n.animationDuration))
        }
        stopTrickling() {
            window.clearInterval(this.trickleInterval),
            delete this.trickleInterval
        }
        trickle = o( () => {
            this.setValue(this.value + Math.random() / 100)
        }
        , "trickle");
        refresh() {
            requestAnimationFrame( () => {
                this.progressElement.style.width = `${10 + this.value * 90}%`
            }
            )
        }
        createStylesheetElement() {
            let t = document.createElement("style");
            t.type = "text/css",
            t.textContent = n.defaultCSS;
            let e = hf();
            return e && (t.nonce = e),
            t
        }
        createProgressElement() {
            let t = document.createElement("div");
            return t.className = "turbo-progress-bar",
            t
        }
    }
      , Kl = class extends Ys {
        static{o(this, "HeadSnapshot")
        }detailsByOuterHTML = this.children.filter(t => !zv(t)).map(t => Yv(t)).reduce( (t, e) => {
            let {outerHTML: s} = e
              , r = s in t ? t[s] : {
                type: Wv(e),
                tracked: $v(e),
                elements: []
            };
            return {
                ...t,
                [s]: {
                    ...r,
                    elements: [...r.elements, e]
                }
            }
        }
        , {});
        get trackedElementSignature() {
            return Object.keys(this.detailsByOuterHTML).filter(t => this.detailsByOuterHTML[t].tracked).join("")
        }
        getScriptElementsNotInSnapshot(t) {
            return this.getElementsMatchingTypeNotInSnapshot("script", t)
        }
        getStylesheetElementsNotInSnapshot(t) {
            return this.getElementsMatchingTypeNotInSnapshot("stylesheet", t)
        }
        getElementsMatchingTypeNotInSnapshot(t, e) {
            return Object.keys(this.detailsByOuterHTML).filter(s => !(s in e.detailsByOuterHTML)).map(s => this.detailsByOuterHTML[s]).filter( ({type: s}) => s == t).map( ({elements: [s]}) => s)
        }
        get provisionalElements() {
            return Object.keys(this.detailsByOuterHTML).reduce( (t, e) => {
                let {type: s, tracked: r, elements: a} = this.detailsByOuterHTML[e];
                return s == null && !r ? [...t, ...a] : a.length > 1 ? [...t, ...a.slice(1)] : t
            }
            , [])
        }
        getMetaValue(t) {
            let e = this.findMetaElementByName(t);
            return e ? e.getAttribute("content") : null
        }
        findMetaElementByName(t) {
            return Object.keys(this.detailsByOuterHTML).reduce( (e, s) => {
                let {elements: [r]} = this.detailsByOuterHTML[s];
                return Kv(r, t) ? r : e
            }
            , void 0 | void 0)
        }
    }
    ;
    function Wv(n) {
        if (qv(n))
            return "script";
        if (Uv(n))
            return "stylesheet"
    }
    o(Wv, "elementType");
    function $v(n) {
        return n.getAttribute("data-turbo-track") == "reload"
    }
    o($v, "elementIsTracked");
    function qv(n) {
        return n.localName == "script"
    }
    o(qv, "elementIsScript");
    function zv(n) {
        return n.localName == "noscript"
    }
    o(zv, "elementIsNoscript");
    function Uv(n) {
        let t = n.localName;
        return t == "style" || t == "link" && n.getAttribute("rel") == "stylesheet"
    }
    o(Uv, "elementIsStylesheet");
    function Kv(n, t) {
        return n.localName == "meta" && n.getAttribute("name") == t
    }
    o(Kv, "elementIsMetaElementWithName");
    function Yv(n) {
        return n.hasAttribute("nonce") && n.setAttribute("nonce", ""),
        n
    }
    o(Yv, "elementWithoutNonce");
    var vi = class n extends Ys {
        static{o(this, "PageSnapshot")
        }static fromHTMLString(t="") {
            return this.fromDocument(lf(t))
        }
        static fromElement(t) {
            return this.fromDocument(t.ownerDocument)
        }
        static fromDocument({documentElement: t, body: e, head: s}) {
            return new this(t,e,new Kl(s))
        }
        constructor(t, e, s) {
            super(e),
            this.documentElement = t,
            this.headSnapshot = s
        }
        clone() {
            let t = this.element.cloneNode(!0)
              , e = this.element.querySelectorAll("select")
              , s = t.querySelectorAll("select");
            for (let[r,a] of e.entries()) {
                let l = s[r];
                for (let u of l.selectedOptions)
                    u.selected = !1;
                for (let u of a.selectedOptions)
                    l.options[u.index].selected = !0
            }
            for (let r of t.querySelectorAll('input[type="password"]'))
                r.value = "";
            return new n(this.documentElement,t,this.headSnapshot)
        }
        get lang() {
            return this.documentElement.getAttribute("lang")
        }
        get headElement() {
            return this.headSnapshot.element
        }
        get rootLocation() {
            let t = this.getSetting("root") ?? "/";
            return Te(t)
        }
        get cacheControlValue() {
            return this.getSetting("cache-control")
        }
        get isPreviewable() {
            return this.cacheControlValue != "no-preview"
        }
        get isCacheable() {
            return this.cacheControlValue != "no-cache"
        }
        get isVisitable() {
            return this.getSetting("visit-control") != "reload"
        }
        get prefersViewTransitions() {
            return this.headSnapshot.getMetaValue("view-transition") === "same-origin"
        }
        get shouldMorphPage() {
            return this.getSetting("refresh-method") === "morph"
        }
        get shouldPreserveScrollPosition() {
            return this.getSetting("refresh-scroll") === "preserve"
        }
        getSetting(t) {
            return this.headSnapshot.getMetaValue(`turbo-${t}`)
        }
    }
      , Yl = class {
        static{o(this, "ViewTransitioner")
        }#t = !1;
        #e = Promise.resolve();
        renderChange(t, e) {
            return t && this.viewTransitionsAvailable && !this.#t ? (this.#t = !0,
            this.#e = this.#e.then(async () => {
                await document.startViewTransition(e).finished
            }
            )) : this.#e = this.#e.then(e),
            this.#e
        }
        get viewTransitionsAvailable() {
            return document.startViewTransition
        }
    }
      , Xv = {
        action: "advance",
        historyChanged: !1,
        visitCachedSnapshot: o( () => {}
        , "visitCachedSnapshot"),
        willRender: !0,
        updateHistory: !0,
        shouldCacheSnapshot: !0,
        acceptsStreamResponse: !1
    }
      , na = {
        visitStart: "visitStart",
        requestStart: "requestStart",
        requestEnd: "requestEnd",
        visitEnd: "visitEnd"
    }
      , hn = {
        initialized: "initialized",
        started: "started",
        canceled: "canceled",
        failed: "failed",
        completed: "completed"
    }
      , Us = {
        networkFailure: 0,
        timeoutFailure: -1,
        contentTypeMismatch: -2
    }
      , Gv = {
        advance: "forward",
        restore: "back",
        replace: "none"
    }
      , Xl = class {
        static{o(this, "Visit")
        }identifier = Ln();
        timingMetrics = {};
        followedRedirect = !1;
        historyChanged = !1;
        scrolled = !1;
        shouldCacheSnapshot = !0;
        acceptsStreamResponse = !1;
        snapshotCached = !1;
        state = hn.initialized;
        viewTransitioner = new Yl;
        constructor(t, e, s, r={}) {
            this.delegate = t,
            this.location = e,
            this.restorationIdentifier = s || Ln();
            let {action: a, historyChanged: l, referrer: u, snapshot: d, snapshotHTML: p, response: b, visitCachedSnapshot: E, willRender: x, updateHistory: w, shouldCacheSnapshot: C, acceptsStreamResponse: I, direction: L} = {
                ...Xv,
                ...r
            };
            this.action = a,
            this.historyChanged = l,
            this.referrer = u,
            this.snapshot = d,
            this.snapshotHTML = p,
            this.response = b,
            this.isSamePage = this.delegate.locationWithActionIsSamePage(this.location, this.action),
            this.isPageRefresh = this.view.isPageRefresh(this),
            this.visitCachedSnapshot = E,
            this.willRender = x,
            this.updateHistory = w,
            this.scrolled = !x,
            this.shouldCacheSnapshot = C,
            this.acceptsStreamResponse = I,
            this.direction = L || Gv[a]
        }
        get adapter() {
            return this.delegate.adapter
        }
        get view() {
            return this.delegate.view
        }
        get history() {
            return this.delegate.history
        }
        get restorationData() {
            return this.history.getRestorationDataForIdentifier(this.restorationIdentifier)
        }
        get silent() {
            return this.isSamePage
        }
        start() {
            this.state == hn.initialized && (this.recordTimingMetric(na.visitStart),
            this.state = hn.started,
            this.adapter.visitStarted(this),
            this.delegate.visitStarted(this))
        }
        cancel() {
            this.state == hn.started && (this.request && this.request.cancel(),
            this.cancelRender(),
            this.state = hn.canceled)
        }
        complete() {
            this.state == hn.started && (this.recordTimingMetric(na.visitEnd),
            this.adapter.visitCompleted(this),
            this.state = hn.completed,
            this.followRedirect(),
            this.followedRedirect || this.delegate.visitCompleted(this))
        }
        fail() {
            this.state == hn.started && (this.state = hn.failed,
            this.adapter.visitFailed(this),
            this.delegate.visitCompleted(this))
        }
        changeHistory() {
            if (!this.historyChanged && this.updateHistory) {
                let t = this.location.href === this.referrer?.href ? "replace" : this.action
                  , e = uf(t);
                this.history.update(e, this.location, this.restorationIdentifier),
                this.historyChanged = !0
            }
        }
        issueRequest() {
            this.hasPreloadedResponse() ? this.simulateRequest() : this.shouldIssueRequest() && !this.request && (this.request = new Dn(this,ni.get,this.location),
            this.request.perform())
        }
        simulateRequest() {
            this.response && (this.startRequest(),
            this.recordResponse(),
            this.finishRequest())
        }
        startRequest() {
            this.recordTimingMetric(na.requestStart),
            this.adapter.visitRequestStarted(this)
        }
        recordResponse(t=this.response) {
            if (this.response = t,
            t) {
                let {statusCode: e} = t;
                Zd(e) ? this.adapter.visitRequestCompleted(this) : this.adapter.visitRequestFailedWithStatusCode(this, e)
            }
        }
        finishRequest() {
            this.recordTimingMetric(na.requestEnd),
            this.adapter.visitRequestFinished(this)
        }
        loadResponse() {
            if (this.response) {
                let {statusCode: t, responseHTML: e} = this.response;
                this.render(async () => {
                    if (this.shouldCacheSnapshot && this.cacheSnapshot(),
                    this.view.renderPromise && await this.view.renderPromise,
                    Zd(t) && e != null) {
                        let s = vi.fromHTMLString(e);
                        await this.renderPageSnapshot(s, !1),
                        this.adapter.visitRendered(this),
                        this.complete()
                    } else
                        await this.view.renderError(vi.fromHTMLString(e), this),
                        this.adapter.visitRendered(this),
                        this.fail()
                }
                )
            }
        }
        getCachedSnapshot() {
            let t = this.view.getCachedSnapshotForLocation(this.location) || this.getPreloadedSnapshot();
            if (t && (!ls(this.location) || t.hasAnchor(ls(this.location))) && (this.action == "restore" || t.isPreviewable))
                return t
        }
        getPreloadedSnapshot() {
            if (this.snapshotHTML)
                return vi.fromHTMLString(this.snapshotHTML)
        }
        hasCachedSnapshot() {
            return this.getCachedSnapshot() != null
        }
        loadCachedSnapshot() {
            let t = this.getCachedSnapshot();
            if (t) {
                let e = this.shouldIssueRequest();
                this.render(async () => {
                    this.cacheSnapshot(),
                    this.isSamePage || this.isPageRefresh ? this.adapter.visitRendered(this) : (this.view.renderPromise && await this.view.renderPromise,
                    await this.renderPageSnapshot(t, e),
                    this.adapter.visitRendered(this),
                    e || this.complete())
                }
                )
            }
        }
        followRedirect() {
            this.redirectedToLocation && !this.followedRedirect && this.response?.redirected && (this.adapter.visitProposedToLocation(this.redirectedToLocation, {
                action: "replace",
                response: this.response,
                shouldCacheSnapshot: !1,
                willRender: !1
            }),
            this.followedRedirect = !0)
        }
        goToSamePageAnchor() {
            this.isSamePage && this.render(async () => {
                this.cacheSnapshot(),
                this.performScroll(),
                this.changeHistory(),
                this.adapter.visitRendered(this)
            }
            )
        }
        prepareRequest(t) {
            this.acceptsStreamResponse && t.acceptResponseType(Pn.contentType)
        }
        requestStarted() {
            this.startRequest()
        }
        requestPreventedHandlingResponse(t, e) {}
        async requestSucceededWithResponse(t, e) {
            let s = await e.responseHTML
              , {redirected: r, statusCode: a} = e;
            s == null ? this.recordResponse({
                statusCode: Us.contentTypeMismatch,
                redirected: r
            }) : (this.redirectedToLocation = e.redirected ? e.location : void 0,
            this.recordResponse({
                statusCode: a,
                responseHTML: s,
                redirected: r
            }))
        }
        async requestFailedWithResponse(t, e) {
            let s = await e.responseHTML
              , {redirected: r, statusCode: a} = e;
            s == null ? this.recordResponse({
                statusCode: Us.contentTypeMismatch,
                redirected: r
            }) : this.recordResponse({
                statusCode: a,
                responseHTML: s,
                redirected: r
            })
        }
        requestErrored(t, e) {
            this.recordResponse({
                statusCode: Us.networkFailure,
                redirected: !1
            })
        }
        requestFinished() {
            this.finishRequest()
        }
        performScroll() {
            !this.scrolled && !this.view.forceReloaded && !this.view.shouldPreserveScrollPosition(this) && (this.action == "restore" ? this.scrollToRestoredPosition() || this.scrollToAnchor() || this.view.scrollToTop() : this.scrollToAnchor() || this.view.scrollToTop(),
            this.isSamePage && this.delegate.visitScrolledToSamePageLocation(this.view.lastRenderedLocation, this.location),
            this.scrolled = !0)
        }
        scrollToRestoredPosition() {
            let {scrollPosition: t} = this.restorationData;
            if (t)
                return this.view.scrollToPosition(t),
                !0
        }
        scrollToAnchor() {
            let t = ls(this.location);
            if (t != null)
                return this.view.scrollToAnchor(t),
                !0
        }
        recordTimingMetric(t) {
            this.timingMetrics[t] = new Date().getTime()
        }
        getTimingMetrics() {
            return {
                ...this.timingMetrics
            }
        }
        hasPreloadedResponse() {
            return typeof this.response == "object"
        }
        shouldIssueRequest() {
            return this.isSamePage ? !1 : this.action == "restore" ? !this.hasCachedSnapshot() : this.willRender
        }
        cacheSnapshot() {
            this.snapshotCached || (this.view.cacheSnapshot(this.snapshot).then(t => t && this.visitCachedSnapshot(t)),
            this.snapshotCached = !0)
        }
        async render(t) {
            this.cancelRender(),
            await new Promise(e => {
                this.frame = document.visibilityState === "hidden" ? setTimeout( () => e(), 0) : requestAnimationFrame( () => e())
            }
            ),
            await t(),
            delete this.frame
        }
        async renderPageSnapshot(t, e) {
            await this.viewTransitioner.renderChange(this.view.shouldTransitionTo(t), async () => {
                await this.view.renderPage(t, e, this.willRender, this),
                this.performScroll()
            }
            )
        }
        cancelRender() {
            this.frame && (cancelAnimationFrame(this.frame),
            delete this.frame)
        }
    }
    ;
    function Zd(n) {
        return n >= 200 && n < 300
    }
    o(Zd, "isSuccessful");
    var Gl = class {
        static{o(this, "BrowserAdapter")
        }progressBar = new Ul;
        constructor(t) {
            this.session = t
        }
        visitProposedToLocation(t, e) {
            Mn(t, this.navigator.rootLocation) ? this.navigator.startVisit(t, e?.restorationIdentifier || Ln(), e) : window.location.href = t.toString()
        }
        visitStarted(t) {
            this.location = t.location,
            t.loadCachedSnapshot(),
            t.issueRequest(),
            t.goToSamePageAnchor()
        }
        visitRequestStarted(t) {
            this.progressBar.setValue(0),
            t.hasCachedSnapshot() || t.action != "restore" ? this.showVisitProgressBarAfterDelay() : this.showProgressBar()
        }
        visitRequestCompleted(t) {
            t.loadResponse()
        }
        visitRequestFailedWithStatusCode(t, e) {
            switch (e) {
            case Us.networkFailure:
            case Us.timeoutFailure:
            case Us.contentTypeMismatch:
                return this.reload({
                    reason: "request_failed",
                    context: {
                        statusCode: e
                    }
                });
            default:
                return t.loadResponse()
            }
        }
        visitRequestFinished(t) {}
        visitCompleted(t) {
            this.progressBar.setValue(1),
            this.hideVisitProgressBar()
        }
        pageInvalidated(t) {
            this.reload(t)
        }
        visitFailed(t) {
            this.progressBar.setValue(1),
            this.hideVisitProgressBar()
        }
        visitRendered(t) {}
        linkPrefetchingIsEnabledForLocation(t) {
            return !0
        }
        formSubmissionStarted(t) {
            this.progressBar.setValue(0),
            this.showFormProgressBarAfterDelay()
        }
        formSubmissionFinished(t) {
            this.progressBar.setValue(1),
            this.hideFormProgressBar()
        }
        showVisitProgressBarAfterDelay() {
            this.visitProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay)
        }
        hideVisitProgressBar() {
            this.progressBar.hide(),
            this.visitProgressBarTimeout != null && (window.clearTimeout(this.visitProgressBarTimeout),
            delete this.visitProgressBarTimeout)
        }
        showFormProgressBarAfterDelay() {
            this.formProgressBarTimeout == null && (this.formProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay))
        }
        hideFormProgressBar() {
            this.progressBar.hide(),
            this.formProgressBarTimeout != null && (window.clearTimeout(this.formProgressBarTimeout),
            delete this.formProgressBarTimeout)
        }
        showProgressBar = o( () => {
            this.progressBar.show()
        }
        , "showProgressBar");
        reload(t) {
            ue("turbo:reload", {
                detail: t
            }),
            window.location.href = this.location?.toString() || window.location.href
        }
        get navigator() {
            return this.session.navigator
        }
    }
      , Ql = class {
        static{o(this, "CacheObserver")
        }selector = "[data-turbo-temporary]";
        deprecatedSelector = "[data-turbo-cache=false]";
        started = !1;
        start() {
            this.started || (this.started = !0,
            addEventListener("turbo:before-cache", this.removeTemporaryElements, !1))
        }
        stop() {
            this.started && (this.started = !1,
            removeEventListener("turbo:before-cache", this.removeTemporaryElements, !1))
        }
        removeTemporaryElements = o(t => {
            for (let e of this.temporaryElements)
                e.remove()
        }
        , "removeTemporaryElements");
        get temporaryElements() {
            return [...document.querySelectorAll(this.selector), ...this.temporaryElementsWithDeprecation]
        }
        get temporaryElementsWithDeprecation() {
            let t = document.querySelectorAll(this.deprecatedSelector);
            return t.length && console.warn(`The ${this.deprecatedSelector} selector is deprecated and will be removed in a future version. Use ${this.selector} instead.`),
            [...t]
        }
    }
      , Jl = class {
        static{o(this, "FrameRedirector")
        }constructor(t, e) {
            this.session = t,
            this.element = e,
            this.linkInterceptor = new ua(this,e),
            this.formSubmitObserver = new Qr(this,e)
        }
        start() {
            this.linkInterceptor.start(),
            this.formSubmitObserver.start()
        }
        stop() {
            this.linkInterceptor.stop(),
            this.formSubmitObserver.stop()
        }
        shouldInterceptLinkClick(t, e, s) {
            return this.#e(t)
        }
        linkClickIntercepted(t, e, s) {
            let r = this.#i(t);
            r && r.delegate.linkClickIntercepted(t, e, s)
        }
        willSubmitForm(t, e) {
            return t.closest("turbo-frame") == null && this.#t(t, e) && this.#e(t, e)
        }
        formSubmitted(t, e) {
            let s = this.#i(t, e);
            s && s.delegate.formSubmitted(t, e)
        }
        #t(t, e) {
            let s = vc(t, e)
              , r = this.element.ownerDocument.querySelector('meta[name="turbo-root"]')
              , a = Te(r?.content ?? "/");
            return this.#e(t, e) && Mn(s, a)
        }
        #e(t, e) {
            if (t instanceof HTMLFormElement ? this.session.submissionIsNavigatable(t, e) : this.session.elementIsNavigatable(t)) {
                let r = this.#i(t, e);
                return r ? r != t.closest("turbo-frame") : !1
            } else
                return !1
        }
        #i(t, e) {
            let s = e?.getAttribute("data-turbo-frame") || t.getAttribute("data-turbo-frame");
            if (s && s != "_top") {
                let r = this.element.querySelector(`#${s}:not([disabled])`);
                if (r instanceof bi)
                    return r
            }
        }
    }
      , Zl = class {
        static{o(this, "History")
        }location;
        restorationIdentifier = Ln();
        restorationData = {};
        started = !1;
        pageLoaded = !1;
        currentIndex = 0;
        constructor(t) {
            this.delegate = t
        }
        start() {
            this.started || (addEventListener("popstate", this.onPopState, !1),
            addEventListener("load", this.onPageLoad, !1),
            this.currentIndex = history.state?.turbo?.restorationIndex || 0,
            this.started = !0,
            this.replace(new URL(window.location.href)))
        }
        stop() {
            this.started && (removeEventListener("popstate", this.onPopState, !1),
            removeEventListener("load", this.onPageLoad, !1),
            this.started = !1)
        }
        push(t, e) {
            this.update(history.pushState, t, e)
        }
        replace(t, e) {
            this.update(history.replaceState, t, e)
        }
        update(t, e, s=Ln()) {
            t === history.pushState && ++this.currentIndex;
            let r = {
                turbo: {
                    restorationIdentifier: s,
                    restorationIndex: this.currentIndex
                }
            };
            t.call(history, r, "", e.href),
            this.location = e,
            this.restorationIdentifier = s
        }
        getRestorationDataForIdentifier(t) {
            return this.restorationData[t] || {}
        }
        updateRestorationData(t) {
            let {restorationIdentifier: e} = this
              , s = this.restorationData[e];
            this.restorationData[e] = {
                ...s,
                ...t
            }
        }
        assumeControlOfScrollRestoration() {
            this.previousScrollRestoration || (this.previousScrollRestoration = history.scrollRestoration ?? "auto",
            history.scrollRestoration = "manual")
        }
        relinquishControlOfScrollRestoration() {
            this.previousScrollRestoration && (history.scrollRestoration = this.previousScrollRestoration,
            delete this.previousScrollRestoration)
        }
        onPopState = o(t => {
            if (this.shouldHandlePopState()) {
                let {turbo: e} = t.state || {};
                if (e) {
                    this.location = new URL(window.location.href);
                    let {restorationIdentifier: s, restorationIndex: r} = e;
                    this.restorationIdentifier = s;
                    let a = r > this.currentIndex ? "forward" : "back";
                    this.delegate.historyPoppedToLocationWithRestorationIdentifierAndDirection(this.location, s, a),
                    this.currentIndex = r
                }
            }
        }
        , "onPopState");
        onPageLoad = o(async t => {
            await av(),
            this.pageLoaded = !0
        }
        , "onPageLoad");
        shouldHandlePopState() {
            return this.pageIsLoaded()
        }
        pageIsLoaded() {
            return this.pageLoaded || document.readyState == "complete"
        }
    }
      , tc = class {
        static{o(this, "LinkPrefetchObserver")
        }started = !1;
        #t = null;
        constructor(t, e) {
            this.delegate = t,
            this.eventTarget = e
        }
        start() {
            this.started || (this.eventTarget.readyState === "loading" ? this.eventTarget.addEventListener("DOMContentLoaded", this.#e, {
                once: !0
            }) : this.#e())
        }
        stop() {
            this.started && (this.eventTarget.removeEventListener("mouseenter", this.#i, {
                capture: !0,
                passive: !0
            }),
            this.eventTarget.removeEventListener("mouseleave", this.#r, {
                capture: !0,
                passive: !0
            }),
            this.eventTarget.removeEventListener("turbo:before-fetch-request", this.#s, !0),
            this.started = !1)
        }
        #e = o( () => {
            this.eventTarget.addEventListener("mouseenter", this.#i, {
                capture: !0,
                passive: !0
            }),
            this.eventTarget.addEventListener("mouseleave", this.#r, {
                capture: !0,
                passive: !0
            }),
            this.eventTarget.addEventListener("turbo:before-fetch-request", this.#s, !0),
            this.started = !0
        }
        , "#enable");
        #i = o(t => {
            if (aa("turbo-prefetch") === "false")
                return;
            let e = t.target;
            if (e.matches && e.matches("a[href]:not([target^=_]):not([download])") && this.#l(e)) {
                let r = e
                  , a = gf(r);
                if (this.delegate.canPrefetchRequestToLocation(r, a)) {
                    this.#t = r;
                    let l = new Dn(this,ni.get,a,new URLSearchParams,e);
                    qs.setLater(a.toString(), l, this.#n)
                }
            }
        }
        , "#tryToPrefetchRequest");
        #r = o(t => {
            t.target === this.#t && this.#o()
        }
        , "#cancelRequestIfObsolete");
        #o = o( () => {
            qs.clear(),
            this.#t = null
        }
        , "#cancelPrefetchRequest");
        #s = o(t => {
            if (t.target.tagName !== "FORM" && t.detail.fetchOptions.method === "GET") {
                let e = qs.get(t.detail.url.toString());
                e && (t.detail.fetchRequest = e),
                qs.clear()
            }
        }
        , "#tryToUsePrefetchedRequest");
        prepareRequest(t) {
            let e = t.target;
            t.headers["X-Sec-Purpose"] = "prefetch";
            let s = e.closest("turbo-frame")
              , r = e.getAttribute("data-turbo-frame") || s?.getAttribute("target") || s?.id;
            r && r !== "_top" && (t.headers["Turbo-Frame"] = r)
        }
        requestSucceededWithResponse() {}
        requestStarted(t) {}
        requestErrored(t) {}
        requestFinished(t) {}
        requestPreventedHandlingResponse(t, e) {}
        requestFailedWithResponse(t, e) {}
        get #n() {
            return Number(aa("turbo-prefetch-cache-time")) || kv
        }
        #l(t) {
            return !(!t.getAttribute("href") || Qv(t) || Jv(t) || Zv(t) || tb(t) || ib(t))
        }
    }
      , Qv = o(n => n.origin !== document.location.origin || !["http:", "https:"].includes(n.protocol) || n.hasAttribute("target"), "unfetchableLink")
      , Jv = o(n => n.pathname + n.search === document.location.pathname + document.location.search || n.href.startsWith("#"), "linkToTheSamePage")
      , Zv = o(n => {
        if (n.getAttribute("data-turbo-prefetch") === "false" || n.getAttribute("data-turbo") === "false")
            return !0;
        let t = zs(n, "[data-turbo-prefetch]");
        return !!(t && t.getAttribute("data-turbo-prefetch") === "false")
    }
    , "linkOptsOut")
      , tb = o(n => {
        let t = n.getAttribute("data-turbo-method");
        return !!(t && t.toLowerCase() !== "get" || eb(n) || n.hasAttribute("data-turbo-confirm") || n.hasAttribute("data-turbo-stream"))
    }
    , "nonSafeLink")
      , eb = o(n => n.hasAttribute("data-remote") || n.hasAttribute("data-behavior") || n.hasAttribute("data-confirm") || n.hasAttribute("data-method"), "isUJS")
      , ib = o(n => ue("turbo:before-prefetch", {
        target: n,
        cancelable: !0
    }).defaultPrevented, "eventPrevented")
      , ec = class {
        static{o(this, "Navigator")
        }constructor(t) {
            this.delegate = t
        }
        proposeVisit(t, e={}) {
            this.delegate.allowsVisitingLocationWithAction(t, e.action) && this.delegate.visitProposedToLocation(t, e)
        }
        startVisit(t, e, s={}) {
            this.stop(),
            this.currentVisit = new Xl(this,Te(t),e,{
                referrer: this.location,
                ...s
            }),
            this.currentVisit.start()
        }
        submitForm(t, e) {
            this.stop(),
            this.formSubmission = new la(this,t,e,!0),
            this.formSubmission.start()
        }
        stop() {
            this.formSubmission && (this.formSubmission.stop(),
            delete this.formSubmission),
            this.currentVisit && (this.currentVisit.cancel(),
            delete this.currentVisit)
        }
        get adapter() {
            return this.delegate.adapter
        }
        get view() {
            return this.delegate.view
        }
        get rootLocation() {
            return this.view.snapshot.rootLocation
        }
        get history() {
            return this.delegate.history
        }
        formSubmissionStarted(t) {
            typeof this.adapter.formSubmissionStarted == "function" && this.adapter.formSubmissionStarted(t)
        }
        async formSubmissionSucceededWithResponse(t, e) {
            if (t == this.formSubmission) {
                let s = await e.responseHTML;
                if (s) {
                    let r = t.isSafe;
                    r || this.view.clearSnapshotCache();
                    let {statusCode: a, redirected: l} = e
                      , d = {
                        action: this.#t(t, e),
                        shouldCacheSnapshot: r,
                        response: {
                            statusCode: a,
                            responseHTML: s,
                            redirected: l
                        }
                    };
                    this.proposeVisit(e.location, d)
                }
            }
        }
        async formSubmissionFailedWithResponse(t, e) {
            let s = await e.responseHTML;
            if (s) {
                let r = vi.fromHTMLString(s);
                e.serverError ? await this.view.renderError(r, this.currentVisit) : await this.view.renderPage(r, !1, !0, this.currentVisit),
                r.shouldPreserveScrollPosition || this.view.scrollToTop(),
                this.view.clearSnapshotCache()
            }
        }
        formSubmissionErrored(t, e) {
            console.error(e)
        }
        formSubmissionFinished(t) {
            typeof this.adapter.formSubmissionFinished == "function" && this.adapter.formSubmissionFinished(t)
        }
        linkPrefetchingIsEnabledForLocation(t) {
            return typeof this.adapter.linkPrefetchingIsEnabledForLocation == "function" ? this.adapter.linkPrefetchingIsEnabledForLocation(t) : !0
        }
        visitStarted(t) {
            this.delegate.visitStarted(t)
        }
        visitCompleted(t) {
            this.delegate.visitCompleted(t),
            delete this.currentVisit
        }
        locationWithActionIsSamePage(t, e) {
            let s = ls(t)
              , r = ls(this.view.lastRenderedLocation)
              , a = e === "restore" && typeof s > "u";
            return e !== "replace" && Bl(t) === Bl(this.view.lastRenderedLocation) && (a || s != null && s !== r)
        }
        visitScrolledToSamePageLocation(t, e) {
            this.delegate.visitScrolledToSamePageLocation(t, e)
        }
        get location() {
            return this.history.location
        }
        get restorationIdentifier() {
            return this.history.restorationIdentifier
        }
        #t(t, e) {
            let {submitter: s, formElement: r} = t;
            return as(s, r) || this.#e(e)
        }
        #e(t) {
            return t.redirected && t.location.href === this.location?.href ? "replace" : "advance"
        }
    }
      , rs = {
        initial: 0,
        loading: 1,
        interactive: 2,
        complete: 3
    }
      , ic = class {
        static{o(this, "PageObserver")
        }stage = rs.initial;
        started = !1;
        constructor(t) {
            this.delegate = t
        }
        start() {
            this.started || (this.stage == rs.initial && (this.stage = rs.loading),
            document.addEventListener("readystatechange", this.interpretReadyState, !1),
            addEventListener("pagehide", this.pageWillUnload, !1),
            this.started = !0)
        }
        stop() {
            this.started && (document.removeEventListener("readystatechange", this.interpretReadyState, !1),
            removeEventListener("pagehide", this.pageWillUnload, !1),
            this.started = !1)
        }
        interpretReadyState = o( () => {
            let {readyState: t} = this;
            t == "interactive" ? this.pageIsInteractive() : t == "complete" && this.pageIsComplete()
        }
        , "interpretReadyState");
        pageIsInteractive() {
            this.stage == rs.loading && (this.stage = rs.interactive,
            this.delegate.pageBecameInteractive())
        }
        pageIsComplete() {
            this.pageIsInteractive(),
            this.stage == rs.interactive && (this.stage = rs.complete,
            this.delegate.pageLoaded())
        }
        pageWillUnload = o( () => {
            this.delegate.pageWillUnload()
        }
        , "pageWillUnload");
        get readyState() {
            return document.readyState
        }
    }
      , nc = class {
        static{o(this, "ScrollObserver")
        }started = !1;
        constructor(t) {
            this.delegate = t
        }
        start() {
            this.started || (addEventListener("scroll", this.onScroll, !1),
            this.onScroll(),
            this.started = !0)
        }
        stop() {
            this.started && (removeEventListener("scroll", this.onScroll, !1),
            this.started = !1)
        }
        onScroll = o( () => {
            this.updatePosition({
                x: window.pageXOffset,
                y: window.pageYOffset
            })
        }
        , "onScroll");
        updatePosition(t) {
            this.delegate.scrollPositionChanged(t)
        }
    }
      , sc = class {
        static{o(this, "StreamMessageRenderer")
        }render({fragment: t}) {
            fa.preservingPermanentElements(this, nb(t), () => {
                sb(t, () => {
                    rb( () => {
                        document.documentElement.appendChild(t)
                    }
                    )
                }
                )
            }
            )
        }
        enteringBardo(t, e) {
            e.replaceWith(t.cloneNode(!0))
        }
        leavingBardo() {}
    }
    ;
    function nb(n) {
        let t = _f(document.documentElement)
          , e = {};
        for (let s of t) {
            let {id: r} = s;
            for (let a of n.querySelectorAll("turbo-stream")) {
                let l = yf(a.templateElement.content, r);
                l && (e[r] = [s, l])
            }
        }
        return e
    }
    o(nb, "getPermanentElementMapForFragment");
    async function sb(n, t) {
        let e = `turbo-stream-autofocus-${Ln()}`
          , s = n.querySelectorAll("turbo-stream")
          , r = ob(s)
          , a = null;
        if (r && (r.id ? a = r.id : a = e,
        r.id = a),
        t(),
        await Xr(),
        (document.activeElement == null || document.activeElement == document.body) && a) {
            let u = document.getElementById(a);
            mc(u) && u.focus(),
            u && u.id == e && u.removeAttribute("id")
        }
    }
    o(sb, "withAutofocusFromFragment");
    async function rb(n) {
        let[t,e] = await fv(n, () => document.activeElement)
          , s = t && t.id;
        if (s) {
            let r = document.getElementById(s);
            mc(r) && r != e && r.focus()
        }
    }
    o(rb, "withPreservedFocus");
    function ob(n) {
        for (let t of n) {
            let e = df(t.templateElement.content);
            if (e)
                return e
        }
        return null
    }
    o(ob, "firstAutofocusableElementInStreams");
    var rc = class {
        static{o(this, "StreamObserver")
        }sources = new Set;
        #t = !1;
        constructor(t) {
            this.delegate = t
        }
        start() {
            this.#t || (this.#t = !0,
            addEventListener("turbo:before-fetch-response", this.inspectFetchResponse, !1))
        }
        stop() {
            this.#t && (this.#t = !1,
            removeEventListener("turbo:before-fetch-response", this.inspectFetchResponse, !1))
        }
        connectStreamSource(t) {
            this.streamSourceIsConnected(t) || (this.sources.add(t),
            t.addEventListener("message", this.receiveMessageEvent, !1))
        }
        disconnectStreamSource(t) {
            this.streamSourceIsConnected(t) && (this.sources.delete(t),
            t.removeEventListener("message", this.receiveMessageEvent, !1))
        }
        streamSourceIsConnected(t) {
            return this.sources.has(t)
        }
        inspectFetchResponse = o(t => {
            let e = ab(t);
            e && lb(e) && (t.preventDefault(),
            this.receiveMessageResponse(e))
        }
        , "inspectFetchResponse");
        receiveMessageEvent = o(t => {
            this.#t && typeof t.data == "string" && this.receiveMessageHTML(t.data)
        }
        , "receiveMessageEvent");
        async receiveMessageResponse(t) {
            let e = await t.responseHTML;
            e && this.receiveMessageHTML(e)
        }
        receiveMessageHTML(t) {
            this.delegate.receivedMessageFromStream(Pn.wrap(t))
        }
    }
    ;
    function ab(n) {
        let t = n.detail?.fetchResponse;
        if (t instanceof Ks)
            return t
    }
    o(ab, "fetchResponseFromEvent");
    function lb(n) {
        return (n.contentType ?? "").startsWith(Pn.contentType)
    }
    o(lb, "fetchResponseIsStream");
    var oc = class extends Jr {
        static{o(this, "ErrorRenderer")
        }static renderElement(t, e) {
            let {documentElement: s, body: r} = document;
            s.replaceChild(e, r)
        }
        async render() {
            this.replaceHeadAndBody(),
            this.activateScriptElements()
        }
        replaceHeadAndBody() {
            let {documentElement: t, head: e} = document;
            t.replaceChild(this.newHead, e),
            this.renderElement(this.currentElement, this.newElement)
        }
        activateScriptElements() {
            for (let t of this.scriptElements) {
                let e = t.parentNode;
                if (e) {
                    let s = Gr(t);
                    e.replaceChild(s, t)
                }
            }
        }
        get newHead() {
            return this.newSnapshot.headSnapshot.element
        }
        get scriptElements() {
            return document.documentElement.querySelectorAll("script")
        }
    }
      , Gs = class extends Jr {
        static{o(this, "PageRenderer")
        }static renderElement(t, e) {
            document.body && e instanceof HTMLBodyElement ? document.body.replaceWith(e) : document.documentElement.appendChild(e)
        }
        get shouldRender() {
            return this.newSnapshot.isVisitable && this.trackedElementsAreIdentical
        }
        get reloadReason() {
            if (!this.newSnapshot.isVisitable)
                return {
                    reason: "turbo_visit_control_is_reload"
                };
            if (!this.trackedElementsAreIdentical)
                return {
                    reason: "tracked_element_mismatch"
                }
        }
        async prepareToRender() {
            this.#t(),
            await this.mergeHead()
        }
        async render() {
            this.willRender && await this.replaceBody()
        }
        finishRendering() {
            super.finishRendering(),
            this.isPreview || this.focusFirstAutofocusableElement()
        }
        get currentHeadSnapshot() {
            return this.currentSnapshot.headSnapshot
        }
        get newHeadSnapshot() {
            return this.newSnapshot.headSnapshot
        }
        get newElement() {
            return this.newSnapshot.element
        }
        #t() {
            let {documentElement: t} = this.currentSnapshot
              , {lang: e} = this.newSnapshot;
            e ? t.setAttribute("lang", e) : t.removeAttribute("lang")
        }
        async mergeHead() {
            let t = this.mergeProvisionalElements()
              , e = this.copyNewHeadStylesheetElements();
            this.copyNewHeadScriptElements(),
            await t,
            await e,
            this.willRender && this.removeUnusedDynamicStylesheetElements()
        }
        async replaceBody() {
            await this.preservingPermanentElements(async () => {
                this.activateNewBody(),
                await this.assignNewBody()
            }
            )
        }
        get trackedElementsAreIdentical() {
            return this.currentHeadSnapshot.trackedElementSignature == this.newHeadSnapshot.trackedElementSignature
        }
        async copyNewHeadStylesheetElements() {
            let t = [];
            for (let e of this.newHeadStylesheetElements)
                t.push(uv(e)),
                document.head.appendChild(e);
            await Promise.all(t)
        }
        copyNewHeadScriptElements() {
            for (let t of this.newHeadScriptElements)
                document.head.appendChild(Gr(t))
        }
        removeUnusedDynamicStylesheetElements() {
            for (let t of this.unusedDynamicStylesheetElements)
                document.head.removeChild(t)
        }
        async mergeProvisionalElements() {
            let t = [...this.newHeadProvisionalElements];
            for (let e of this.currentHeadProvisionalElements)
                this.isCurrentElementInElementList(e, t) || document.head.removeChild(e);
            for (let e of t)
                document.head.appendChild(e)
        }
        isCurrentElementInElementList(t, e) {
            for (let[s,r] of e.entries()) {
                if (t.tagName == "TITLE") {
                    if (r.tagName != "TITLE")
                        continue;
                    if (t.innerHTML == r.innerHTML)
                        return e.splice(s, 1),
                        !0
                }
                if (r.isEqualNode(t))
                    return e.splice(s, 1),
                    !0
            }
            return !1
        }
        removeCurrentHeadProvisionalElements() {
            for (let t of this.currentHeadProvisionalElements)
                document.head.removeChild(t)
        }
        copyNewHeadProvisionalElements() {
            for (let t of this.newHeadProvisionalElements)
                document.head.appendChild(t)
        }
        activateNewBody() {
            document.adoptNode(this.newElement),
            this.activateNewBodyScriptElements()
        }
        activateNewBodyScriptElements() {
            for (let t of this.newBodyScriptElements) {
                let e = Gr(t);
                t.replaceWith(e)
            }
        }
        async assignNewBody() {
            await this.renderElement(this.currentElement, this.newElement)
        }
        get unusedDynamicStylesheetElements() {
            return this.oldHeadStylesheetElements.filter(t => t.getAttribute("data-turbo-track") === "dynamic")
        }
        get oldHeadStylesheetElements() {
            return this.currentHeadSnapshot.getStylesheetElementsNotInSnapshot(this.newHeadSnapshot)
        }
        get newHeadStylesheetElements() {
            return this.newHeadSnapshot.getStylesheetElementsNotInSnapshot(this.currentHeadSnapshot)
        }
        get newHeadScriptElements() {
            return this.newHeadSnapshot.getScriptElementsNotInSnapshot(this.currentHeadSnapshot)
        }
        get currentHeadProvisionalElements() {
            return this.currentHeadSnapshot.provisionalElements
        }
        get newHeadProvisionalElements() {
            return this.newHeadSnapshot.provisionalElements
        }
        get newBodyScriptElements() {
            return this.newElement.querySelectorAll("script")
        }
    }
      , ac = class extends Gs {
        static{o(this, "MorphingPageRenderer")
        }static renderElement(t, e) {
            yc(t, e, {
                callbacks: {
                    beforeNodeMorphed: o(s => !tf(s), "beforeNodeMorphed")
                }
            });
            for (let s of t.querySelectorAll("turbo-frame"))
                tf(s) && s.reload();
            ue("turbo:morph", {
                detail: {
                    currentElement: t,
                    newElement: e
                }
            })
        }
        async preservingPermanentElements(t) {
            return await t()
        }
        get renderMethod() {
            return "morph"
        }
        get shouldAutofocus() {
            return !1
        }
    }
    ;
    function tf(n) {
        return n instanceof bi && n.src && n.refresh === "morph" && !n.closest("[data-turbo-permanent]")
    }
    o(tf, "canRefreshFrame");
    var lc = class {
        static{o(this, "SnapshotCache")
        }keys = [];
        snapshots = {};
        constructor(t) {
            this.size = t
        }
        has(t) {
            return ia(t)in this.snapshots
        }
        get(t) {
            if (this.has(t)) {
                let e = this.read(t);
                return this.touch(t),
                e
            }
        }
        put(t, e) {
            return this.write(t, e),
            this.touch(t),
            e
        }
        clear() {
            this.snapshots = {}
        }
        read(t) {
            return this.snapshots[ia(t)]
        }
        write(t, e) {
            this.snapshots[ia(t)] = e
        }
        touch(t) {
            let e = ia(t)
              , s = this.keys.indexOf(e);
            s > -1 && this.keys.splice(s, 1),
            this.keys.unshift(e),
            this.trim()
        }
        trim() {
            for (let t of this.keys.splice(this.size))
                delete this.snapshots[t]
        }
    }
      , cc = class extends ca {
        static{o(this, "PageView")
        }snapshotCache = new lc(10);
        lastRenderedLocation = new URL(location.href);
        forceReloaded = !1;
        shouldTransitionTo(t) {
            return this.snapshot.prefersViewTransitions && t.prefersViewTransitions
        }
        renderPage(t, e=!1, s=!0, r) {
            let l = this.isPageRefresh(r) && this.snapshot.shouldMorphPage ? ac : Gs
              , u = new l(this.snapshot,t,e,s);
            return u.shouldRender ? r?.changeHistory() : this.forceReloaded = !0,
            this.render(u)
        }
        renderError(t, e) {
            e?.changeHistory();
            let s = new oc(this.snapshot,t,!1);
            return this.render(s)
        }
        clearSnapshotCache() {
            this.snapshotCache.clear()
        }
        async cacheSnapshot(t=this.snapshot) {
            if (t.isCacheable) {
                this.delegate.viewWillCacheSnapshot();
                let {lastRenderedLocation: e} = this;
                await af();
                let s = t.clone();
                return this.snapshotCache.put(e, s),
                s
            }
        }
        getCachedSnapshotForLocation(t) {
            return this.snapshotCache.get(t)
        }
        isPageRefresh(t) {
            return !t || this.lastRenderedLocation.pathname === t.location.pathname && t.action === "replace"
        }
        shouldPreserveScrollPosition(t) {
            return this.isPageRefresh(t) && this.snapshot.shouldPreserveScrollPosition
        }
        get snapshot() {
            return vi.fromElement(this.element)
        }
    }
      , uc = class {
        static{o(this, "Preloader")
        }selector = "a[data-turbo-preload]";
        constructor(t, e) {
            this.delegate = t,
            this.snapshotCache = e
        }
        start() {
            document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", this.#t) : this.preloadOnLoadLinksForView(document.body)
        }
        stop() {
            document.removeEventListener("DOMContentLoaded", this.#t)
        }
        preloadOnLoadLinksForView(t) {
            for (let e of t.querySelectorAll(this.selector))
                this.delegate.shouldPreloadLink(e) && this.preloadURL(e)
        }
        async preloadURL(t) {
            let e = new URL(t.href);
            if (this.snapshotCache.has(e))
                return;
            await new Dn(this,ni.get,e,new URLSearchParams,t).perform()
        }
        prepareRequest(t) {
            t.headers["X-Sec-Purpose"] = "prefetch"
        }
        async requestSucceededWithResponse(t, e) {
            try {
                let s = await e.responseHTML
                  , r = vi.fromHTMLString(s);
                this.snapshotCache.put(t.url, r)
            } catch {}
        }
        requestStarted(t) {}
        requestErrored(t) {}
        requestFinished(t) {}
        requestPreventedHandlingResponse(t, e) {}
        requestFailedWithResponse(t, e) {}
        #t = o( () => {
            this.preloadOnLoadLinksForView(document.body)
        }
        , "#preloadAll")
    }
      , hc = class {
        static{o(this, "Cache")
        }constructor(t) {
            this.session = t
        }
        clear() {
            this.session.clearCache()
        }
        resetCacheControl() {
            this.#t("")
        }
        exemptPageFromCache() {
            this.#t("no-cache")
        }
        exemptPageFromPreview() {
            this.#t("no-preview")
        }
        #t(t) {
            dv("turbo-cache-control", t)
        }
    }
      , dc = class {
        static{o(this, "Session")
        }navigator = new ec(this);
        history = new Zl(this);
        view = new cc(this,document.documentElement);
        adapter = new Gl(this);
        pageObserver = new ic(this);
        cacheObserver = new Ql;
        linkPrefetchObserver = new tc(this,document);
        linkClickObserver = new ha(this,window);
        formSubmitObserver = new Qr(this,document);
        scrollObserver = new nc(this);
        streamObserver = new rc(this);
        formLinkClickObserver = new da(this,document.documentElement);
        frameRedirector = new Jl(this,document.documentElement);
        streamMessageRenderer = new sc;
        cache = new hc(this);
        enabled = !0;
        started = !1;
        #t = 150;
        constructor(t) {
            this.recentRequests = t,
            this.preloader = new uc(this,this.view.snapshotCache),
            this.debouncedRefresh = this.refresh,
            this.pageRefreshDebouncePeriod = this.pageRefreshDebouncePeriod
        }
        start() {
            this.started || (this.pageObserver.start(),
            this.cacheObserver.start(),
            this.linkPrefetchObserver.start(),
            this.formLinkClickObserver.start(),
            this.linkClickObserver.start(),
            this.formSubmitObserver.start(),
            this.scrollObserver.start(),
            this.streamObserver.start(),
            this.frameRedirector.start(),
            this.history.start(),
            this.preloader.start(),
            this.started = !0,
            this.enabled = !0)
        }
        disable() {
            this.enabled = !1
        }
        stop() {
            this.started && (this.pageObserver.stop(),
            this.cacheObserver.stop(),
            this.linkPrefetchObserver.stop(),
            this.formLinkClickObserver.stop(),
            this.linkClickObserver.stop(),
            this.formSubmitObserver.stop(),
            this.scrollObserver.stop(),
            this.streamObserver.stop(),
            this.frameRedirector.stop(),
            this.history.stop(),
            this.preloader.stop(),
            this.started = !1)
        }
        registerAdapter(t) {
            this.adapter = t
        }
        visit(t, e={}) {
            let s = e.frame ? document.getElementById(e.frame) : null;
            if (s instanceof bi) {
                let r = e.action || as(s);
                s.delegate.proposeVisitIfNavigatedWithAction(s, r),
                s.src = t.toString()
            } else
                this.navigator.proposeVisit(Te(t), e)
        }
        refresh(t, e) {
            let s = e && this.recentRequests.has(e)
              , r = t === document.baseURI;
            !s && !this.navigator.currentVisit && r && this.visit(t, {
                action: "replace",
                shouldCacheSnapshot: !1
            })
        }
        connectStreamSource(t) {
            this.streamObserver.connectStreamSource(t)
        }
        disconnectStreamSource(t) {
            this.streamObserver.disconnectStreamSource(t)
        }
        renderStreamMessage(t) {
            this.streamMessageRenderer.render(Pn.wrap(t))
        }
        clearCache() {
            this.view.clearSnapshotCache()
        }
        setProgressBarDelay(t) {
            console.warn("Please replace `session.setProgressBarDelay(delay)` with `session.progressBarDelay = delay`. The function is deprecated and will be removed in a future version of Turbo.`"),
            this.progressBarDelay = t
        }
        set progressBarDelay(t) {
            ve.drive.progressBarDelay = t
        }
        get progressBarDelay() {
            return ve.drive.progressBarDelay
        }
        set drive(t) {
            ve.drive.enabled = t
        }
        get drive() {
            return ve.drive.enabled
        }
        set formMode(t) {
            ve.forms.mode = t
        }
        get formMode() {
            return ve.forms.mode
        }
        get location() {
            return this.history.location
        }
        get restorationIdentifier() {
            return this.history.restorationIdentifier
        }
        get pageRefreshDebouncePeriod() {
            return this.#t
        }
        set pageRefreshDebouncePeriod(t) {
            this.refresh = pv(this.debouncedRefresh.bind(this), t),
            this.#t = t
        }
        shouldPreloadLink(t) {
            let e = t.hasAttribute("data-turbo-method")
              , s = t.hasAttribute("data-turbo-stream")
              , r = t.getAttribute("data-turbo-frame")
              , a = r == "_top" ? null : document.getElementById(r) || zs(t, "turbo-frame:not([disabled])");
            if (e || s || a instanceof bi)
                return !1;
            {
                let l = new URL(t.href);
                return this.elementIsNavigatable(t) && Mn(l, this.snapshot.rootLocation)
            }
        }
        historyPoppedToLocationWithRestorationIdentifierAndDirection(t, e, s) {
            this.enabled ? this.navigator.startVisit(t, e, {
                action: "restore",
                historyChanged: !0,
                direction: s
            }) : this.adapter.pageInvalidated({
                reason: "turbo_disabled"
            })
        }
        scrollPositionChanged(t) {
            this.history.updateRestorationData({
                scrollPosition: t
            })
        }
        willSubmitFormLinkToLocation(t, e) {
            return this.elementIsNavigatable(t) && Mn(e, this.snapshot.rootLocation)
        }
        submittedFormLinkToLocation() {}
        canPrefetchRequestToLocation(t, e) {
            return this.elementIsNavigatable(t) && Mn(e, this.snapshot.rootLocation) && this.navigator.linkPrefetchingIsEnabledForLocation(e)
        }
        willFollowLinkToLocation(t, e, s) {
            return this.elementIsNavigatable(t) && Mn(e, this.snapshot.rootLocation) && this.applicationAllowsFollowingLinkToLocation(t, e, s)
        }
        followedLinkToLocation(t, e) {
            let s = this.getActionForLink(t)
              , r = t.hasAttribute("data-turbo-stream");
            this.visit(e.href, {
                action: s,
                acceptsStreamResponse: r
            })
        }
        allowsVisitingLocationWithAction(t, e) {
            return this.locationWithActionIsSamePage(t, e) || this.applicationAllowsVisitingLocation(t)
        }
        visitProposedToLocation(t, e) {
            ef(t),
            this.adapter.visitProposedToLocation(t, e)
        }
        visitStarted(t) {
            t.acceptsStreamResponse || (ra(document.documentElement),
            this.view.markVisitDirection(t.direction)),
            ef(t.location),
            t.silent || this.notifyApplicationAfterVisitingLocation(t.location, t.action)
        }
        visitCompleted(t) {
            this.view.unmarkVisitDirection(),
            oa(document.documentElement),
            this.notifyApplicationAfterPageLoad(t.getTimingMetrics())
        }
        locationWithActionIsSamePage(t, e) {
            return this.navigator.locationWithActionIsSamePage(t, e)
        }
        visitScrolledToSamePageLocation(t, e) {
            this.notifyApplicationAfterVisitingSamePageLocation(t, e)
        }
        willSubmitForm(t, e) {
            let s = vc(t, e);
            return this.submissionIsNavigatable(t, e) && Mn(Te(s), this.snapshot.rootLocation)
        }
        formSubmitted(t, e) {
            this.navigator.submitForm(t, e)
        }
        pageBecameInteractive() {
            this.view.lastRenderedLocation = this.location,
            this.notifyApplicationAfterPageLoad()
        }
        pageLoaded() {
            this.history.assumeControlOfScrollRestoration()
        }
        pageWillUnload() {
            this.history.relinquishControlOfScrollRestoration()
        }
        receivedMessageFromStream(t) {
            this.renderStreamMessage(t)
        }
        viewWillCacheSnapshot() {
            this.navigator.currentVisit?.silent || this.notifyApplicationBeforeCachingSnapshot()
        }
        allowsImmediateRender({element: t}, e) {
            let s = this.notifyApplicationBeforeRender(t, e)
              , {defaultPrevented: r, detail: {render: a}} = s;
            return this.view.renderer && a && (this.view.renderer.renderElement = a),
            !r
        }
        viewRenderedSnapshot(t, e, s) {
            this.view.lastRenderedLocation = this.history.location,
            this.notifyApplicationAfterRender(s)
        }
        preloadOnLoadLinksForView(t) {
            this.preloader.preloadOnLoadLinksForView(t)
        }
        viewInvalidated(t) {
            this.adapter.pageInvalidated(t)
        }
        frameLoaded(t) {
            this.notifyApplicationAfterFrameLoad(t)
        }
        frameRendered(t, e) {
            this.notifyApplicationAfterFrameRender(t, e)
        }
        applicationAllowsFollowingLinkToLocation(t, e, s) {
            return !this.notifyApplicationAfterClickingLinkToLocation(t, e, s).defaultPrevented
        }
        applicationAllowsVisitingLocation(t) {
            return !this.notifyApplicationBeforeVisitingLocation(t).defaultPrevented
        }
        notifyApplicationAfterClickingLinkToLocation(t, e, s) {
            return ue("turbo:click", {
                target: t,
                detail: {
                    url: e.href,
                    originalEvent: s
                },
                cancelable: !0
            })
        }
        notifyApplicationBeforeVisitingLocation(t) {
            return ue("turbo:before-visit", {
                detail: {
                    url: t.href
                },
                cancelable: !0
            })
        }
        notifyApplicationAfterVisitingLocation(t, e) {
            return ue("turbo:visit", {
                detail: {
                    url: t.href,
                    action: e
                }
            })
        }
        notifyApplicationBeforeCachingSnapshot() {
            return ue("turbo:before-cache")
        }
        notifyApplicationBeforeRender(t, e) {
            return ue("turbo:before-render", {
                detail: {
                    newBody: t,
                    ...e
                },
                cancelable: !0
            })
        }
        notifyApplicationAfterRender(t) {
            return ue("turbo:render", {
                detail: {
                    renderMethod: t
                }
            })
        }
        notifyApplicationAfterPageLoad(t={}) {
            return ue("turbo:load", {
                detail: {
                    url: this.location.href,
                    timing: t
                }
            })
        }
        notifyApplicationAfterVisitingSamePageLocation(t, e) {
            dispatchEvent(new HashChangeEvent("hashchange",{
                oldURL: t.toString(),
                newURL: e.toString()
            }))
        }
        notifyApplicationAfterFrameLoad(t) {
            return ue("turbo:frame-load", {
                target: t
            })
        }
        notifyApplicationAfterFrameRender(t, e) {
            return ue("turbo:frame-render", {
                detail: {
                    fetchResponse: t
                },
                target: e,
                cancelable: !0
            })
        }
        submissionIsNavigatable(t, e) {
            if (ve.forms.mode == "off")
                return !1;
            {
                let s = e ? this.elementIsNavigatable(e) : !0;
                return ve.forms.mode == "optin" ? s && t.closest('[data-turbo="true"]') != null : s && this.elementIsNavigatable(t)
            }
        }
        elementIsNavigatable(t) {
            let e = zs(t, "[data-turbo]")
              , s = zs(t, "turbo-frame");
            return ve.drive.enabled || s ? e ? e.getAttribute("data-turbo") != "false" : !0 : e ? e.getAttribute("data-turbo") == "true" : !1
        }
        getActionForLink(t) {
            return as(t) || "advance"
        }
        get snapshot() {
            return this.view.snapshot
        }
    }
    ;
    function ef(n) {
        Object.defineProperties(n, cb)
    }
    o(ef, "extendURLWithDeprecatedProperties");
    var cb = {
        absoluteURL: {
            get() {
                return this.toString()
            }
        }
    }
      , de = new dc(mf)
      , {cache: Sf, navigator: Tf} = de;
    function _c() {
        de.start()
    }
    o(_c, "start");
    function xf(n) {
        de.registerAdapter(n)
    }
    o(xf, "registerAdapter");
    function wf(n, t) {
        de.visit(n, t)
    }
    o(wf, "visit");
    function Zr(n) {
        de.connectStreamSource(n)
    }
    o(Zr, "connectStreamSource");
    function to(n) {
        de.disconnectStreamSource(n)
    }
    o(to, "disconnectStreamSource");
    function Cf(n) {
        de.renderStreamMessage(n)
    }
    o(Cf, "renderStreamMessage");
    function Af() {
        console.warn("Please replace `Turbo.clearCache()` with `Turbo.cache.clear()`. The top-level function is deprecated and will be removed in a future version of Turbo.`"),
        de.clearCache()
    }
    o(Af, "clearCache");
    function kf(n) {
        console.warn("Please replace `Turbo.setProgressBarDelay(delay)` with `Turbo.config.drive.progressBarDelay = delay`. The top-level function is deprecated and will be removed in a future version of Turbo.`"),
        ve.drive.progressBarDelay = n
    }
    o(kf, "setProgressBarDelay");
    function Mf(n) {
        console.warn("Please replace `Turbo.setConfirmMethod(confirmMethod)` with `Turbo.config.forms.confirm = confirmMethod`. The top-level function is deprecated and will be removed in a future version of Turbo.`"),
        ve.forms.confirm = n
    }
    o(Mf, "setConfirmMethod");
    function Of(n) {
        console.warn("Please replace `Turbo.setFormMode(mode)` with `Turbo.config.forms.mode = mode`. The top-level function is deprecated and will be removed in a future version of Turbo.`"),
        ve.forms.mode = n
    }
    o(Of, "setFormMode");
    var ub = Object.freeze({
        __proto__: null,
        navigator: Tf,
        session: de,
        cache: Sf,
        PageRenderer: Gs,
        PageSnapshot: vi,
        FrameRenderer: Xs,
        fetch: bc,
        config: ve,
        start: _c,
        registerAdapter: xf,
        visit: wf,
        connectStreamSource: Zr,
        disconnectStreamSource: to,
        renderStreamMessage: Cf,
        clearCache: Af,
        setProgressBarDelay: kf,
        setConfirmMethod: Mf,
        setFormMode: Of
    })
      , fc = class extends Error {
        static{o(this, "TurboFrameMissingError")
        }
    }
      , pc = class {
        static{o(this, "FrameController")
        }fetchResponseLoaded = o(t => Promise.resolve(), "fetchResponseLoaded");
        #t = null;
        #e = o( () => {}
        , "#resolveVisitPromise");
        #i = !1;
        #r = !1;
        #o = new Set;
        #s = !1;
        action = null;
        constructor(t) {
            this.element = t,
            this.view = new $l(this,this.element),
            this.appearanceObserver = new jl(this,this.element),
            this.formLinkClickObserver = new da(this,this.element),
            this.linkInterceptor = new ua(this,this.element),
            this.restorationIdentifier = Ln(),
            this.formSubmitObserver = new Qr(this,this.element)
        }
        connect() {
            this.#i || (this.#i = !0,
            this.loadingStyle == os.lazy ? this.appearanceObserver.start() : this.#n(),
            this.formLinkClickObserver.start(),
            this.linkInterceptor.start(),
            this.formSubmitObserver.start())
        }
        disconnect() {
            this.#i && (this.#i = !1,
            this.appearanceObserver.stop(),
            this.formLinkClickObserver.stop(),
            this.linkInterceptor.stop(),
            this.formSubmitObserver.stop())
        }
        disabledChanged() {
            this.loadingStyle == os.eager && this.#n()
        }
        sourceURLChanged() {
            this.#b("src") || (this.element.isConnected && (this.complete = !1),
            (this.loadingStyle == os.eager || this.#r) && this.#n())
        }
        sourceURLReloaded() {
            let {refresh: t, src: e} = this.element;
            return this.#s = e && t === "morph",
            this.element.removeAttribute("complete"),
            this.element.src = null,
            this.element.src = e,
            this.element.loaded
        }
        loadingStyleChanged() {
            this.loadingStyle == os.lazy ? this.appearanceObserver.start() : (this.appearanceObserver.stop(),
            this.#n())
        }
        async #n() {
            this.enabled && this.isActive && !this.complete && this.sourceURL && (this.element.loaded = this.#h(Te(this.sourceURL)),
            this.appearanceObserver.stop(),
            await this.element.loaded,
            this.#r = !0)
        }
        async loadResponse(t) {
            (t.redirected || t.succeeded && t.isHTML) && (this.sourceURL = t.response.url);
            try {
                let e = await t.responseHTML;
                if (e) {
                    let s = lf(e);
                    vi.fromDocument(s).isVisitable ? await this.#l(t, s) : await this.#f(t)
                }
            } finally {
                this.#s = !1,
                this.fetchResponseLoaded = () => Promise.resolve()
            }
        }
        elementAppearedInViewport(t) {
            this.proposeVisitIfNavigatedWithAction(t, as(t)),
            this.#n()
        }
        willSubmitFormLinkToLocation(t) {
            return this.#c(t)
        }
        submittedFormLinkToLocation(t, e, s) {
            let r = this.#a(t);
            r && s.setAttribute("data-turbo-frame", r.id)
        }
        shouldInterceptLinkClick(t, e, s) {
            return this.#c(t)
        }
        linkClickIntercepted(t, e) {
            this.#d(t, e)
        }
        willSubmitForm(t, e) {
            return t.closest("turbo-frame") == this.element && this.#c(t, e)
        }
        formSubmitted(t, e) {
            this.formSubmission && this.formSubmission.stop(),
            this.formSubmission = new la(this,t,e);
            let {fetchRequest: s} = this.formSubmission;
            this.prepareRequest(s),
            this.formSubmission.start()
        }
        prepareRequest(t) {
            t.headers["Turbo-Frame"] = this.id,
            this.currentNavigationElement?.hasAttribute("data-turbo-stream") && t.acceptResponseType(Pn.contentType)
        }
        requestStarted(t) {
            ra(this.element)
        }
        requestPreventedHandlingResponse(t, e) {
            this.#e()
        }
        async requestSucceededWithResponse(t, e) {
            await this.loadResponse(e),
            this.#e()
        }
        async requestFailedWithResponse(t, e) {
            await this.loadResponse(e),
            this.#e()
        }
        requestErrored(t, e) {
            console.error(e),
            this.#e()
        }
        requestFinished(t) {
            oa(this.element)
        }
        formSubmissionStarted({formElement: t}) {
            ra(t, this.#a(t))
        }
        formSubmissionSucceededWithResponse(t, e) {
            let s = this.#a(t.formElement, t.submitter);
            s.delegate.proposeVisitIfNavigatedWithAction(s, as(t.submitter, t.formElement, s)),
            s.delegate.loadResponse(e),
            t.isSafe || de.clearCache()
        }
        formSubmissionFailedWithResponse(t, e) {
            this.element.delegate.loadResponse(e),
            de.clearCache()
        }
        formSubmissionErrored(t, e) {
            console.error(e)
        }
        formSubmissionFinished({formElement: t}) {
            oa(t, this.#a(t))
        }
        allowsImmediateRender({element: t}, e) {
            let s = ue("turbo:before-frame-render", {
                target: this.element,
                detail: {
                    newFrame: t,
                    ...e
                },
                cancelable: !0
            })
              , {defaultPrevented: r, detail: {render: a}} = s;
            return this.view.renderer && a && (this.view.renderer.renderElement = a),
            !r
        }
        viewRenderedSnapshot(t, e, s) {}
        preloadOnLoadLinksForView(t) {
            de.preloadOnLoadLinksForView(t)
        }
        viewInvalidated() {}
        willRenderFrame(t, e) {
            this.previousFrameElement = t.cloneNode(!0)
        }
        visitCachedSnapshot = o( ({element: t}) => {
            let e = t.querySelector("#" + this.element.id);
            e && this.previousFrameElement && e.replaceChildren(...this.previousFrameElement.children),
            delete this.previousFrameElement
        }
        , "visitCachedSnapshot");
        async #l(t, e) {
            let s = await this.extractForeignFrameElement(e.body)
              , r = this.#s ? zl : Xs;
            if (s) {
                let a = new Ys(s)
                  , l = new r(this,this.view.snapshot,a,!1,!1);
                this.view.renderPromise && await this.view.renderPromise,
                this.changeHistory(),
                await this.view.render(l),
                this.complete = !0,
                de.frameRendered(t, this.element),
                de.frameLoaded(this.element),
                await this.fetchResponseLoaded(t)
            } else
                this.#p(t) && this.#g(t)
        }
        async #h(t) {
            let e = new Dn(this,ni.get,t,new URLSearchParams,this.element);
            return this.#t?.cancel(),
            this.#t = e,
            new Promise(s => {
                this.#e = () => {
                    this.#e = () => {}
                    ,
                    this.#t = null,
                    s()
                }
                ,
                e.perform()
            }
            )
        }
        #d(t, e, s) {
            let r = this.#a(t, s);
            r.delegate.proposeVisitIfNavigatedWithAction(r, as(s, t, r)),
            this.#_(t, () => {
                r.src = e
            }
            )
        }
        proposeVisitIfNavigatedWithAction(t, e=null) {
            if (this.action = e,
            this.action) {
                let s = vi.fromElement(t).clone()
                  , {visitCachedSnapshot: r} = t.delegate;
                t.delegate.fetchResponseLoaded = async a => {
                    if (t.src) {
                        let {statusCode: l, redirected: u} = a
                          , d = await a.responseHTML
                          , b = {
                            response: {
                                statusCode: l,
                                redirected: u,
                                responseHTML: d
                            },
                            visitCachedSnapshot: r,
                            willRender: !1,
                            updateHistory: !1,
                            restorationIdentifier: this.restorationIdentifier,
                            snapshot: s
                        };
                        this.action && (b.action = this.action),
                        de.visit(t.src, b)
                    }
                }
            }
        }
        changeHistory() {
            if (this.action) {
                let t = uf(this.action);
                de.history.update(t, Te(this.element.src || ""), this.restorationIdentifier)
            }
        }
        async #f(t) {
            console.warn(`The response (${t.statusCode}) from <turbo-frame id="${this.element.id}"> is performing a full page visit due to turbo-visit-control.`),
            await this.#u(t.response)
        }
        #p(t) {
            this.element.setAttribute("complete", "");
            let e = t.response
              , s = o(async (a, l) => {
                a instanceof Response ? this.#u(a) : de.visit(a, l)
            }
            , "visit");
            return !ue("turbo:frame-missing", {
                target: this.element,
                detail: {
                    response: e,
                    visit: s
                },
                cancelable: !0
            }).defaultPrevented
        }
        #g(t) {
            this.view.missing(),
            this.#m(t)
        }
        #m(t) {
            let e = `The response (${t.statusCode}) did not contain the expected <turbo-frame id="${this.element.id}"> and will be ignored. To perform a full page visit instead, set turbo-visit-control to reload.`;
            throw new fc(e)
        }
        async #u(t) {
            let e = new Ks(t)
              , s = await e.responseHTML
              , {location: r, redirected: a, statusCode: l} = e;
            return de.visit(r, {
                response: {
                    redirected: a,
                    statusCode: l,
                    responseHTML: s
                }
            })
        }
        #a(t, e) {
            let s = sa("data-turbo-frame", e, t) || this.element.getAttribute("target");
            return nf(s) ?? this.element
        }
        async extractForeignFrameElement(t) {
            let e, s = CSS.escape(this.id);
            try {
                if (e = sf(t.querySelector(`turbo-frame#${s}`), this.sourceURL),
                e)
                    return e;
                if (e = sf(t.querySelector(`turbo-frame[src][recurse~=${s}]`), this.sourceURL),
                e)
                    return await e.loaded,
                    await this.extractForeignFrameElement(e)
            } catch (r) {
                return console.error(r),
                new bi
            }
            return null
        }
        #v(t, e) {
            let s = vc(t, e);
            return Mn(Te(s), this.rootLocation)
        }
        #c(t, e) {
            let s = sa("data-turbo-frame", e, t) || this.element.getAttribute("target");
            if (t instanceof HTMLFormElement && !this.#v(t, e) || !this.enabled || s == "_top")
                return !1;
            if (s) {
                let r = nf(s);
                if (r)
                    return !r.disabled
            }
            return !(!de.elementIsNavigatable(t) || e && !de.elementIsNavigatable(e))
        }
        get id() {
            return this.element.id
        }
        get enabled() {
            return !this.element.disabled
        }
        get sourceURL() {
            if (this.element.src)
                return this.element.src
        }
        set sourceURL(t) {
            this.#y("src", () => {
                this.element.src = t ?? null
            }
            )
        }
        get loadingStyle() {
            return this.element.loading
        }
        get isLoading() {
            return this.formSubmission !== void 0 || this.#e() !== void 0
        }
        get complete() {
            return this.element.hasAttribute("complete")
        }
        set complete(t) {
            t ? this.element.setAttribute("complete", "") : this.element.removeAttribute("complete")
        }
        get isActive() {
            return this.element.isActive && this.#i
        }
        get rootLocation() {
            let e = this.element.ownerDocument.querySelector('meta[name="turbo-root"]')?.content ?? "/";
            return Te(e)
        }
        #b(t) {
            return this.#o.has(t)
        }
        #y(t, e) {
            this.#o.add(t),
            e(),
            this.#o.delete(t)
        }
        #_(t, e) {
            this.currentNavigationElement = t,
            e(),
            delete this.currentNavigationElement
        }
    }
    ;
    function nf(n) {
        if (n != null) {
            let t = document.getElementById(n);
            if (t instanceof bi)
                return t
        }
    }
    o(nf, "getFrameElementById");
    function sf(n, t) {
        if (n) {
            let e = n.getAttribute("src");
            if (e != null && t != null && yv(e, t))
                throw new Error(`Matching <turbo-frame id="${n.id}"> element has a source URL which references itself`);
            if (n.ownerDocument !== document && (n = document.importNode(n, !0)),
            n instanceof bi)
                return n.connectedCallback(),
                n.disconnectedCallback(),
                n
        }
    }
    o(sf, "activateElement");
    var Ec = {
        after() {
            this.targetElements.forEach(n => n.parentElement?.insertBefore(this.templateContent, n.nextSibling))
        },
        append() {
            this.removeDuplicateTargetChildren(),
            this.targetElements.forEach(n => n.append(this.templateContent))
        },
        before() {
            this.targetElements.forEach(n => n.parentElement?.insertBefore(this.templateContent, n))
        },
        prepend() {
            this.removeDuplicateTargetChildren(),
            this.targetElements.forEach(n => n.prepend(this.templateContent))
        },
        remove() {
            this.targetElements.forEach(n => n.remove())
        },
        replace() {
            let n = this.getAttribute("method");
            this.targetElements.forEach(t => {
                n === "morph" ? yc(t, this.templateContent) : t.replaceWith(this.templateContent)
            }
            )
        },
        update() {
            let n = this.getAttribute("method");
            this.targetElements.forEach(t => {
                n === "morph" ? Ef(t, this.templateContent) : (t.innerHTML = "",
                t.append(this.templateContent))
            }
            )
        },
        refresh() {
            de.refresh(this.baseURI, this.requestId)
        }
    }
      , pa = class n extends HTMLElement {
        static{o(this, "StreamElement")
        }static async renderElement(t) {
            await t.performAction()
        }
        async connectedCallback() {
            try {
                await this.render()
            } catch (t) {
                console.error(t)
            } finally {
                this.disconnect()
            }
        }
        async render() {
            return this.renderPromise ??= (async () => {
                let t = this.beforeRenderEvent;
                this.dispatchEvent(t) && (await Xr(),
                await t.detail.render(this))
            }
            )()
        }
        disconnect() {
            try {
                this.remove()
            } catch {}
        }
        removeDuplicateTargetChildren() {
            this.duplicateChildren.forEach(t => t.remove())
        }
        get duplicateChildren() {
            let t = this.targetElements.flatMap(s => [...s.children]).filter(s => !!s.getAttribute("id"))
              , e = [...this.templateContent?.children || []].filter(s => !!s.getAttribute("id")).map(s => s.getAttribute("id"));
            return t.filter(s => e.includes(s.getAttribute("id")))
        }
        get performAction() {
            if (this.action) {
                let t = Ec[this.action];
                if (t)
                    return t;
                this.#t("unknown action")
            }
            this.#t("action attribute is missing")
        }
        get targetElements() {
            if (this.target)
                return this.targetElementsById;
            if (this.targets)
                return this.targetElementsByQuery;
            this.#t("target or targets attribute is missing")
        }
        get templateContent() {
            return this.templateElement.content.cloneNode(!0)
        }
        get templateElement() {
            if (this.firstElementChild === null) {
                let t = this.ownerDocument.createElement("template");
                return this.appendChild(t),
                t
            } else if (this.firstElementChild instanceof HTMLTemplateElement)
                return this.firstElementChild;
            this.#t("first child element must be a <template> element")
        }
        get action() {
            return this.getAttribute("action")
        }
        get target() {
            return this.getAttribute("target")
        }
        get targets() {
            return this.getAttribute("targets")
        }
        get requestId() {
            return this.getAttribute("request-id")
        }
        #t(t) {
            throw new Error(`${this.description}: ${t}`)
        }
        get description() {
            return (this.outerHTML.match(/<[^>]+>/) ?? [])[0] ?? "<turbo-stream>"
        }
        get beforeRenderEvent() {
            return new CustomEvent("turbo:before-stream-render",{
                bubbles: !0,
                cancelable: !0,
                detail: {
                    newStream: this,
                    render: n.renderElement
                }
            })
        }
        get targetElementsById() {
            let t = this.ownerDocument?.getElementById(this.target);
            return t !== null ? [t] : []
        }
        get targetElementsByQuery() {
            let t = this.ownerDocument?.querySelectorAll(this.targets);
            return t.length !== 0 ? Array.prototype.slice.call(t) : []
        }
    }
      , ga = class extends HTMLElement {
        static{o(this, "StreamSourceElement")
        }streamSource = null;
        connectedCallback() {
            this.streamSource = this.src.match(/^ws{1,2}:/) ? new WebSocket(this.src) : new EventSource(this.src),
            Zr(this.streamSource)
        }
        disconnectedCallback() {
            this.streamSource && (this.streamSource.close(),
            to(this.streamSource))
        }
        get src() {
            return this.getAttribute("src") || ""
        }
    }
    ;
    bi.delegateConstructor = pc;
    customElements.get("turbo-frame") === void 0 && customElements.define("turbo-frame", bi);
    customElements.get("turbo-stream") === void 0 && customElements.define("turbo-stream", pa);
    customElements.get("turbo-stream-source") === void 0 && customElements.define("turbo-stream-source", ga);
    ( () => {
        let n = document.currentScript;
        if (n && !n.hasAttribute("data-turbo-suppress-warning"))
            for (n = n.parentElement; n; ) {
                if (n == document.body)
                    return console.warn(cf`
        You are loading Turbo from a <script> element inside the <body> element. This is probably not what you meant to do!

        Load your application’s JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.

        For more information, see: https://turbo.hotwired.dev/handbook/building#working-with-script-elements

        ——
        Suppress this warning by adding a "data-turbo-suppress-warning" attribute to: %s
      `, n.outerHTML);
                n = n.parentElement
            }
    }
    )();
    window.Turbo = {
        ...ub,
        StreamActions: Ec
    };
    _c();
    var Ff;
    async function pb() {
        return Ff || Nf(gb().then(Nf))
    }
    o(pb, "getConsumer");
    function Nf(n) {
        return Ff = n
    }
    o(Nf, "setConsumer");
    async function gb() {
        let {createConsumer: n} = await Promise.resolve().then( () => (If(),
        Rf));
        return n()
    }
    o(gb, "createConsumer");
    async function Vf(n, t) {
        let {subscriptions: e} = await pb();
        return e.create(n, t)
    }
    o(Vf, "subscribeTo");
    function oo(n) {
        return !n || typeof n != "object" || n instanceof Date || n instanceof RegExp ? n : Array.isArray(n) ? n.map(oo) : Object.keys(n).reduce(function(t, e) {
            var s = e[0].toLowerCase() + e.slice(1).replace(/([A-Z]+)/g, function(r, a) {
                return "_" + a.toLowerCase()
            });
            return t[s] = oo(n[e]),
            t
        }, {})
    }
    o(oo, "walk");
    var Dc = class extends HTMLElement {
        static{o(this, "TurboCableStreamSourceElement")
        }static observedAttributes = ["channel", "signed-stream-name"];
        async connectedCallback() {
            Zr(this),
            this.subscription = await Vf(this.channel, {
                received: this.dispatchMessageEvent.bind(this),
                connected: this.subscriptionConnected.bind(this),
                disconnected: this.subscriptionDisconnected.bind(this)
            })
        }
        disconnectedCallback() {
            to(this),
            this.subscription && this.subscription.unsubscribe(),
            this.subscriptionDisconnected()
        }
        attributeChangedCallback() {
            this.subscription && (this.disconnectedCallback(),
            this.connectedCallback())
        }
        dispatchMessageEvent(t) {
            let e = new MessageEvent("message",{
                data: t
            });
            return this.dispatchEvent(e)
        }
        subscriptionConnected() {
            this.setAttribute("connected", "")
        }
        subscriptionDisconnected() {
            this.removeAttribute("connected")
        }
        get channel() {
            let t = this.getAttribute("channel")
              , e = this.getAttribute("signed-stream-name");
            return {
                channel: t,
                signed_stream_name: e,
                ...oo({
                    ...this.dataset
                })
            }
        }
    }
    ;
    customElements.get("turbo-cable-stream-source") === void 0 && customElements.define("turbo-cable-stream-source", Dc);
    function Bf(n) {
        if (n.target instanceof HTMLFormElement) {
            let {target: t, detail: {fetchOptions: e}} = n;
            t.addEventListener("turbo:submit-start", ({detail: {formSubmission: {submitter: s}}}) => {
                let r = yb(e.body) ? e.body : new URLSearchParams
                  , a = vb(s, r, t);
                /get/i.test(a) || (/post/i.test(a) ? r.delete("_method") : r.set("_method", a),
                e.method = "post")
            }
            , {
                once: !0
            })
        }
    }
    o(Bf, "encodeMethodIntoRequestBody");
    function vb(n, t, e) {
        let s = bb(n)
          , r = t.get("_method")
          , a = e.getAttribute("method") || "get";
        return typeof s == "string" ? s : typeof r == "string" ? r : a
    }
    o(vb, "determineFetchMethod");
    function bb(n) {
        return n instanceof HTMLButtonElement || n instanceof HTMLInputElement ? n.name === "_method" ? n.value : n.hasAttribute("formmethod") ? n.formMethod : null : null
    }
    o(bb, "determineFormMethod");
    function yb(n) {
        return n instanceof FormData || n instanceof URLSearchParams
    }
    o(yb, "isBodyInit");
    window.Turbo = Sc;
    addEventListener("turbo:before-fetch-request", Bf);
    var Pc = class {
        static{o(this, "EventListener")
        }constructor(t, e, s) {
            this.eventTarget = t,
            this.eventName = e,
            this.eventOptions = s,
            this.unorderedBindings = new Set
        }
        connect() {
            this.eventTarget.addEventListener(this.eventName, this, this.eventOptions)
        }
        disconnect() {
            this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions)
        }
        bindingConnected(t) {
            this.unorderedBindings.add(t)
        }
        bindingDisconnected(t) {
            this.unorderedBindings.delete(t)
        }
        handleEvent(t) {
            let e = _b(t);
            for (let s of this.bindings) {
                if (e.immediatePropagationStopped)
                    break;
                s.handleEvent(e)
            }
        }
        hasBindings() {
            return this.unorderedBindings.size > 0
        }
        get bindings() {
            return Array.from(this.unorderedBindings).sort( (t, e) => {
                let s = t.index
                  , r = e.index;
                return s < r ? -1 : s > r ? 1 : 0
            }
            )
        }
    }
    ;
    function _b(n) {
        if ("immediatePropagationStopped"in n)
            return n;
        {
            let {stopImmediatePropagation: t} = n;
            return Object.assign(n, {
                immediatePropagationStopped: !1,
                stopImmediatePropagation() {
                    this.immediatePropagationStopped = !0,
                    t.call(this)
                }
            })
        }
    }
    o(_b, "extendEvent");
    var Rc = class {
        static{o(this, "Dispatcher")
        }constructor(t) {
            this.application = t,
            this.eventListenerMaps = new Map,
            this.started = !1
        }
        start() {
            this.started || (this.started = !0,
            this.eventListeners.forEach(t => t.connect()))
        }
        stop() {
            this.started && (this.started = !1,
            this.eventListeners.forEach(t => t.disconnect()))
        }
        get eventListeners() {
            return Array.from(this.eventListenerMaps.values()).reduce( (t, e) => t.concat(Array.from(e.values())), [])
        }
        bindingConnected(t) {
            this.fetchEventListenerForBinding(t).bindingConnected(t)
        }
        bindingDisconnected(t, e=!1) {
            this.fetchEventListenerForBinding(t).bindingDisconnected(t),
            e && this.clearEventListenersForBinding(t)
        }
        handleError(t, e, s={}) {
            this.application.handleError(t, `Error ${e}`, s)
        }
        clearEventListenersForBinding(t) {
            let e = this.fetchEventListenerForBinding(t);
            e.hasBindings() || (e.disconnect(),
            this.removeMappedEventListenerFor(t))
        }
        removeMappedEventListenerFor(t) {
            let {eventTarget: e, eventName: s, eventOptions: r} = t
              , a = this.fetchEventListenerMapForEventTarget(e)
              , l = this.cacheKey(s, r);
            a.delete(l),
            a.size == 0 && this.eventListenerMaps.delete(e)
        }
        fetchEventListenerForBinding(t) {
            let {eventTarget: e, eventName: s, eventOptions: r} = t;
            return this.fetchEventListener(e, s, r)
        }
        fetchEventListener(t, e, s) {
            let r = this.fetchEventListenerMapForEventTarget(t)
              , a = this.cacheKey(e, s)
              , l = r.get(a);
            return l || (l = this.createEventListener(t, e, s),
            r.set(a, l)),
            l
        }
        createEventListener(t, e, s) {
            let r = new Pc(t,e,s);
            return this.started && r.connect(),
            r
        }
        fetchEventListenerMapForEventTarget(t) {
            let e = this.eventListenerMaps.get(t);
            return e || (e = new Map,
            this.eventListenerMaps.set(t, e)),
            e
        }
        cacheKey(t, e) {
            let s = [t];
            return Object.keys(e).sort().forEach(r => {
                s.push(`${e[r] ? "" : "!"}${r}`)
            }
            ),
            s.join(":")
        }
    }
      , Eb = {
        stop({event: n, value: t}) {
            return t && n.stopPropagation(),
            !0
        },
        prevent({event: n, value: t}) {
            return t && n.preventDefault(),
            !0
        },
        self({event: n, value: t, element: e}) {
            return t ? e === n.target : !0
        }
    }
      , Sb = /^(?:(?:([^.]+?)\+)?(.+?)(?:\.(.+?))?(?:@(window|document))?->)?(.+?)(?:#([^:]+?))(?::(.+))?$/;
    function Tb(n) {
        let e = n.trim().match(Sb) || []
          , s = e[2]
          , r = e[3];
        return r && !["keydown", "keyup", "keypress"].includes(s) && (s += `.${r}`,
        r = ""),
        {
            eventTarget: xb(e[4]),
            eventName: s,
            eventOptions: e[7] ? wb(e[7]) : {},
            identifier: e[5],
            methodName: e[6],
            keyFilter: e[1] || r
        }
    }
    o(Tb, "parseActionDescriptorString");
    function xb(n) {
        if (n == "window")
            return window;
        if (n == "document")
            return document
    }
    o(xb, "parseEventTarget");
    function wb(n) {
        return n.split(":").reduce( (t, e) => Object.assign(t, {
            [e.replace(/^!/, "")]: !/^!/.test(e)
        }), {})
    }
    o(wb, "parseEventOptions");
    function Cb(n) {
        if (n == window)
            return "window";
        if (n == document)
            return "document"
    }
    o(Cb, "stringifyEventTarget");
    function iu(n) {
        return n.replace(/(?:[_-])([a-z0-9])/g, (t, e) => e.toUpperCase())
    }
    o(iu, "camelize");
    function Ic(n) {
        return iu(n.replace(/--/g, "-").replace(/__/g, "_"))
    }
    o(Ic, "namespaceCamelize");
    function lo(n) {
        return n.charAt(0).toUpperCase() + n.slice(1)
    }
    o(lo, "capitalize");
    function Xf(n) {
        return n.replace(/([A-Z])/g, (t, e) => `-${e.toLowerCase()}`)
    }
    o(Xf, "dasherize");
    function Ab(n) {
        return n.match(/[^\s]+/g) || []
    }
    o(Ab, "tokenize");
    function Hf(n) {
        return n != null
    }
    o(Hf, "isSomething");
    function Nc(n, t) {
        return Object.prototype.hasOwnProperty.call(n, t)
    }
    o(Nc, "hasProperty");
    var jf = ["meta", "ctrl", "alt", "shift"]
      , Fc = class {
        static{o(this, "Action")
        }constructor(t, e, s, r) {
            this.element = t,
            this.index = e,
            this.eventTarget = s.eventTarget || t,
            this.eventName = s.eventName || kb(t) || Ta("missing event name"),
            this.eventOptions = s.eventOptions || {},
            this.identifier = s.identifier || Ta("missing identifier"),
            this.methodName = s.methodName || Ta("missing method name"),
            this.keyFilter = s.keyFilter || "",
            this.schema = r
        }
        static forToken(t, e) {
            return new this(t.element,t.index,Tb(t.content),e)
        }
        toString() {
            let t = this.keyFilter ? `.${this.keyFilter}` : ""
              , e = this.eventTargetName ? `@${this.eventTargetName}` : "";
            return `${this.eventName}${t}${e}->${this.identifier}#${this.methodName}`
        }
        shouldIgnoreKeyboardEvent(t) {
            if (!this.keyFilter)
                return !1;
            let e = this.keyFilter.split("+");
            if (this.keyFilterDissatisfied(t, e))
                return !0;
            let s = e.filter(r => !jf.includes(r))[0];
            return s ? (Nc(this.keyMappings, s) || Ta(`contains unknown key filter: ${this.keyFilter}`),
            this.keyMappings[s].toLowerCase() !== t.key.toLowerCase()) : !1
        }
        shouldIgnoreMouseEvent(t) {
            if (!this.keyFilter)
                return !1;
            let e = [this.keyFilter];
            return !!this.keyFilterDissatisfied(t, e)
        }
        get params() {
            let t = {}
              , e = new RegExp(`^data-${this.identifier}-(.+)-param$`,"i");
            for (let {name: s, value: r} of Array.from(this.element.attributes)) {
                let a = s.match(e)
                  , l = a && a[1];
                l && (t[iu(l)] = Mb(r))
            }
            return t
        }
        get eventTargetName() {
            return Cb(this.eventTarget)
        }
        get keyMappings() {
            return this.schema.keyMappings
        }
        keyFilterDissatisfied(t, e) {
            let[s,r,a,l] = jf.map(u => e.includes(u));
            return t.metaKey !== s || t.ctrlKey !== r || t.altKey !== a || t.shiftKey !== l
        }
    }
      , Wf = {
        a: o( () => "click", "a"),
        button: o( () => "click", "button"),
        form: o( () => "submit", "form"),
        details: o( () => "toggle", "details"),
        input: o(n => n.getAttribute("type") == "submit" ? "click" : "input", "input"),
        select: o( () => "change", "select"),
        textarea: o( () => "input", "textarea")
    };
    function kb(n) {
        let t = n.tagName.toLowerCase();
        if (t in Wf)
            return Wf[t](n)
    }
    o(kb, "getDefaultEventNameForElement");
    function Ta(n) {
        throw new Error(n)
    }
    o(Ta, "error");
    function Mb(n) {
        try {
            return JSON.parse(n)
        } catch {
            return n
        }
    }
    o(Mb, "typecast");
    var Vc = class {
        static{o(this, "Binding")
        }constructor(t, e) {
            this.context = t,
            this.action = e
        }
        get index() {
            return this.action.index
        }
        get eventTarget() {
            return this.action.eventTarget
        }
        get eventOptions() {
            return this.action.eventOptions
        }
        get identifier() {
            return this.context.identifier
        }
        handleEvent(t) {
            let e = this.prepareActionEvent(t);
            this.willBeInvokedByEvent(t) && this.applyEventModifiers(e) && this.invokeWithEvent(e)
        }
        get eventName() {
            return this.action.eventName
        }
        get method() {
            let t = this.controller[this.methodName];
            if (typeof t == "function")
                return t;
            throw new Error(`Action "${this.action}" references undefined method "${this.methodName}"`)
        }
        applyEventModifiers(t) {
            let {element: e} = this.action
              , {actionDescriptorFilters: s} = this.context.application
              , {controller: r} = this.context
              , a = !0;
            for (let[l,u] of Object.entries(this.eventOptions))
                if (l in s) {
                    let d = s[l];
                    a = a && d({
                        name: l,
                        value: u,
                        event: t,
                        element: e,
                        controller: r
                    })
                } else
                    continue;
            return a
        }
        prepareActionEvent(t) {
            return Object.assign(t, {
                params: this.action.params
            })
        }
        invokeWithEvent(t) {
            let {target: e, currentTarget: s} = t;
            try {
                this.method.call(this.controller, t),
                this.context.logDebugActivity(this.methodName, {
                    event: t,
                    target: e,
                    currentTarget: s,
                    action: this.methodName
                })
            } catch (r) {
                let {identifier: a, controller: l, element: u, index: d} = this
                  , p = {
                    identifier: a,
                    controller: l,
                    element: u,
                    index: d,
                    event: t
                };
                this.context.handleError(r, `invoking action "${this.action}"`, p)
            }
        }
        willBeInvokedByEvent(t) {
            let e = t.target;
            return t instanceof KeyboardEvent && this.action.shouldIgnoreKeyboardEvent(t) || t instanceof MouseEvent && this.action.shouldIgnoreMouseEvent(t) ? !1 : this.element === e ? !0 : e instanceof Element && this.element.contains(e) ? this.scope.containsElement(e) : this.scope.containsElement(this.action.element)
        }
        get controller() {
            return this.context.controller
        }
        get methodName() {
            return this.action.methodName
        }
        get element() {
            return this.scope.element
        }
        get scope() {
            return this.context.scope
        }
    }
      , xa = class {
        static{o(this, "ElementObserver")
        }constructor(t, e) {
            this.mutationObserverInit = {
                attributes: !0,
                childList: !0,
                subtree: !0
            },
            this.element = t,
            this.started = !1,
            this.delegate = e,
            this.elements = new Set,
            this.mutationObserver = new MutationObserver(s => this.processMutations(s))
        }
        start() {
            this.started || (this.started = !0,
            this.mutationObserver.observe(this.element, this.mutationObserverInit),
            this.refresh())
        }
        pause(t) {
            this.started && (this.mutationObserver.disconnect(),
            this.started = !1),
            t(),
            this.started || (this.mutationObserver.observe(this.element, this.mutationObserverInit),
            this.started = !0)
        }
        stop() {
            this.started && (this.mutationObserver.takeRecords(),
            this.mutationObserver.disconnect(),
            this.started = !1)
        }
        refresh() {
            if (this.started) {
                let t = new Set(this.matchElementsInTree());
                for (let e of Array.from(this.elements))
                    t.has(e) || this.removeElement(e);
                for (let e of Array.from(t))
                    this.addElement(e)
            }
        }
        processMutations(t) {
            if (this.started)
                for (let e of t)
                    this.processMutation(e)
        }
        processMutation(t) {
            t.type == "attributes" ? this.processAttributeChange(t.target, t.attributeName) : t.type == "childList" && (this.processRemovedNodes(t.removedNodes),
            this.processAddedNodes(t.addedNodes))
        }
        processAttributeChange(t, e) {
            this.elements.has(t) ? this.delegate.elementAttributeChanged && this.matchElement(t) ? this.delegate.elementAttributeChanged(t, e) : this.removeElement(t) : this.matchElement(t) && this.addElement(t)
        }
        processRemovedNodes(t) {
            for (let e of Array.from(t)) {
                let s = this.elementFromNode(e);
                s && this.processTree(s, this.removeElement)
            }
        }
        processAddedNodes(t) {
            for (let e of Array.from(t)) {
                let s = this.elementFromNode(e);
                s && this.elementIsActive(s) && this.processTree(s, this.addElement)
            }
        }
        matchElement(t) {
            return this.delegate.matchElement(t)
        }
        matchElementsInTree(t=this.element) {
            return this.delegate.matchElementsInTree(t)
        }
        processTree(t, e) {
            for (let s of this.matchElementsInTree(t))
                e.call(this, s)
        }
        elementFromNode(t) {
            if (t.nodeType == Node.ELEMENT_NODE)
                return t
        }
        elementIsActive(t) {
            return t.isConnected != this.element.isConnected ? !1 : this.element.contains(t)
        }
        addElement(t) {
            this.elements.has(t) || this.elementIsActive(t) && (this.elements.add(t),
            this.delegate.elementMatched && this.delegate.elementMatched(t))
        }
        removeElement(t) {
            this.elements.has(t) && (this.elements.delete(t),
            this.delegate.elementUnmatched && this.delegate.elementUnmatched(t))
        }
    }
      , wa = class {
        static{o(this, "AttributeObserver")
        }constructor(t, e, s) {
            this.attributeName = e,
            this.delegate = s,
            this.elementObserver = new xa(t,this)
        }
        get element() {
            return this.elementObserver.element
        }
        get selector() {
            return `[${this.attributeName}]`
        }
        start() {
            this.elementObserver.start()
        }
        pause(t) {
            this.elementObserver.pause(t)
        }
        stop() {
            this.elementObserver.stop()
        }
        refresh() {
            this.elementObserver.refresh()
        }
        get started() {
            return this.elementObserver.started
        }
        matchElement(t) {
            return t.hasAttribute(this.attributeName)
        }
        matchElementsInTree(t) {
            let e = this.matchElement(t) ? [t] : []
              , s = Array.from(t.querySelectorAll(this.selector));
            return e.concat(s)
        }
        elementMatched(t) {
            this.delegate.elementMatchedAttribute && this.delegate.elementMatchedAttribute(t, this.attributeName)
        }
        elementUnmatched(t) {
            this.delegate.elementUnmatchedAttribute && this.delegate.elementUnmatchedAttribute(t, this.attributeName)
        }
        elementAttributeChanged(t, e) {
            this.delegate.elementAttributeValueChanged && this.attributeName == e && this.delegate.elementAttributeValueChanged(t, e)
        }
    }
    ;
    function Ob(n, t, e) {
        Gf(n, t).add(e)
    }
    o(Ob, "add");
    function Lb(n, t, e) {
        Gf(n, t).delete(e),
        Db(n, t)
    }
    o(Lb, "del");
    function Gf(n, t) {
        let e = n.get(t);
        return e || (e = new Set,
        n.set(t, e)),
        e
    }
    o(Gf, "fetch");
    function Db(n, t) {
        let e = n.get(t);
        e != null && e.size == 0 && n.delete(t)
    }
    o(Db, "prune");
    var dn = class {
        static{o(this, "Multimap")
        }constructor() {
            this.valuesByKey = new Map
        }
        get keys() {
            return Array.from(this.valuesByKey.keys())
        }
        get values() {
            return Array.from(this.valuesByKey.values()).reduce( (e, s) => e.concat(Array.from(s)), [])
        }
        get size() {
            return Array.from(this.valuesByKey.values()).reduce( (e, s) => e + s.size, 0)
        }
        add(t, e) {
            Ob(this.valuesByKey, t, e)
        }
        delete(t, e) {
            Lb(this.valuesByKey, t, e)
        }
        has(t, e) {
            let s = this.valuesByKey.get(t);
            return s != null && s.has(e)
        }
        hasKey(t) {
            return this.valuesByKey.has(t)
        }
        hasValue(t) {
            return Array.from(this.valuesByKey.values()).some(s => s.has(t))
        }
        getValuesForKey(t) {
            let e = this.valuesByKey.get(t);
            return e ? Array.from(e) : []
        }
        getKeysForValue(t) {
            return Array.from(this.valuesByKey).filter( ([e,s]) => s.has(t)).map( ([e,s]) => e)
        }
    }
    ;
    var Bc = class {
        static{o(this, "SelectorObserver")
        }constructor(t, e, s, r) {
            this._selector = e,
            this.details = r,
            this.elementObserver = new xa(t,this),
            this.delegate = s,
            this.matchesByElement = new dn
        }
        get started() {
            return this.elementObserver.started
        }
        get selector() {
            return this._selector
        }
        set selector(t) {
            this._selector = t,
            this.refresh()
        }
        start() {
            this.elementObserver.start()
        }
        pause(t) {
            this.elementObserver.pause(t)
        }
        stop() {
            this.elementObserver.stop()
        }
        refresh() {
            this.elementObserver.refresh()
        }
        get element() {
            return this.elementObserver.element
        }
        matchElement(t) {
            let {selector: e} = this;
            if (e) {
                let s = t.matches(e);
                return this.delegate.selectorMatchElement ? s && this.delegate.selectorMatchElement(t, this.details) : s
            } else
                return !1
        }
        matchElementsInTree(t) {
            let {selector: e} = this;
            if (e) {
                let s = this.matchElement(t) ? [t] : []
                  , r = Array.from(t.querySelectorAll(e)).filter(a => this.matchElement(a));
                return s.concat(r)
            } else
                return []
        }
        elementMatched(t) {
            let {selector: e} = this;
            e && this.selectorMatched(t, e)
        }
        elementUnmatched(t) {
            let e = this.matchesByElement.getKeysForValue(t);
            for (let s of e)
                this.selectorUnmatched(t, s)
        }
        elementAttributeChanged(t, e) {
            let {selector: s} = this;
            if (s) {
                let r = this.matchElement(t)
                  , a = this.matchesByElement.has(s, t);
                r && !a ? this.selectorMatched(t, s) : !r && a && this.selectorUnmatched(t, s)
            }
        }
        selectorMatched(t, e) {
            this.delegate.selectorMatched(t, e, this.details),
            this.matchesByElement.add(e, t)
        }
        selectorUnmatched(t, e) {
            this.delegate.selectorUnmatched(t, e, this.details),
            this.matchesByElement.delete(e, t)
        }
    }
      , Hc = class {
        static{o(this, "StringMapObserver")
        }constructor(t, e) {
            this.element = t,
            this.delegate = e,
            this.started = !1,
            this.stringMap = new Map,
            this.mutationObserver = new MutationObserver(s => this.processMutations(s))
        }
        start() {
            this.started || (this.started = !0,
            this.mutationObserver.observe(this.element, {
                attributes: !0,
                attributeOldValue: !0
            }),
            this.refresh())
        }
        stop() {
            this.started && (this.mutationObserver.takeRecords(),
            this.mutationObserver.disconnect(),
            this.started = !1)
        }
        refresh() {
            if (this.started)
                for (let t of this.knownAttributeNames)
                    this.refreshAttribute(t, null)
        }
        processMutations(t) {
            if (this.started)
                for (let e of t)
                    this.processMutation(e)
        }
        processMutation(t) {
            let e = t.attributeName;
            e && this.refreshAttribute(e, t.oldValue)
        }
        refreshAttribute(t, e) {
            let s = this.delegate.getStringMapKeyForAttribute(t);
            if (s != null) {
                this.stringMap.has(t) || this.stringMapKeyAdded(s, t);
                let r = this.element.getAttribute(t);
                if (this.stringMap.get(t) != r && this.stringMapValueChanged(r, s, e),
                r == null) {
                    let a = this.stringMap.get(t);
                    this.stringMap.delete(t),
                    a && this.stringMapKeyRemoved(s, t, a)
                } else
                    this.stringMap.set(t, r)
            }
        }
        stringMapKeyAdded(t, e) {
            this.delegate.stringMapKeyAdded && this.delegate.stringMapKeyAdded(t, e)
        }
        stringMapValueChanged(t, e, s) {
            this.delegate.stringMapValueChanged && this.delegate.stringMapValueChanged(t, e, s)
        }
        stringMapKeyRemoved(t, e, s) {
            this.delegate.stringMapKeyRemoved && this.delegate.stringMapKeyRemoved(t, e, s)
        }
        get knownAttributeNames() {
            return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)))
        }
        get currentAttributeNames() {
            return Array.from(this.element.attributes).map(t => t.name)
        }
        get recordedAttributeNames() {
            return Array.from(this.stringMap.keys())
        }
    }
      , Ca = class {
        static{o(this, "TokenListObserver")
        }constructor(t, e, s) {
            this.attributeObserver = new wa(t,e,this),
            this.delegate = s,
            this.tokensByElement = new dn
        }
        get started() {
            return this.attributeObserver.started
        }
        start() {
            this.attributeObserver.start()
        }
        pause(t) {
            this.attributeObserver.pause(t)
        }
        stop() {
            this.attributeObserver.stop()
        }
        refresh() {
            this.attributeObserver.refresh()
        }
        get element() {
            return this.attributeObserver.element
        }
        get attributeName() {
            return this.attributeObserver.attributeName
        }
        elementMatchedAttribute(t) {
            this.tokensMatched(this.readTokensForElement(t))
        }
        elementAttributeValueChanged(t) {
            let[e,s] = this.refreshTokensForElement(t);
            this.tokensUnmatched(e),
            this.tokensMatched(s)
        }
        elementUnmatchedAttribute(t) {
            this.tokensUnmatched(this.tokensByElement.getValuesForKey(t))
        }
        tokensMatched(t) {
            t.forEach(e => this.tokenMatched(e))
        }
        tokensUnmatched(t) {
            t.forEach(e => this.tokenUnmatched(e))
        }
        tokenMatched(t) {
            this.delegate.tokenMatched(t),
            this.tokensByElement.add(t.element, t)
        }
        tokenUnmatched(t) {
            this.delegate.tokenUnmatched(t),
            this.tokensByElement.delete(t.element, t)
        }
        refreshTokensForElement(t) {
            let e = this.tokensByElement.getValuesForKey(t)
              , s = this.readTokensForElement(t)
              , r = Rb(e, s).findIndex( ([a,l]) => !Ib(a, l));
            return r == -1 ? [[], []] : [e.slice(r), s.slice(r)]
        }
        readTokensForElement(t) {
            let e = this.attributeName
              , s = t.getAttribute(e) || "";
            return Pb(s, t, e)
        }
    }
    ;
    function Pb(n, t, e) {
        return n.trim().split(/\s+/).filter(s => s.length).map( (s, r) => ({
            element: t,
            attributeName: e,
            content: s,
            index: r
        }))
    }
    o(Pb, "parseTokenString");
    function Rb(n, t) {
        let e = Math.max(n.length, t.length);
        return Array.from({
            length: e
        }, (s, r) => [n[r], t[r]])
    }
    o(Rb, "zip");
    function Ib(n, t) {
        return n && t && n.index == t.index && n.content == t.content
    }
    o(Ib, "tokensAreEqual");
    var Aa = class {
        static{o(this, "ValueListObserver")
        }constructor(t, e, s) {
            this.tokenListObserver = new Ca(t,e,this),
            this.delegate = s,
            this.parseResultsByToken = new WeakMap,
            this.valuesByTokenByElement = new WeakMap
        }
        get started() {
            return this.tokenListObserver.started
        }
        start() {
            this.tokenListObserver.start()
        }
        stop() {
            this.tokenListObserver.stop()
        }
        refresh() {
            this.tokenListObserver.refresh()
        }
        get element() {
            return this.tokenListObserver.element
        }
        get attributeName() {
            return this.tokenListObserver.attributeName
        }
        tokenMatched(t) {
            let {element: e} = t
              , {value: s} = this.fetchParseResultForToken(t);
            s && (this.fetchValuesByTokenForElement(e).set(t, s),
            this.delegate.elementMatchedValue(e, s))
        }
        tokenUnmatched(t) {
            let {element: e} = t
              , {value: s} = this.fetchParseResultForToken(t);
            s && (this.fetchValuesByTokenForElement(e).delete(t),
            this.delegate.elementUnmatchedValue(e, s))
        }
        fetchParseResultForToken(t) {
            let e = this.parseResultsByToken.get(t);
            return e || (e = this.parseToken(t),
            this.parseResultsByToken.set(t, e)),
            e
        }
        fetchValuesByTokenForElement(t) {
            let e = this.valuesByTokenByElement.get(t);
            return e || (e = new Map,
            this.valuesByTokenByElement.set(t, e)),
            e
        }
        parseToken(t) {
            try {
                return {
                    value: this.delegate.parseValueForToken(t)
                }
            } catch (e) {
                return {
                    error: e
                }
            }
        }
    }
      , jc = class {
        static{o(this, "BindingObserver")
        }constructor(t, e) {
            this.context = t,
            this.delegate = e,
            this.bindingsByAction = new Map
        }
        start() {
            this.valueListObserver || (this.valueListObserver = new Aa(this.element,this.actionAttribute,this),
            this.valueListObserver.start())
        }
        stop() {
            this.valueListObserver && (this.valueListObserver.stop(),
            delete this.valueListObserver,
            this.disconnectAllActions())
        }
        get element() {
            return this.context.element
        }
        get identifier() {
            return this.context.identifier
        }
        get actionAttribute() {
            return this.schema.actionAttribute
        }
        get schema() {
            return this.context.schema
        }
        get bindings() {
            return Array.from(this.bindingsByAction.values())
        }
        connectAction(t) {
            let e = new Vc(this.context,t);
            this.bindingsByAction.set(t, e),
            this.delegate.bindingConnected(e)
        }
        disconnectAction(t) {
            let e = this.bindingsByAction.get(t);
            e && (this.bindingsByAction.delete(t),
            this.delegate.bindingDisconnected(e))
        }
        disconnectAllActions() {
            this.bindings.forEach(t => this.delegate.bindingDisconnected(t, !0)),
            this.bindingsByAction.clear()
        }
        parseValueForToken(t) {
            let e = Fc.forToken(t, this.schema);
            if (e.identifier == this.identifier)
                return e
        }
        elementMatchedValue(t, e) {
            this.connectAction(e)
        }
        elementUnmatchedValue(t, e) {
            this.disconnectAction(e)
        }
    }
      , Wc = class {
        static{o(this, "ValueObserver")
        }constructor(t, e) {
            this.context = t,
            this.receiver = e,
            this.stringMapObserver = new Hc(this.element,this),
            this.valueDescriptorMap = this.controller.valueDescriptorMap
        }
        start() {
            this.stringMapObserver.start(),
            this.invokeChangedCallbacksForDefaultValues()
        }
        stop() {
            this.stringMapObserver.stop()
        }
        get element() {
            return this.context.element
        }
        get controller() {
            return this.context.controller
        }
        getStringMapKeyForAttribute(t) {
            if (t in this.valueDescriptorMap)
                return this.valueDescriptorMap[t].name
        }
        stringMapKeyAdded(t, e) {
            let s = this.valueDescriptorMap[e];
            this.hasValue(t) || this.invokeChangedCallback(t, s.writer(this.receiver[t]), s.writer(s.defaultValue))
        }
        stringMapValueChanged(t, e, s) {
            let r = this.valueDescriptorNameMap[e];
            t !== null && (s === null && (s = r.writer(r.defaultValue)),
            this.invokeChangedCallback(e, t, s))
        }
        stringMapKeyRemoved(t, e, s) {
            let r = this.valueDescriptorNameMap[t];
            this.hasValue(t) ? this.invokeChangedCallback(t, r.writer(this.receiver[t]), s) : this.invokeChangedCallback(t, r.writer(r.defaultValue), s)
        }
        invokeChangedCallbacksForDefaultValues() {
            for (let {key: t, name: e, defaultValue: s, writer: r} of this.valueDescriptors)
                s != null && !this.controller.data.has(t) && this.invokeChangedCallback(e, r(s), void 0)
        }
        invokeChangedCallback(t, e, s) {
            let r = `${t}Changed`
              , a = this.receiver[r];
            if (typeof a == "function") {
                let l = this.valueDescriptorNameMap[t];
                try {
                    let u = l.reader(e)
                      , d = s;
                    s && (d = l.reader(s)),
                    a.call(this.receiver, u, d)
                } catch (u) {
                    throw u instanceof TypeError && (u.message = `Stimulus Value "${this.context.identifier}.${l.name}" - ${u.message}`),
                    u
                }
            }
        }
        get valueDescriptors() {
            let {valueDescriptorMap: t} = this;
            return Object.keys(t).map(e => t[e])
        }
        get valueDescriptorNameMap() {
            let t = {};
            return Object.keys(this.valueDescriptorMap).forEach(e => {
                let s = this.valueDescriptorMap[e];
                t[s.name] = s
            }
            ),
            t
        }
        hasValue(t) {
            let e = this.valueDescriptorNameMap[t]
              , s = `has${lo(e.name)}`;
            return this.receiver[s]
        }
    }
      , $c = class {
        static{o(this, "TargetObserver")
        }constructor(t, e) {
            this.context = t,
            this.delegate = e,
            this.targetsByName = new dn
        }
        start() {
            this.tokenListObserver || (this.tokenListObserver = new Ca(this.element,this.attributeName,this),
            this.tokenListObserver.start())
        }
        stop() {
            this.tokenListObserver && (this.disconnectAllTargets(),
            this.tokenListObserver.stop(),
            delete this.tokenListObserver)
        }
        tokenMatched({element: t, content: e}) {
            this.scope.containsElement(t) && this.connectTarget(t, e)
        }
        tokenUnmatched({element: t, content: e}) {
            this.disconnectTarget(t, e)
        }
        connectTarget(t, e) {
            var s;
            this.targetsByName.has(e, t) || (this.targetsByName.add(e, t),
            (s = this.tokenListObserver) === null || s === void 0 || s.pause( () => this.delegate.targetConnected(t, e)))
        }
        disconnectTarget(t, e) {
            var s;
            this.targetsByName.has(e, t) && (this.targetsByName.delete(e, t),
            (s = this.tokenListObserver) === null || s === void 0 || s.pause( () => this.delegate.targetDisconnected(t, e)))
        }
        disconnectAllTargets() {
            for (let t of this.targetsByName.keys)
                for (let e of this.targetsByName.getValuesForKey(t))
                    this.disconnectTarget(e, t)
        }
        get attributeName() {
            return `data-${this.context.identifier}-target`
        }
        get element() {
            return this.context.element
        }
        get scope() {
            return this.context.scope
        }
    }
    ;
    function co(n, t) {
        let e = Qf(n);
        return Array.from(e.reduce( (s, r) => (Fb(r, t).forEach(a => s.add(a)),
        s), new Set))
    }
    o(co, "readInheritableStaticArrayValues");
    function Nb(n, t) {
        return Qf(n).reduce( (s, r) => (s.push(...Vb(r, t)),
        s), [])
    }
    o(Nb, "readInheritableStaticObjectPairs");
    function Qf(n) {
        let t = [];
        for (; n; )
            t.push(n),
            n = Object.getPrototypeOf(n);
        return t.reverse()
    }
    o(Qf, "getAncestorsForConstructor");
    function Fb(n, t) {
        let e = n[t];
        return Array.isArray(e) ? e : []
    }
    o(Fb, "getOwnStaticArrayValues");
    function Vb(n, t) {
        let e = n[t];
        return e ? Object.keys(e).map(s => [s, e[s]]) : []
    }
    o(Vb, "getOwnStaticObjectPairs");
    var qc = class {
        static{o(this, "OutletObserver")
        }constructor(t, e) {
            this.started = !1,
            this.context = t,
            this.delegate = e,
            this.outletsByName = new dn,
            this.outletElementsByName = new dn,
            this.selectorObserverMap = new Map,
            this.attributeObserverMap = new Map
        }
        start() {
            this.started || (this.outletDefinitions.forEach(t => {
                this.setupSelectorObserverForOutlet(t),
                this.setupAttributeObserverForOutlet(t)
            }
            ),
            this.started = !0,
            this.dependentContexts.forEach(t => t.refresh()))
        }
        refresh() {
            this.selectorObserverMap.forEach(t => t.refresh()),
            this.attributeObserverMap.forEach(t => t.refresh())
        }
        stop() {
            this.started && (this.started = !1,
            this.disconnectAllOutlets(),
            this.stopSelectorObservers(),
            this.stopAttributeObservers())
        }
        stopSelectorObservers() {
            this.selectorObserverMap.size > 0 && (this.selectorObserverMap.forEach(t => t.stop()),
            this.selectorObserverMap.clear())
        }
        stopAttributeObservers() {
            this.attributeObserverMap.size > 0 && (this.attributeObserverMap.forEach(t => t.stop()),
            this.attributeObserverMap.clear())
        }
        selectorMatched(t, e, {outletName: s}) {
            let r = this.getOutlet(t, s);
            r && this.connectOutlet(r, t, s)
        }
        selectorUnmatched(t, e, {outletName: s}) {
            let r = this.getOutletFromMap(t, s);
            r && this.disconnectOutlet(r, t, s)
        }
        selectorMatchElement(t, {outletName: e}) {
            let s = this.selector(e)
              , r = this.hasOutlet(t, e)
              , a = t.matches(`[${this.schema.controllerAttribute}~=${e}]`);
            return s ? r && a && t.matches(s) : !1
        }
        elementMatchedAttribute(t, e) {
            let s = this.getOutletNameFromOutletAttributeName(e);
            s && this.updateSelectorObserverForOutlet(s)
        }
        elementAttributeValueChanged(t, e) {
            let s = this.getOutletNameFromOutletAttributeName(e);
            s && this.updateSelectorObserverForOutlet(s)
        }
        elementUnmatchedAttribute(t, e) {
            let s = this.getOutletNameFromOutletAttributeName(e);
            s && this.updateSelectorObserverForOutlet(s)
        }
        connectOutlet(t, e, s) {
            var r;
            this.outletElementsByName.has(s, e) || (this.outletsByName.add(s, t),
            this.outletElementsByName.add(s, e),
            (r = this.selectorObserverMap.get(s)) === null || r === void 0 || r.pause( () => this.delegate.outletConnected(t, e, s)))
        }
        disconnectOutlet(t, e, s) {
            var r;
            this.outletElementsByName.has(s, e) && (this.outletsByName.delete(s, t),
            this.outletElementsByName.delete(s, e),
            (r = this.selectorObserverMap.get(s)) === null || r === void 0 || r.pause( () => this.delegate.outletDisconnected(t, e, s)))
        }
        disconnectAllOutlets() {
            for (let t of this.outletElementsByName.keys)
                for (let e of this.outletElementsByName.getValuesForKey(t))
                    for (let s of this.outletsByName.getValuesForKey(t))
                        this.disconnectOutlet(s, e, t)
        }
        updateSelectorObserverForOutlet(t) {
            let e = this.selectorObserverMap.get(t);
            e && (e.selector = this.selector(t))
        }
        setupSelectorObserverForOutlet(t) {
            let e = this.selector(t)
              , s = new Bc(document.body,e,this,{
                outletName: t
            });
            this.selectorObserverMap.set(t, s),
            s.start()
        }
        setupAttributeObserverForOutlet(t) {
            let e = this.attributeNameForOutletName(t)
              , s = new wa(this.scope.element,e,this);
            this.attributeObserverMap.set(t, s),
            s.start()
        }
        selector(t) {
            return this.scope.outlets.getSelectorForOutletName(t)
        }
        attributeNameForOutletName(t) {
            return this.scope.schema.outletAttributeForScope(this.identifier, t)
        }
        getOutletNameFromOutletAttributeName(t) {
            return this.outletDefinitions.find(e => this.attributeNameForOutletName(e) === t)
        }
        get outletDependencies() {
            let t = new dn;
            return this.router.modules.forEach(e => {
                let s = e.definition.controllerConstructor;
                co(s, "outlets").forEach(a => t.add(a, e.identifier))
            }
            ),
            t
        }
        get outletDefinitions() {
            return this.outletDependencies.getKeysForValue(this.identifier)
        }
        get dependentControllerIdentifiers() {
            return this.outletDependencies.getValuesForKey(this.identifier)
        }
        get dependentContexts() {
            let t = this.dependentControllerIdentifiers;
            return this.router.contexts.filter(e => t.includes(e.identifier))
        }
        hasOutlet(t, e) {
            return !!this.getOutlet(t, e) || !!this.getOutletFromMap(t, e)
        }
        getOutlet(t, e) {
            return this.application.getControllerForElementAndIdentifier(t, e)
        }
        getOutletFromMap(t, e) {
            return this.outletsByName.getValuesForKey(e).find(s => s.element === t)
        }
        get scope() {
            return this.context.scope
        }
        get schema() {
            return this.context.schema
        }
        get identifier() {
            return this.context.identifier
        }
        get application() {
            return this.context.application
        }
        get router() {
            return this.application.router
        }
    }
      , zc = class {
        static{o(this, "Context")
        }constructor(t, e) {
            this.logDebugActivity = (s, r={}) => {
                let {identifier: a, controller: l, element: u} = this;
                r = Object.assign({
                    identifier: a,
                    controller: l,
                    element: u
                }, r),
                this.application.logDebugActivity(this.identifier, s, r)
            }
            ,
            this.module = t,
            this.scope = e,
            this.controller = new t.controllerConstructor(this),
            this.bindingObserver = new jc(this,this.dispatcher),
            this.valueObserver = new Wc(this,this.controller),
            this.targetObserver = new $c(this,this),
            this.outletObserver = new qc(this,this);
            try {
                this.controller.initialize(),
                this.logDebugActivity("initialize")
            } catch (s) {
                this.handleError(s, "initializing controller")
            }
        }
        connect() {
            this.bindingObserver.start(),
            this.valueObserver.start(),
            this.targetObserver.start(),
            this.outletObserver.start();
            try {
                this.controller.connect(),
                this.logDebugActivity("connect")
            } catch (t) {
                this.handleError(t, "connecting controller")
            }
        }
        refresh() {
            this.outletObserver.refresh()
        }
        disconnect() {
            try {
                this.controller.disconnect(),
                this.logDebugActivity("disconnect")
            } catch (t) {
                this.handleError(t, "disconnecting controller")
            }
            this.outletObserver.stop(),
            this.targetObserver.stop(),
            this.valueObserver.stop(),
            this.bindingObserver.stop()
        }
        get application() {
            return this.module.application
        }
        get identifier() {
            return this.module.identifier
        }
        get schema() {
            return this.application.schema
        }
        get dispatcher() {
            return this.application.dispatcher
        }
        get element() {
            return this.scope.element
        }
        get parentElement() {
            return this.element.parentElement
        }
        handleError(t, e, s={}) {
            let {identifier: r, controller: a, element: l} = this;
            s = Object.assign({
                identifier: r,
                controller: a,
                element: l
            }, s),
            this.application.handleError(t, `Error ${e}`, s)
        }
        targetConnected(t, e) {
            this.invokeControllerMethod(`${e}TargetConnected`, t)
        }
        targetDisconnected(t, e) {
            this.invokeControllerMethod(`${e}TargetDisconnected`, t)
        }
        outletConnected(t, e, s) {
            this.invokeControllerMethod(`${Ic(s)}OutletConnected`, t, e)
        }
        outletDisconnected(t, e, s) {
            this.invokeControllerMethod(`${Ic(s)}OutletDisconnected`, t, e)
        }
        invokeControllerMethod(t, ...e) {
            let s = this.controller;
            typeof s[t] == "function" && s[t](...e)
        }
    }
    ;
    function Bb(n) {
        return Hb(n, jb(n))
    }
    o(Bb, "bless");
    function Hb(n, t) {
        let e = zb(n)
          , s = Wb(n.prototype, t);
        return Object.defineProperties(e.prototype, s),
        e
    }
    o(Hb, "shadow");
    function jb(n) {
        return co(n, "blessings").reduce( (e, s) => {
            let r = s(n);
            for (let a in r) {
                let l = e[a] || {};
                e[a] = Object.assign(l, r[a])
            }
            return e
        }
        , {})
    }
    o(jb, "getBlessedProperties");
    function Wb(n, t) {
        return qb(t).reduce( (e, s) => {
            let r = $b(n, t, s);
            return r && Object.assign(e, {
                [s]: r
            }),
            e
        }
        , {})
    }
    o(Wb, "getShadowProperties");
    function $b(n, t, e) {
        let s = Object.getOwnPropertyDescriptor(n, e);
        if (!(s && "value"in s)) {
            let a = Object.getOwnPropertyDescriptor(t, e).value;
            return s && (a.get = s.get || a.get,
            a.set = s.set || a.set),
            a
        }
    }
    o($b, "getShadowedDescriptor");
    var qb = typeof Object.getOwnPropertySymbols == "function" ? n => [...Object.getOwnPropertyNames(n), ...Object.getOwnPropertySymbols(n)] : Object.getOwnPropertyNames
      , zb = ( () => {
        function n(e) {
            function s() {
                return Reflect.construct(e, arguments, new.target)
            }
            return o(s, "extended"),
            s.prototype = Object.create(e.prototype, {
                constructor: {
                    value: s
                }
            }),
            Reflect.setPrototypeOf(s, e),
            s
        }
        o(n, "extendWithReflect");
        function t() {
            let s = n(o(function() {
                this.a.call(this)
            }, "a"));
            return s.prototype.a = function() {}
            ,
            new s
        }
        o(t, "testReflectExtension");
        try {
            return t(),
            n
        } catch {
            return s => class extends s {
                static{o(this, "extended")
                }
            }
        }
    }
    )();
    function Ub(n) {
        return {
            identifier: n.identifier,
            controllerConstructor: Bb(n.controllerConstructor)
        }
    }
    o(Ub, "blessDefinition");
    var Uc = class {
        static{o(this, "Module")
        }constructor(t, e) {
            this.application = t,
            this.definition = Ub(e),
            this.contextsByScope = new WeakMap,
            this.connectedContexts = new Set
        }
        get identifier() {
            return this.definition.identifier
        }
        get controllerConstructor() {
            return this.definition.controllerConstructor
        }
        get contexts() {
            return Array.from(this.connectedContexts)
        }
        connectContextForScope(t) {
            let e = this.fetchContextForScope(t);
            this.connectedContexts.add(e),
            e.connect()
        }
        disconnectContextForScope(t) {
            let e = this.contextsByScope.get(t);
            e && (this.connectedContexts.delete(e),
            e.disconnect())
        }
        fetchContextForScope(t) {
            let e = this.contextsByScope.get(t);
            return e || (e = new zc(this,t),
            this.contextsByScope.set(t, e)),
            e
        }
    }
      , Kc = class {
        static{o(this, "ClassMap")
        }constructor(t) {
            this.scope = t
        }
        has(t) {
            return this.data.has(this.getDataKey(t))
        }
        get(t) {
            return this.getAll(t)[0]
        }
        getAll(t) {
            let e = this.data.get(this.getDataKey(t)) || "";
            return Ab(e)
        }
        getAttributeName(t) {
            return this.data.getAttributeNameForKey(this.getDataKey(t))
        }
        getDataKey(t) {
            return `${t}-class`
        }
        get data() {
            return this.scope.data
        }
    }
      , Yc = class {
        static{o(this, "DataMap")
        }constructor(t) {
            this.scope = t
        }
        get element() {
            return this.scope.element
        }
        get identifier() {
            return this.scope.identifier
        }
        get(t) {
            let e = this.getAttributeNameForKey(t);
            return this.element.getAttribute(e)
        }
        set(t, e) {
            let s = this.getAttributeNameForKey(t);
            return this.element.setAttribute(s, e),
            this.get(t)
        }
        has(t) {
            let e = this.getAttributeNameForKey(t);
            return this.element.hasAttribute(e)
        }
        delete(t) {
            if (this.has(t)) {
                let e = this.getAttributeNameForKey(t);
                return this.element.removeAttribute(e),
                !0
            } else
                return !1
        }
        getAttributeNameForKey(t) {
            return `data-${this.identifier}-${Xf(t)}`
        }
    }
      , Xc = class {
        static{o(this, "Guide")
        }constructor(t) {
            this.warnedKeysByObject = new WeakMap,
            this.logger = t
        }
        warn(t, e, s) {
            let r = this.warnedKeysByObject.get(t);
            r || (r = new Set,
            this.warnedKeysByObject.set(t, r)),
            r.has(e) || (r.add(e),
            this.logger.warn(s, t))
        }
    }
    ;
    function Gc(n, t) {
        return `[${n}~="${t}"]`
    }
    o(Gc, "attributeValueContainsToken");
    var Qc = class {
        static{o(this, "TargetSet")
        }constructor(t) {
            this.scope = t
        }
        get element() {
            return this.scope.element
        }
        get identifier() {
            return this.scope.identifier
        }
        get schema() {
            return this.scope.schema
        }
        has(t) {
            return this.find(t) != null
        }
        find(...t) {
            return t.reduce( (e, s) => e || this.findTarget(s) || this.findLegacyTarget(s), void 0)
        }
        findAll(...t) {
            return t.reduce( (e, s) => [...e, ...this.findAllTargets(s), ...this.findAllLegacyTargets(s)], [])
        }
        findTarget(t) {
            let e = this.getSelectorForTargetName(t);
            return this.scope.findElement(e)
        }
        findAllTargets(t) {
            let e = this.getSelectorForTargetName(t);
            return this.scope.findAllElements(e)
        }
        getSelectorForTargetName(t) {
            let e = this.schema.targetAttributeForScope(this.identifier);
            return Gc(e, t)
        }
        findLegacyTarget(t) {
            let e = this.getLegacySelectorForTargetName(t);
            return this.deprecate(this.scope.findElement(e), t)
        }
        findAllLegacyTargets(t) {
            let e = this.getLegacySelectorForTargetName(t);
            return this.scope.findAllElements(e).map(s => this.deprecate(s, t))
        }
        getLegacySelectorForTargetName(t) {
            let e = `${this.identifier}.${t}`;
            return Gc(this.schema.targetAttribute, e)
        }
        deprecate(t, e) {
            if (t) {
                let {identifier: s} = this
                  , r = this.schema.targetAttribute
                  , a = this.schema.targetAttributeForScope(s);
                this.guide.warn(t, `target:${e}`, `Please replace ${r}="${s}.${e}" with ${a}="${e}". The ${r} attribute is deprecated and will be removed in a future version of Stimulus.`)
            }
            return t
        }
        get guide() {
            return this.scope.guide
        }
    }
      , Jc = class {
        static{o(this, "OutletSet")
        }constructor(t, e) {
            this.scope = t,
            this.controllerElement = e
        }
        get element() {
            return this.scope.element
        }
        get identifier() {
            return this.scope.identifier
        }
        get schema() {
            return this.scope.schema
        }
        has(t) {
            return this.find(t) != null
        }
        find(...t) {
            return t.reduce( (e, s) => e || this.findOutlet(s), void 0)
        }
        findAll(...t) {
            return t.reduce( (e, s) => [...e, ...this.findAllOutlets(s)], [])
        }
        getSelectorForOutletName(t) {
            let e = this.schema.outletAttributeForScope(this.identifier, t);
            return this.controllerElement.getAttribute(e)
        }
        findOutlet(t) {
            let e = this.getSelectorForOutletName(t);
            if (e)
                return this.findElement(e, t)
        }
        findAllOutlets(t) {
            let e = this.getSelectorForOutletName(t);
            return e ? this.findAllElements(e, t) : []
        }
        findElement(t, e) {
            return this.scope.queryElements(t).filter(r => this.matchesElement(r, t, e))[0]
        }
        findAllElements(t, e) {
            return this.scope.queryElements(t).filter(r => this.matchesElement(r, t, e))
        }
        matchesElement(t, e, s) {
            let r = t.getAttribute(this.scope.schema.controllerAttribute) || "";
            return t.matches(e) && r.split(" ").includes(s)
        }
    }
      , Zc = class n {
        static{o(this, "Scope")
        }constructor(t, e, s, r) {
            this.targets = new Qc(this),
            this.classes = new Kc(this),
            this.data = new Yc(this),
            this.containsElement = a => a.closest(this.controllerSelector) === this.element,
            this.schema = t,
            this.element = e,
            this.identifier = s,
            this.guide = new Xc(r),
            this.outlets = new Jc(this.documentScope,e)
        }
        findElement(t) {
            return this.element.matches(t) ? this.element : this.queryElements(t).find(this.containsElement)
        }
        findAllElements(t) {
            return [...this.element.matches(t) ? [this.element] : [], ...this.queryElements(t).filter(this.containsElement)]
        }
        queryElements(t) {
            return Array.from(this.element.querySelectorAll(t))
        }
        get controllerSelector() {
            return Gc(this.schema.controllerAttribute, this.identifier)
        }
        get isDocumentScope() {
            return this.element === document.documentElement
        }
        get documentScope() {
            return this.isDocumentScope ? this : new n(this.schema,document.documentElement,this.identifier,this.guide.logger)
        }
    }
      , tu = class {
        static{o(this, "ScopeObserver")
        }constructor(t, e, s) {
            this.element = t,
            this.schema = e,
            this.delegate = s,
            this.valueListObserver = new Aa(this.element,this.controllerAttribute,this),
            this.scopesByIdentifierByElement = new WeakMap,
            this.scopeReferenceCounts = new WeakMap
        }
        start() {
            this.valueListObserver.start()
        }
        stop() {
            this.valueListObserver.stop()
        }
        get controllerAttribute() {
            return this.schema.controllerAttribute
        }
        parseValueForToken(t) {
            let {element: e, content: s} = t;
            return this.parseValueForElementAndIdentifier(e, s)
        }
        parseValueForElementAndIdentifier(t, e) {
            let s = this.fetchScopesByIdentifierForElement(t)
              , r = s.get(e);
            return r || (r = this.delegate.createScopeForElementAndIdentifier(t, e),
            s.set(e, r)),
            r
        }
        elementMatchedValue(t, e) {
            let s = (this.scopeReferenceCounts.get(e) || 0) + 1;
            this.scopeReferenceCounts.set(e, s),
            s == 1 && this.delegate.scopeConnected(e)
        }
        elementUnmatchedValue(t, e) {
            let s = this.scopeReferenceCounts.get(e);
            s && (this.scopeReferenceCounts.set(e, s - 1),
            s == 1 && this.delegate.scopeDisconnected(e))
        }
        fetchScopesByIdentifierForElement(t) {
            let e = this.scopesByIdentifierByElement.get(t);
            return e || (e = new Map,
            this.scopesByIdentifierByElement.set(t, e)),
            e
        }
    }
      , eu = class {
        static{o(this, "Router")
        }constructor(t) {
            this.application = t,
            this.scopeObserver = new tu(this.element,this.schema,this),
            this.scopesByIdentifier = new dn,
            this.modulesByIdentifier = new Map
        }
        get element() {
            return this.application.element
        }
        get schema() {
            return this.application.schema
        }
        get logger() {
            return this.application.logger
        }
        get controllerAttribute() {
            return this.schema.controllerAttribute
        }
        get modules() {
            return Array.from(this.modulesByIdentifier.values())
        }
        get contexts() {
            return this.modules.reduce( (t, e) => t.concat(e.contexts), [])
        }
        start() {
            this.scopeObserver.start()
        }
        stop() {
            this.scopeObserver.stop()
        }
        loadDefinition(t) {
            this.unloadIdentifier(t.identifier);
            let e = new Uc(this.application,t);
            this.connectModule(e);
            let s = t.controllerConstructor.afterLoad;
            s && s.call(t.controllerConstructor, t.identifier, this.application)
        }
        unloadIdentifier(t) {
            let e = this.modulesByIdentifier.get(t);
            e && this.disconnectModule(e)
        }
        getContextForElementAndIdentifier(t, e) {
            let s = this.modulesByIdentifier.get(e);
            if (s)
                return s.contexts.find(r => r.element == t)
        }
        proposeToConnectScopeForElementAndIdentifier(t, e) {
            let s = this.scopeObserver.parseValueForElementAndIdentifier(t, e);
            s ? this.scopeObserver.elementMatchedValue(s.element, s) : console.error(`Couldn't find or create scope for identifier: "${e}" and element:`, t)
        }
        handleError(t, e, s) {
            this.application.handleError(t, e, s)
        }
        createScopeForElementAndIdentifier(t, e) {
            return new Zc(this.schema,t,e,this.logger)
        }
        scopeConnected(t) {
            this.scopesByIdentifier.add(t.identifier, t);
            let e = this.modulesByIdentifier.get(t.identifier);
            e && e.connectContextForScope(t)
        }
        scopeDisconnected(t) {
            this.scopesByIdentifier.delete(t.identifier, t);
            let e = this.modulesByIdentifier.get(t.identifier);
            e && e.disconnectContextForScope(t)
        }
        connectModule(t) {
            this.modulesByIdentifier.set(t.identifier, t),
            this.scopesByIdentifier.getValuesForKey(t.identifier).forEach(s => t.connectContextForScope(s))
        }
        disconnectModule(t) {
            this.modulesByIdentifier.delete(t.identifier),
            this.scopesByIdentifier.getValuesForKey(t.identifier).forEach(s => t.disconnectContextForScope(s))
        }
    }
      , Kb = {
        controllerAttribute: "data-controller",
        actionAttribute: "data-action",
        targetAttribute: "data-target",
        targetAttributeForScope: o(n => `data-${n}-target`, "targetAttributeForScope"),
        outletAttributeForScope: o( (n, t) => `data-${n}-${t}-outlet`, "outletAttributeForScope"),
        keyMappings: Object.assign(Object.assign({
            enter: "Enter",
            tab: "Tab",
            esc: "Escape",
            space: " ",
            up: "ArrowUp",
            down: "ArrowDown",
            left: "ArrowLeft",
            right: "ArrowRight",
            home: "Home",
            end: "End",
            page_up: "PageUp",
            page_down: "PageDown"
        }, $f("abcdefghijklmnopqrstuvwxyz".split("").map(n => [n, n]))), $f("0123456789".split("").map(n => [n, n])))
    };
    function $f(n) {
        return n.reduce( (t, [e,s]) => Object.assign(Object.assign({}, t), {
            [e]: s
        }), {})
    }
    o($f, "objectFromEntries");
    var ka = class {
        static{o(this, "Application")
        }constructor(t=document.documentElement, e=Kb) {
            this.logger = console,
            this.debug = !1,
            this.logDebugActivity = (s, r, a={}) => {
                this.debug && this.logFormattedMessage(s, r, a)
            }
            ,
            this.element = t,
            this.schema = e,
            this.dispatcher = new Rc(this),
            this.router = new eu(this),
            this.actionDescriptorFilters = Object.assign({}, Eb)
        }
        static start(t, e) {
            let s = new this(t,e);
            return s.start(),
            s
        }
        async start() {
            await Yb(),
            this.logDebugActivity("application", "starting"),
            this.dispatcher.start(),
            this.router.start(),
            this.logDebugActivity("application", "start")
        }
        stop() {
            this.logDebugActivity("application", "stopping"),
            this.dispatcher.stop(),
            this.router.stop(),
            this.logDebugActivity("application", "stop")
        }
        register(t, e) {
            this.load({
                identifier: t,
                controllerConstructor: e
            })
        }
        registerActionOption(t, e) {
            this.actionDescriptorFilters[t] = e
        }
        load(t, ...e) {
            (Array.isArray(t) ? t : [t, ...e]).forEach(r => {
                r.controllerConstructor.shouldLoad && this.router.loadDefinition(r)
            }
            )
        }
        unload(t, ...e) {
            (Array.isArray(t) ? t : [t, ...e]).forEach(r => this.router.unloadIdentifier(r))
        }
        get controllers() {
            return this.router.contexts.map(t => t.controller)
        }
        getControllerForElementAndIdentifier(t, e) {
            let s = this.router.getContextForElementAndIdentifier(t, e);
            return s ? s.controller : null
        }
        handleError(t, e, s) {
            var r;
            this.logger.error(`%s

%o

%o`, e, t, s),
            (r = window.onerror) === null || r === void 0 || r.call(window, e, "", 0, 0, t)
        }
        logFormattedMessage(t, e, s={}) {
            s = Object.assign({
                application: this
            }, s),
            this.logger.groupCollapsed(`${t} #${e}`),
            this.logger.log("details:", Object.assign({}, s)),
            this.logger.groupEnd()
        }
    }
    ;
    function Yb() {
        return new Promise(n => {
            document.readyState == "loading" ? document.addEventListener("DOMContentLoaded", () => n()) : n()
        }
        )
    }
    o(Yb, "domReady");
    function Xb(n) {
        return co(n, "classes").reduce( (e, s) => Object.assign(e, Gb(s)), {})
    }
    o(Xb, "ClassPropertiesBlessing");
    function Gb(n) {
        return {
            [`${n}Class`]: {
                get() {
                    let {classes: t} = this;
                    if (t.has(n))
                        return t.get(n);
                    {
                        let e = t.getAttributeName(n);
                        throw new Error(`Missing attribute "${e}"`)
                    }
                }
            },
            [`${n}Classes`]: {
                get() {
                    return this.classes.getAll(n)
                }
            },
            [`has${lo(n)}Class`]: {
                get() {
                    return this.classes.has(n)
                }
            }
        }
    }
    o(Gb, "propertiesForClassDefinition");
    function Qb(n) {
        return co(n, "outlets").reduce( (e, s) => Object.assign(e, Jb(s)), {})
    }
    o(Qb, "OutletPropertiesBlessing");
    function qf(n, t, e) {
        return n.application.getControllerForElementAndIdentifier(t, e)
    }
    o(qf, "getOutletController");
    function zf(n, t, e) {
        let s = qf(n, t, e);
        if (s || (n.application.router.proposeToConnectScopeForElementAndIdentifier(t, e),
        s = qf(n, t, e),
        s))
            return s
    }
    o(zf, "getControllerAndEnsureConnectedScope");
    function Jb(n) {
        let t = Ic(n);
        return {
            [`${t}Outlet`]: {
                get() {
                    let e = this.outlets.find(n)
                      , s = this.outlets.getSelectorForOutletName(n);
                    if (e) {
                        let r = zf(this, e, n);
                        if (r)
                            return r;
                        throw new Error(`The provided outlet element is missing an outlet controller "${n}" instance for host controller "${this.identifier}"`)
                    }
                    throw new Error(`Missing outlet element "${n}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${s}".`)
                }
            },
            [`${t}Outlets`]: {
                get() {
                    let e = this.outlets.findAll(n);
                    return e.length > 0 ? e.map(s => {
                        let r = zf(this, s, n);
                        if (r)
                            return r;
                        console.warn(`The provided outlet element is missing an outlet controller "${n}" instance for host controller "${this.identifier}"`, s)
                    }
                    ).filter(s => s) : []
                }
            },
            [`${t}OutletElement`]: {
                get() {
                    let e = this.outlets.find(n)
                      , s = this.outlets.getSelectorForOutletName(n);
                    if (e)
                        return e;
                    throw new Error(`Missing outlet element "${n}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${s}".`)
                }
            },
            [`${t}OutletElements`]: {
                get() {
                    return this.outlets.findAll(n)
                }
            },
            [`has${lo(t)}Outlet`]: {
                get() {
                    return this.outlets.has(n)
                }
            }
        }
    }
    o(Jb, "propertiesForOutletDefinition");
    function Zb(n) {
        return co(n, "targets").reduce( (e, s) => Object.assign(e, ty(s)), {})
    }
    o(Zb, "TargetPropertiesBlessing");
    function ty(n) {
        return {
            [`${n}Target`]: {
                get() {
                    let t = this.targets.find(n);
                    if (t)
                        return t;
                    throw new Error(`Missing target element "${n}" for "${this.identifier}" controller`)
                }
            },
            [`${n}Targets`]: {
                get() {
                    return this.targets.findAll(n)
                }
            },
            [`has${lo(n)}Target`]: {
                get() {
                    return this.targets.has(n)
                }
            }
        }
    }
    o(ty, "propertiesForTargetDefinition");
    function ey(n) {
        let t = Nb(n, "values")
          , e = {
            valueDescriptorMap: {
                get() {
                    return t.reduce( (s, r) => {
                        let a = Jf(r, this.identifier)
                          , l = this.data.getAttributeNameForKey(a.key);
                        return Object.assign(s, {
                            [l]: a
                        })
                    }
                    , {})
                }
            }
        };
        return t.reduce( (s, r) => Object.assign(s, iy(r)), e)
    }
    o(ey, "ValuePropertiesBlessing");
    function iy(n, t) {
        let e = Jf(n, t)
          , {key: s, name: r, reader: a, writer: l} = e;
        return {
            [r]: {
                get() {
                    let u = this.data.get(s);
                    return u !== null ? a(u) : e.defaultValue
                },
                set(u) {
                    u === void 0 ? this.data.delete(s) : this.data.set(s, l(u))
                }
            },
            [`has${lo(r)}`]: {
                get() {
                    return this.data.has(s) || e.hasCustomDefaultValue
                }
            }
        }
    }
    o(iy, "propertiesForValueDefinitionPair");
    function Jf([n,t], e) {
        return oy({
            controller: e,
            token: n,
            typeDefinition: t
        })
    }
    o(Jf, "parseValueDefinitionPair");
    function Ma(n) {
        switch (n) {
        case Array:
            return "array";
        case Boolean:
            return "boolean";
        case Number:
            return "number";
        case Object:
            return "object";
        case String:
            return "string"
        }
    }
    o(Ma, "parseValueTypeConstant");
    function ao(n) {
        switch (typeof n) {
        case "boolean":
            return "boolean";
        case "number":
            return "number";
        case "string":
            return "string"
        }
        if (Array.isArray(n))
            return "array";
        if (Object.prototype.toString.call(n) === "[object Object]")
            return "object"
    }
    o(ao, "parseValueTypeDefault");
    function ny(n) {
        let {controller: t, token: e, typeObject: s} = n
          , r = Hf(s.type)
          , a = Hf(s.default)
          , l = r && a
          , u = r && !a
          , d = !r && a
          , p = Ma(s.type)
          , b = ao(n.typeObject.default);
        if (u)
            return p;
        if (d)
            return b;
        if (p !== b) {
            let E = t ? `${t}.${e}` : e;
            throw new Error(`The specified default value for the Stimulus Value "${E}" must match the defined type "${p}". The provided default value of "${s.default}" is of type "${b}".`)
        }
        if (l)
            return p
    }
    o(ny, "parseValueTypeObject");
    function sy(n) {
        let {controller: t, token: e, typeDefinition: s} = n
          , a = ny({
            controller: t,
            token: e,
            typeObject: s
        })
          , l = ao(s)
          , u = Ma(s)
          , d = a || l || u;
        if (d)
            return d;
        let p = t ? `${t}.${s}` : e;
        throw new Error(`Unknown value type "${p}" for "${e}" value`)
    }
    o(sy, "parseValueTypeDefinition");
    function ry(n) {
        let t = Ma(n);
        if (t)
            return Uf[t];
        let e = Nc(n, "default")
          , s = Nc(n, "type")
          , r = n;
        if (e)
            return r.default;
        if (s) {
            let {type: a} = r
              , l = Ma(a);
            if (l)
                return Uf[l]
        }
        return n
    }
    o(ry, "defaultValueForDefinition");
    function oy(n) {
        let {token: t, typeDefinition: e} = n
          , s = `${Xf(t)}-value`
          , r = sy(n);
        return {
            type: r,
            key: s,
            name: iu(s),
            get defaultValue() {
                return ry(e)
            },
            get hasCustomDefaultValue() {
                return ao(e) !== void 0
            },
            reader: ay[r],
            writer: Kf[r] || Kf.default
        }
    }
    o(oy, "valueDescriptorForTokenAndTypeDefinition");
    var Uf = {
        get array() {
            return []
        },
        boolean: !1,
        number: 0,
        get object() {
            return {}
        },
        string: ""
    }
      , ay = {
        array(n) {
            let t = JSON.parse(n);
            if (!Array.isArray(t))
                throw new TypeError(`expected value of type "array" but instead got value "${n}" of type "${ao(t)}"`);
            return t
        },
        boolean(n) {
            return !(n == "0" || String(n).toLowerCase() == "false")
        },
        number(n) {
            return Number(n.replace(/_/g, ""))
        },
        object(n) {
            let t = JSON.parse(n);
            if (t === null || typeof t != "object" || Array.isArray(t))
                throw new TypeError(`expected value of type "object" but instead got value "${n}" of type "${ao(t)}"`);
            return t
        },
        string(n) {
            return n
        }
    }
      , Kf = {
        default: ly,
        array: Yf,
        object: Yf
    };
    function Yf(n) {
        return JSON.stringify(n)
    }
    o(Yf, "writeJSON");
    function ly(n) {
        return `${n}`
    }
    o(ly, "writeString");
    var qe = class {
        static{o(this, "Controller")
        }constructor(t) {
            this.context = t
        }
        static get shouldLoad() {
            return !0
        }
        static afterLoad(t, e) {}
        get application() {
            return this.context.application
        }
        get scope() {
            return this.context.scope
        }
        get element() {
            return this.scope.element
        }
        get identifier() {
            return this.scope.identifier
        }
        get targets() {
            return this.scope.targets
        }
        get outlets() {
            return this.scope.outlets
        }
        get classes() {
            return this.scope.classes
        }
        get data() {
            return this.scope.data
        }
        initialize() {}
        connect() {}
        disconnect() {}
        dispatch(t, {target: e=this.element, detail: s={}, prefix: r=this.identifier, bubbles: a=!0, cancelable: l=!0}={}) {
            let u = r ? `${r}:${t}` : t
              , d = new CustomEvent(u,{
                detail: s,
                bubbles: a,
                cancelable: l
            });
            return e.dispatchEvent(d),
            d
        }
    }
    ;
    qe.blessings = [Xb, Zb, ey, Qb];
    qe.targets = [];
    qe.outlets = [];
    qe.values = {};
    var nu = "[role='option']:not([aria-disabled])"
      , cy = "[aria-selected='true']"
      , hs = class n extends qe {
        static{o(this, "Autocomplete")
        }static targets = ["input", "hidden", "results"];
        static classes = ["selected"];
        static values = {
            ready: Boolean,
            submitOnEnter: Boolean,
            url: String,
            minLength: Number,
            delay: {
                type: Number,
                default: 300
            },
            queryParam: {
                type: String,
                default: "q"
            }
        };
        static uniqOptionId = 0;
        connect() {
            this.close(),
            this.inputTarget.hasAttribute("autocomplete") || this.inputTarget.setAttribute("autocomplete", "off"),
            this.inputTarget.setAttribute("spellcheck", "false"),
            this.mouseDown = !1,
            this.onInputChange = uy(this.onInputChange, this.delayValue),
            this.inputTarget.addEventListener("keydown", this.onKeydown),
            this.inputTarget.addEventListener("blur", this.onInputBlur),
            this.inputTarget.addEventListener("input", this.onInputChange),
            this.resultsTarget.addEventListener("mousedown", this.onResultsMouseDown),
            this.resultsTarget.addEventListener("click", this.onResultsClick),
            this.inputTarget.hasAttribute("autofocus") && this.inputTarget.focus(),
            this.readyValue = !0
        }
        disconnect() {
            this.hasInputTarget && (this.inputTarget.removeEventListener("keydown", this.onKeydown),
            this.inputTarget.removeEventListener("blur", this.onInputBlur),
            this.inputTarget.removeEventListener("input", this.onInputChange)),
            this.hasResultsTarget && (this.resultsTarget.removeEventListener("mousedown", this.onResultsMouseDown),
            this.resultsTarget.removeEventListener("click", this.onResultsClick))
        }
        sibling(t) {
            let e = this.options
              , s = this.selectedOption
              , r = e.indexOf(s)
              , a = t ? e[r + 1] : e[r - 1]
              , l = t ? e[0] : e[e.length - 1];
            return a || l
        }
        select(t) {
            let e = this.selectedOption;
            e && (e.removeAttribute("aria-selected"),
            e.classList.remove(...this.selectedClassesOrDefault)),
            t.setAttribute("aria-selected", "true"),
            t.classList.add(...this.selectedClassesOrDefault),
            this.inputTarget.setAttribute("aria-activedescendant", t.id),
            t.scrollIntoView({
                behavior: "auto",
                block: "nearest"
            })
        }
        onKeydown = o(t => {
            let e = this[`on${t.key}Keydown`];
            e && e(t)
        }
        , "onKeydown");
        onEscapeKeydown = o(t => {
            this.resultsShown && (this.hideAndRemoveOptions(),
            t.stopPropagation(),
            t.preventDefault())
        }
        , "onEscapeKeydown");
        onArrowDownKeydown = o(t => {
            let e = this.sibling(!0);
            e && this.select(e),
            t.preventDefault()
        }
        , "onArrowDownKeydown");
        onArrowUpKeydown = o(t => {
            let e = this.sibling(!1);
            e && this.select(e),
            t.preventDefault()
        }
        , "onArrowUpKeydown");
        onTabKeydown = o(t => {
            let e = this.selectedOption;
            e && this.commit(e)
        }
        , "onTabKeydown");
        onEnterKeydown = o(t => {
            let e = this.selectedOption;
            e && this.resultsShown && (this.commit(e),
            this.hasSubmitOnEnterValue || t.preventDefault())
        }
        , "onEnterKeydown");
        onInputBlur = o( () => {
            this.mouseDown || this.close()
        }
        , "onInputBlur");
        commit(t) {
            if (t.getAttribute("aria-disabled") === "true")
                return;
            if (t instanceof HTMLAnchorElement) {
                t.click(),
                this.close();
                return
            }
            let e = t.getAttribute("data-autocomplete-label") || t.textContent.trim()
              , s = t.getAttribute("data-autocomplete-value") || e;
            this.inputTarget.value = e,
            this.hasHiddenTarget ? (this.hiddenTarget.value = s,
            this.hiddenTarget.dispatchEvent(new Event("input")),
            this.hiddenTarget.dispatchEvent(new Event("change"))) : this.inputTarget.value = s,
            this.inputTarget.focus(),
            this.hideAndRemoveOptions(),
            this.element.dispatchEvent(new CustomEvent("autocomplete.change",{
                bubbles: !0,
                detail: {
                    value: s,
                    textValue: e,
                    selected: t
                }
            }))
        }
        clear() {
            this.inputTarget.value = "",
            this.hasHiddenTarget && (this.hiddenTarget.value = "")
        }
        onResultsClick = o(t => {
            if (!(t.target instanceof Element))
                return;
            let e = t.target.closest(nu);
            e && this.commit(e)
        }
        , "onResultsClick");
        onResultsMouseDown = o( () => {
            this.mouseDown = !0,
            this.resultsTarget.addEventListener("mouseup", () => {
                this.mouseDown = !1
            }
            , {
                once: !0
            })
        }
        , "onResultsMouseDown");
        onInputChange = o( () => {
            this.hasHiddenTarget && (this.hiddenTarget.value = "");
            let t = this.inputTarget.value.trim();
            t && t.length >= this.minLengthValue ? this.fetchResults(t) : this.hideAndRemoveOptions()
        }
        , "onInputChange");
        identifyOptions() {
            let t = this.resultsTarget.id || "stimulus-autocomplete";
            this.resultsTarget.querySelectorAll(`${nu}:not([id])`).forEach(s => s.id = `${t}-option-${n.uniqOptionId++}`)
        }
        hideAndRemoveOptions() {
            this.close(),
            this.resultsTarget.innerHTML = null
        }
        fetchResults = o(async t => {
            if (!this.hasUrlValue)
                return;
            let e = this.buildURL(t);
            try {
                this.element.dispatchEvent(new CustomEvent("loadstart"));
                let s = await this.doFetch(e);
                this.replaceResults(s),
                this.element.dispatchEvent(new CustomEvent("load")),
                this.element.dispatchEvent(new CustomEvent("loadend"))
            } catch (s) {
                throw this.element.dispatchEvent(new CustomEvent("error")),
                this.element.dispatchEvent(new CustomEvent("loadend")),
                s
            }
        }
        , "fetchResults");
        buildURL(t) {
            let e = new URL(this.urlValue,window.location.href)
              , s = new URLSearchParams(e.search.slice(1));
            return s.append(this.queryParamValue, t),
            e.search = s.toString(),
            e.toString()
        }
        doFetch = o(async t => {
            let e = await fetch(t, this.optionsForFetch());
            if (!e.ok)
                throw new Error(`Server responded with status ${e.status}`);
            return await e.text()
        }
        , "doFetch");
        replaceResults(t) {
            this.resultsTarget.innerHTML = t,
            this.identifyOptions(),
            this.options ? this.open() : this.close()
        }
        open() {
            this.resultsShown || (this.resultsShown = !0,
            this.element.setAttribute("aria-expanded", "true"),
            this.element.dispatchEvent(new CustomEvent("toggle",{
                detail: {
                    action: "open",
                    inputTarget: this.inputTarget,
                    resultsTarget: this.resultsTarget
                }
            })))
        }
        close() {
            this.resultsShown && (this.resultsShown = !1,
            this.inputTarget.removeAttribute("aria-activedescendant"),
            this.element.setAttribute("aria-expanded", "false"),
            this.element.dispatchEvent(new CustomEvent("toggle",{
                detail: {
                    action: "close",
                    inputTarget: this.inputTarget,
                    resultsTarget: this.resultsTarget
                }
            })))
        }
        get resultsShown() {
            return !this.resultsTarget.hidden
        }
        set resultsShown(t) {
            this.resultsTarget.hidden = !t
        }
        get options() {
            return Array.from(this.resultsTarget.querySelectorAll(nu))
        }
        get selectedOption() {
            return this.resultsTarget.querySelector(cy)
        }
        get selectedClassesOrDefault() {
            return this.hasSelectedClass ? this.selectedClasses : ["active"]
        }
        optionsForFetch() {
            return {
                headers: {
                    "X-Requested-With": "XMLHttpRequest"
                }
            }
        }
    }
      , uy = o( (n, t=10) => {
        let e = null;
        return (...s) => {
            clearTimeout(e),
            e = setTimeout(n, t)
        }
    }
    , "debounce");
    var ou = {};
    Rt(ou, {
        default: () => ru
    });
    var su = {};
    Rt(su, {
        default: () => vt
    });
    var vt = class extends qe {
        static{o(this, "default")
        }connect() {
            this.element[this.identifier] = this
        }
        identifierCamelCase() {
            return this.identifier.replace(/(-)+./g, n => n.substr(0, n.length - 2) + n[n.length - 1].toUpperCase())
        }
    }
    ;
    var ru = class extends vt {
        static{o(this, "default")
        }static targets = ["vintageReservations", "vintageFilterButton"];
        static values = {
            filteredVintageId: {
                type: Number,
                default: NaN
            }
        };
        filter({params: n}) {
            this.filteredVintageIdValue = n.vintageId
        }
        resetFilter() {
            this.filteredVintageIdValue = NaN
        }
        filteredVintageIdValueChanged(n) {
            let t = `data-${this.identifier}-vintage-id-param`;
            this.vintageFilterButtonTargets.forEach(e => {
                let s = parseInt(e.attributes[t].value);
                e.classList.toggle("active", n === s)
            }
            ),
            this.vintageReservationsTargets.forEach(e => {
                let s = parseInt(e.dataset.vintageId);
                e.classList.toggle("d-none", n && n !== s)
            }
            )
        }
    }
    ;
    var au = {};
    Rt(au, {
        default: () => ds
    });
    var ds = class extends vt {
        static{o(this, "default")
        }static targets = ["input"];
        setValue({params: {value: n}}) {
            this.inputTarget.value = n
        }
    }
    ;
    var cu = {};
    Rt(cu, {
        default: () => lu
    });
    var lu = class extends vt {
        static{o(this, "default")
        }static targets = ["label"];
        connect() {
            super.connect()
        }
        removeLabel(n) {
            n.target.closest("[data-label]").remove(),
            this.element.submit()
        }
        labelSelected(n) {
            this.element.submit()
        }
    }
    ;
    var hu = {};
    Rt(hu, {
        default: () => uu
    });
    var uu = class extends vt {
        static{o(this, "default")
        }static targets = ["syncController", "syncInput", "reservationCollapse", "addButton", "erCredits", "erCreditsSum", "clientInformation"];
        connect() {
            this.updateAddButton()
        }
        syncGroupControllers({detail: {groupId: n}, params: {multipleForm: t, attribute: e}}) {
            t === "main_form" && this.syncControllerTargets.forEach(s => {
                let r = s.dataset;
                r.multipleReservationsEditorMultipleFormParam === "sub_form" && r.multipleReservationsEditorAttributeParam === e && (r.separateGroupSelectionSelectedGroupValue = n)
            }
            )
        }
        syncInputs({target: n, params: {multipleForm: t, attribute: e}}) {
            t === "main_form" && this.syncInputTargets.forEach(s => {
                let r = s.dataset;
                r.multipleReservationsEditorMultipleFormParam === "sub_form" && r.multipleReservationsEditorAttributeParam === e && (s.type == "radio" ? s.checked = s.value === n.value : s.value = n.value)
            }
            )
        }
        addForm() {
            let n = this.getFirstClosedReservationCollapse();
            n && (n.querySelector("span").innerHTML = "",
            new window.bootstrap.Collapse(n,{
                show: !0
            }),
            n.dataset.free = "0",
            this.setDestroyInput(n, !1),
            this.setActiveInput(n, !0),
            this.toggleSubFormButtonIcon(n.querySelector("i.fa")),
            new window.bootstrap.Collapse(n.querySelector(".reservation-sub-collapse"),{
                toggle: !0
            })),
            this.updateAddButton(),
            this.updateErCreditsSum()
        }
        updateAddButton() {
            this.addButtonTarget.disabled = !this.getFirstClosedReservationCollapse()
        }
        getFirstClosedReservationCollapse() {
            return this.reservationCollapseTargets.find(n => n.dataset.free == "1")
        }
        toggleForm(n) {
            let t = n.target.closest(".reservation-main-collapse");
            new window.bootstrap.Collapse(t.querySelector(".reservation-sub-collapse"),{
                toggle: !0
            });
            let e = t.querySelector('[data-prop="destroy"]');
            e.value === "false" ? (e.value = !0,
            t.querySelector("span").innerHTML = "will not be created") : (t.querySelector("span").innerHTML = "",
            e.value = !1),
            this.toggleSubFormButtonIcon(t.querySelector("i.fa")),
            this.updateErCreditsSum()
        }
        setDestroyInput(n, t) {
            let e = n.querySelector('[data-prop="destroy"]');
            e.value = t
        }
        setActiveInput(n, t) {
            let e = n.querySelector('[data-prop="active"]');
            e.value = t
        }
        toggleSubFormButtonIcon(n) {
            n.classList.toggle("fa-times"),
            n.classList.toggle("fa-pencil")
        }
        updateErCreditsSum() {
            this.erCreditsSumTarget.innerHTML = this.calculateErCreditsSum()
        }
        calculateErCreditsSum() {
            return this.erCreditsTargets.reduce( (n, t) => {
                let e = t.closest(".reservation-sub-collapse");
                if (!e || e.querySelector('[data-prop="active"]').value === "false" || e.querySelector('[data-prop="destroy"]').value === "true")
                    return n;
                let s = parseFloat(t.value);
                return !s || Number.isNaN(s) ? n : n + s
            }
            , 0)
        }
        updateClientInformations(n) {
            let t = n.target.closest(".reservation-main-collapse");
            t && t.dataset.index === "0" && this.clientInformationTargets.forEach( (e, s) => {
                s > 1 && (e.value = `${n.target.value} (${s})`)
            }
            )
        }
    }
    ;
    var fu = {};
    Rt(fu, {
        default: () => du
    });
    var du = class extends qe {
        static{o(this, "default")
        }static targets = ["projectId", "vintageId"];
        updateTargetFields({params: {vintageId: n, carbonProjectId: t}}) {
            this.projectIdTarget.value = t,
            this.projectIdTarget.dispatchEvent(new Event("change",{
                bubbles: !0
            })),
            requestAnimationFrame( () => {
                this.vintageIdTarget.value = n
            }
            )
        }
    }
    ;
    var gu = {};
    Rt(gu, {
        default: () => pu
    });
    var pu = class extends ds {
        static{o(this, "default")
        }static targets = ["list"];
        static values = {
            dataUrl: String,
            loaded: Boolean
        };
        loadAllCountries(n) {
            this.loadedValue || (fetch(this.dataUrlValue, {
                headers: {
                    "Content-Type": "application/json"
                }
            }).then(t => {
                t.json().then(e => {
                    this.renderListTargetContent(e)
                }
                )
            }
            ),
            this.loadedValue = !0)
        }
        renderListTargetContent(n) {
            this.listTarget.innerHTML = "",
            Object.keys(n).forEach(t => {
                this.listTarget.appendChild(document.createTextNode("\xA0")),
                this.listTarget.appendChild(this.createCountryElement(t, n[t]))
            }
            )
        }
        createCountryElement(n, t) {
            let e = document.createElement("span");
            e.classList.add("text-nowrap");
            let s = document.createElement("a");
            return s.classList.add("text-decoration-underline", "link-secondary", "link-offset-2", "link-underline-opacity-25", "link-underline-opacity-100-hover"),
            s.dataset["orders-CountryInputValueParam"] = n,
            s.dataset.action = "orders--country-input#setValue",
            s.innerHTML = `${n}:`,
            e.appendChild(s),
            e.appendChild(document.createTextNode(` ${t}\xA0 - \xA0`)),
            e
        }
    }
    ;
    var vu = {};
    Rt(vu, {
        default: () => mu
    });
    var mu = class extends ds {
        static{o(this, "default")
        }static targets = ["list"];
        static values = {
            dataUrl: String,
            loaded: Boolean
        };
        loadAllPartnerStrings(n) {
            this.loadedValue || (fetch(this.dataUrlValue, {
                headers: {
                    "Content-Type": "application/json"
                }
            }).then(t => {
                t.json().then(e => {
                    this.renderListTargetContent(e)
                }
                )
            }
            ),
            this.loadedValue = !0)
        }
        renderListTargetContent(n) {
            this.listTarget.innerHTML = "",
            n.forEach(t => {
                this.listTarget.appendChild(document.createTextNode("\xA0")),
                this.listTarget.appendChild(this.createPartnerStringElement(t)),
                this.listTarget.appendChild(document.createTextNode("\xA0"))
            }
            )
        }
        createPartnerStringElement(n) {
            let t = document.createElement("a");
            return t.classList.add("text-nowrap", "text-decoration-underline", "link-secondary", "link-offset-2", "link-underline-opacity-25", "link-underline-opacity-100-hover"),
            t.dataset["orders-PartnerStringInputValueParam"] = n,
            t.dataset.action = "orders--partner-string-input#setValue",
            t.innerHTML = n,
            t
        }
    }
    ;
    var yu = {};
    Rt(yu, {
        default: () => bu
    });
    var bu = class extends vt {
        static{o(this, "default")
        }static targets = ["vintageTBody", "reservation", "preReservation", "erSum", "erImported", "erDifference", "saveBtn"];
        connect() {
            super.connect(),
            this.update()
        }
        update() {
            this.updatePreReservation(),
            this.updateVintageTable(),
            this.updateSumAndDifference()
        }
        updatePreReservation() {
            let n = this.getPreReservationData();
            if (n == null)
                return;
            let t = this.preReservationTarget.querySelector('[data-prop="destroy"]');
            n.reduceEr > n.totalEr || t.checked ? (this.preReservationTarget.querySelector('[data-prop="er-reduce"]').value = n.totalEr,
            n.reduceEr = n.totalEr) : n.reduceEr < 0 && (this.preReservationTarget.querySelector('[data-prop="er-reduce"]').value = 0,
            n.reduceEr = 0),
            this.preReservationTarget.querySelector('[data-prop="er-credits"]').value = n.totalEr - n.reduceEr
        }
        updateReservationEr(n) {
            parseFloat(n.target.value || "0") < 0 && (n.target.value = 0),
            this.update()
        }
        changeDestroyReservation(n) {
            let t = n.target.checked
              , e = n.target.closest('[data-prima-reservations-target="reservation"]');
            e.dataset.reservationId ? e.querySelectorAll("[data-prop]").forEach(s => {
                s.dataset.prop != "destroy" && (t ? s.setAttribute("disabled", "disabled") : s.removeAttribute("disabled"))
            }
            ) : e.remove(),
            this.update()
        }
        copyReservation(n) {
            let t = n.target.closest('[data-prima-reservations-target="reservation"]')
              , e = t.cloneNode(!0);
            delete e.dataset.reservationId;
            let s = this.reservationTargets.length;
            e.querySelectorAll("input, select").forEach(r => {
                r.id = r.id.replace(/_\d+_/, "_" + s + "_"),
                r.name = r.name.replace(/\[\d+\]/, "[" + s + "]"),
                r.disabled = !1
            }
            ),
            e.querySelectorAll("label").forEach(r => {
                r.setAttribute("for", r.getAttribute("for").replace(/_\d+_/, "_" + s + "_"))
            }
            ),
            t.insertAdjacentElement("afterend", e),
            this.update()
        }
        updateVintageTable() {
            let n = this.getReservationVintageUsage()
              , t = this.getPreReservationData();
            this.vintageTBodyTarget.querySelectorAll('[data-prop="available_er"] [data-vintage-id]').forEach(e => {
                let s = parseInt(e.dataset.vintageId)
                  , r = parseFloat(e.dataset.availableEr)
                  , a = this.vintageTBodyTarget.querySelector(`[data-prop="pre_reserved"] [data-vintage-id="${s}"]`)
                  , l = this.vintageTBodyTarget.querySelector(`[data-prop="new_reserved"] [data-vintage-id="${s}"]`)
                  , u = this.vintageTBodyTarget.querySelector(`[data-prop="result"] [data-vintage-id="${s}"]`)
                  , d = t && t.vintage == s && t.reduceEr;
                this.setValueOnElement(a, d),
                this.setValueOnElement(l, n[s], !0);
                let p = r - (n[s] || 0) + (d || 0);
                this.setValueOnElement(u, p)
            }
            )
        }
        updateSumAndDifference() {
            let n = this.getReservationVintageUsage()
              , t = this.erImportedTarget.value
              , e = Object.values(n).reduce( (a, l) => a + l, 0)
              , s = t - e;
            this.erSumTarget.value = Math.round(e * 1e3) / 1e3,
            this.erDifferenceTarget.value = Math.round(s * 1e3) / 1e3;
            let r = this.erDifferenceTarget.closest("td");
            Math.abs(s) < .001 ? (r.classList.remove("bg-danger"),
            r.classList.add("bg-success"),
            this.saveBtnTarget.removeAttribute("disabled")) : (r.classList.add("bg-danger"),
            r.classList.remove("bg-success"),
            this.saveBtnTarget.setAttribute("disabled", !0))
        }
        getPreReservationData() {
            if (!this.hasPreReservationTarget)
                return null;
            let n = this.preReservationTarget.querySelector('[data-prop="vintage-id"]')
              , t = this.preReservationTarget.querySelector('[data-prop="er-total"]')
              , e = this.preReservationTarget.querySelector('[data-prop="er-reduce"]');
            return {
                vintage: n.value,
                totalEr: parseFloat(t.value),
                reduceEr: parseFloat(e.value)
            }
        }
        getReservationVintageUsage() {
            let n = {};
            return this.reservationTargets.forEach(t => {
                if (t.querySelector('[data-prop="destroy"]').checked)
                    return;
                let e = t.querySelector('[data-prop="vintage"]').value
                  , s = parseFloat(t.querySelector('[data-prop="er"]').value || 0);
                n[e] = (n[e] || 0) + s
            }
            ),
            n
        }
        setValueOnElement(n, t, e=!1) {
            typeof t != "number" ? n.innerHTML = "-" : n.innerHTML = Math.round((e ? -t : t) * 1e3) / 1e3,
            this.setColorClassForValue(n, t, e)
        }
        setColorClassForValue(n, t, e) {
            n.classList.remove("text-danger"),
            n.classList.remove("text-success"),
            !(typeof t != "number" || t == 0) && (t < 0 != e ? n.classList.add("text-danger") : n.classList.add("text-success"))
        }
    }
    ;
    var Eu = {};
    Rt(Eu, {
        default: () => _u
    });
    var _u = class extends vt {
        static{o(this, "default")
        }static targets = ["flexible", "retirementConfirmationRequested", "statuses", "importedFromPrima", "salePeriodState"];
        setPresentAll() {
            this.setTargetSelection(this.flexibleTarget, ["flexible", "inflexible"]),
            this.setTargetSelection(this.retirementConfirmationRequestedTarget, ["confirmation", "no_confirmation"]),
            this.setTargetSelection(this.statusesTarget, ["offered", "provisional", "regular", "transferred", "retired"]),
            this.setTargetSelection(this.importedFromPrimaTarget, ["yes", "no"]),
            this.setTargetSelection(this.salePeriodStateTarget, ["open", "closed"])
        }
        setPresentPreReservations() {
            this.setTargetSelection(this.flexibleTarget, ["flexible", "inflexible"]),
            this.setTargetSelection(this.retirementConfirmationRequestedTarget, ["confirmation", "no_confirmation"]),
            this.setTargetSelection(this.statusesTarget, ["offered", "provisional", "regular"]),
            this.setTargetSelection(this.importedFromPrimaTarget, ["no"]),
            this.setTargetSelection(this.salePeriodStateTarget, ["open"])
        }
        setTargetSelection(n, t) {
            n.querySelectorAll("input").forEach(e => {
                if (e.type === "checkbox") {
                    let s = e.closest("label") || document.querySelector(`label[for="${e.id}"]`);
                    t.includes(e.value) ? e.checked = !0 : e.checked = !1
                }
            }
            )
        }
    }
    ;
    var Tu = {};
    Rt(Tu, {
        default: () => Su
    });
    var hy = ["text-danger", "text-bg-danger", "text-warning", "text-bg-warning", "text-success", "text-bg-success", "text-primary", "text-bg-primary", "text-secondary", "text-bg-secondary", "text-info", "text-bg-info", "text-light", "text-bg-light", "text-dark", "text-bg-dark", "text-muted"];
    function Zf(n) {
        return isNaN(n) ? "n/a" : n
    }
    o(Zf, "formatAmount");
    function Oa(n) {
        return isNaN(n) ? "n/a" : n > 0 ? `+${n}` : n == 0 ? `\xB1${n}` : n
    }
    o(Oa, "formatDifference");
    function tp(n, t, e=!1) {
        isNaN(t) ? fs(n, e ? "" : "text-muted") : t < 0 ? fs(n, e ? "text-bg-danger" : "text-danger") : fs(n, "")
    }
    o(tp, "setAmountColorClass");
    function La(n, t, e=!1) {
        isNaN(t) ? fs(n, e ? "" : "text-muted") : t > 0 ? fs(n, e ? "text-bg-success" : "text-success") : t == 0 ? fs(n, "") : fs(n, e ? "text-bg-danger" : "text-danger")
    }
    o(La, "setDifferenceColorClass");
    function fs(n, t) {
        hy.forEach(e => {
            n.classList.toggle(e, e === t)
        }
        )
    }
    o(fs, "_setColorClass");
    var Su = class extends vt {
        static{o(this, "default")
        }static targets = ["sumInfo", "sumErNow", "sumErBefore", "sumErDivergence", "saveBtn"];
        static outlets = ["reservations--split-single"];
        static values = {
            vintageErs: Object
        };
        update() {
            let n = this.sumPersistedEr()
              , t = this.reservedErByVintageId()
              , e = this.sumReservedEr()
              , s = this.roundTons(e - n);
            this.updateOutlets({
                sumErDivergence: s,
                reservedErByVintageId: t,
                sumPersistedEr: n
            }),
            this.updateSumTable({
                sumPersistedEr: n,
                sumReservedEr: e,
                sumErDivergence: s
            }),
            this.updateSaveButton(s)
        }
        fixSum(n) {
            let t = this.roundTons(this.sumReservedEr() - this.sumPersistedEr());
            this.enclosingOutlet(n.target).addErValue(-t)
        }
        fillVintage(n) {
            let t = this.enclosingOutlet(n.target)
              , e = t.vintageId()
              , s = this.reservedErByVintageId()[e]
              , r = parseFloat(this.vintageErsValue[e])
              , a = this.roundTons(r - s);
            t.addErValue(a)
        }
        sumPersistedEr() {
            return this.roundTons(this.reservationsSplitSingleOutlets.reduce( (n, t) => n + t.persistedEr(), 0))
        }
        sumReservedEr() {
            let n = this.reservationsSplitSingleOutlets.reduce( (t, e) => t + e.reservedEr(), 0);
            return this.roundTons(n)
        }
        reservedErByVintageId() {
            return this.reservationsSplitSingleOutlets.reduce( (n, t) => {
                let e = t.vintageId();
                return n[e] = this.roundTons((n[e] || 0) + t.reservedEr()),
                n
            }
            , {})
        }
        updateOutlets({sumErDivergence: n, reservedErByVintageId: t, sumPersistedEr: e}) {
            return this.reservationsSplitSingleOutlets.forEach(s => {
                s.updateErSumDivergence(n);
                let r = s.vintageId()
                  , a = t[r] || 0
                  , l = parseFloat(this.vintageErsValue[r]);
                s.updateErInfo({
                    availableErOfVintage: l,
                    reservedErOfVintage: a,
                    sumPersistedEr: e
                })
            }
            )
        }
        updateSumTable({sumPersistedEr: n, sumReservedEr: t, sumErDivergence: e}) {
            this.sumErNowTarget.innerHTML = t,
            this.sumErBeforeTarget.innerHTML = n,
            this.setColoredDifference(this.sumErDivergenceTarget, e);
            let s = Math.abs(e) == 0
              , r = this.sumInfoTarget.classList;
            r.toggle("border-danger", !s),
            r.toggle("border-success", s),
            r.toggle("bg-danger-subtle", !s),
            r.toggle("bg-success-subtle", s)
        }
        updateSaveButton(n) {
            this.saveBtnTarget.classList.toggle("disabled", n != 0)
        }
        enclosingOutlet(n) {
            return n.closest("[data-outlet-for='reservations--split-multi']")["reservations--split-single"]
        }
        setColoredDifference(n, t, e=!1) {
            let s = this.roundTons(t);
            La(n, s, e),
            n.innerHTML = Oa(s)
        }
        roundTons(n) {
            return Math.round(n * 1e3) / 1e3
        }
    }
    ;
    var wu = {};
    Rt(wu, {
        default: () => xu
    });
    var xu = class extends vt {
        static{o(this, "default")
        }static targets = ["persistedErInput", "vintageInput", "erCreditsInput", "deleteInput", "deleteOverlay", "availableEr", "reservedEr", "remainingEr", "resetBtn", "resetAmount", "fillVintageBtn", "fillVintageBtnText", "fillVintageAmount", "fixSumBtn", "fixSumAmount"];
        connect() {
            super.connect(),
            this.update()
        }
        update() {
            let n = this.deleteInputTarget.checked;
            this.deleteOverlayTarget.classList.toggle("d-none", !n),
            this.hasResetBtnTarget && (this.resetBtnTarget.classList.toggle("disabled", this.changedEr() == 0),
            this.setColoredDifference(this.resetAmountTarget, -this.changedEr(), !0)),
            this.dispatch("updated")
        }
        reset() {
            this.setErValue(this.persistedEr())
        }
        setErValue(n) {
            n !== this.erCreditsInputTarget.value && (this.erCreditsInputTarget.value = n,
            this.erCreditsInputTarget.dispatchEvent(new Event("change")))
        }
        addErValue(n) {
            this.setErValue(this.roundTons(this.reservedEr() + n))
        }
        updateErInfo({availableErOfVintage: n, reservedErOfVintage: t, sumPersistedEr: e}) {
            let s = this.roundTons(n - t);
            this.setColoredAmount(this.availableErTarget, n),
            this.setColoredDifference(this.reservedErTarget, -t),
            this.setColoredAmount(this.remainingErTarget, s),
            this.hasFillVintageBtnTarget && (this.setColoredDifference(this.fillVintageAmountTarget, s, !0),
            this.fillVintageBtnTarget.classList.toggle("disabled", isNaN(s) || s == 0 || n > e),
            this.fillVintageBtnTextTarget.innerHTML = s >= 0 ? "Fill Vintage" : "Fix Overbook")
        }
        updateErSumDivergence(n) {
            this.hasFixSumBtnTarget && (this.setColoredDifference(this.fixSumAmountTarget, -n, !0),
            this.fixSumBtnTarget.classList.toggle("disabled", n == 0))
        }
        vintageId() {
            return parseInt(this.vintageInputTarget.value)
        }
        reservedEr() {
            return this.deleteInputTarget.checked ? 0 : parseFloat(this.erCreditsInputTarget.value || "0")
        }
        persistedEr() {
            return parseFloat(this.persistedErInputTarget.value)
        }
        changedEr() {
            return this.roundTons(this.reservedEr() - this.persistedEr())
        }
        setColoredAmount(n, t, e=!1) {
            let s = this.roundTons(t);
            tp(n, s, e),
            n.innerHTML = Zf(s)
        }
        setColoredDifference(n, t, e=!1) {
            let s = this.roundTons(t);
            La(n, s, e),
            n.innerHTML = Oa(s)
        }
        roundTons(n) {
            return Math.round(n * 1e3) / 1e3
        }
    }
    ;
    var Au = {};
    Rt(Au, {
        default: () => Cu
    });
    var Cu = class extends vt {
        static{o(this, "default")
        }static targets = ["masterCheckbox", "checkbox", "counter"];
        connect() {
            this.updateMasterState(),
            this.updateCounter(),
            this.checkboxTargets.forEach(n => {
                n.addEventListener("change", () => {
                    this.updateMasterState(),
                    this.updateCounter()
                }
                )
            }
            ),
            this.hasMasterCheckboxTarget && this.masterCheckboxTarget.addEventListener("change", () => {
                this.checkboxTargets.forEach(n => {
                    n.checked = this.masterCheckboxTarget.checked
                }
                ),
                this.updateCounter()
            }
            )
        }
        updateMasterState() {
            if (!this.hasMasterCheckboxTarget)
                return;
            let n = !1
              , t = !1;
            this.checkboxTargets.forEach(e => {
                e.checked && (n = !0),
                e.checked || (t = !0)
            }
            ),
            this.masterCheckboxTarget.checked = !t && n,
            this.masterCheckboxTarget.indeterminate = n && t
        }
        updateCounter() {
            if (!this.hasCounterTarget)
                return;
            let n = this.checkboxTargets.reduce( (t, e) => t + (e.checked ? 1 : 0), 0);
            this.counterTarget.innerHTML = n
        }
    }
    ;
    var Mu = {};
    Rt(Mu, {
        default: () => ku
    });
    var ku = class extends vt {
        static{o(this, "default")
        }static targets = ["group", "select"];
        static values = {
            selectedGroup: String,
            map: Object
        };
        connect() {
            super.connect(),
            this.verifyMap(),
            this.update()
        }
        update() {
            this.selectedGroupValue = this.groupTarget.value
        }
        selectedGroupValueChanged(n, t) {
            if (typeof t > "u")
                return;
            n !== this.groupTarget.value && (this.groupTarget.value = n);
            let e = this.mapValue[n] || []
              , s = e.find(a => a.id == this.selectTarget.value)
              , r = s ? s.id : "";
            this.selectTarget.type !== "hidden" && (this.removeSelectOptions(this.selectTarget),
            e.forEach(a => {
                this.selectTarget.options.add(new Option(a.name,a.id))
            }
            )),
            this.selectTarget.value = r,
            this.dispatch("group-selected", {
                detail: {
                    groupId: n
                }
            })
        }
        removeSelectOptions(n) {
            let t = n.querySelectorAll('option:not([value=""])');
            Array.from(t).forEach(e => e.remove())
        }
        verifyMap() {
            for (var n in this.mapValue) {
                if (typeof n != "string")
                    throw "passed map needs ids as keys";
                let t = this.mapValue[n];
                if (!Array.isArray(t))
                    throw "passed map needs arrays as values";
                t.forEach(e => {
                    if (typeof e != "object" || e === null || typeof e.id > "u" || typeof e.name > "u")
                        throw "passed map needs arrays of form {:id, :name} as values"
                }
                )
            }
        }
    }
    ;
    var Lu = {};
    Rt(Lu, {
        default: () => Ou
    });
    var Ou = class extends vt {
        static{o(this, "default")
        }static targets = ["filterInput", "entry", "entryValue"];
        connect() {
            super.connect(),
            this.filter()
        }
        filter() {
            let n = this.filterInputTarget.value.toLowerCase();
            this.entryTargets.forEach(t => {
                let e = t.querySelector('[data-simple-filter-target="entryValue"]')
                  , s = e && e.innerHTML.toLowerCase();
                n.length > 0 && s && s.indexOf(n) < 0 ? t.setAttribute("hidden", "hidden") : t.removeAttribute("hidden")
            }
            )
        }
        reset() {
            this.filterInputTarget.value = "",
            this.filter()
        }
    }
    ;
    var Pu = {};
    Rt(Pu, {
        default: () => Du
    });
    var Du = class extends vt {
        static{o(this, "default")
        }static targets = ["reportKeyInput"];
        generateReportKey(n) {
            if (this.reportKeyInputTarget.value == "" || confirm("This will replace the existing key!") == !0) {
                let t = new Array(10).join().replace(/(.|$)/g, function() {
                    return (Math.random() * 36 | 0).toString(36)
                });
                this.reportKeyInputTarget.value = t
            }
        }
    }
    ;
    var Iu = {};
    Rt(Iu, {
        default: () => Ru
    });
    var Ru = class extends vt {
        static{o(this, "default")
        }connect() {
            super.connect(),
            this.element.addEventListener("input", n => {
                this.updateHeight()
            }
            ),
            this.updateHeight()
        }
        updateHeight() {
            this.element.style.height = "auto",
            this.element.style.height = `${this.element.scrollHeight}px`
        }
    }
    ;
    var Fu = {};
    Rt(Fu, {
        default: () => dy
    });
    var Nu = class n extends hs {
        static{o(this, "AirportAutocomplete")
        }static airportData = null;
        static airportDataLoaded = !1;
        initialize() {
            if (super.initialize(),
            !this.hasUrlValue)
                throw "missing url to internal airports endpoint";
            n.airportDataLoaded || (n.airportDataLoaded = !0,
            fetch(this.urlValue, {
                headers: {
                    "Content-Type": "application/json"
                }
            }).then(t => {
                t.json().then(e => {
                    n.airportData = e
                }
                )
            }
            ))
        }
        connect() {
            super.connect(),
            this.element.addEventListener("autocomplete.change", () => {
                this.inputTarget.setSelectionRange(0, 0),
                this.inputTarget.scrollLeft = 0
            }
            )
        }
        replaceResults(t) {
            super.replaceResults(t),
            this.maybeSelectFirstOption()
        }
        maybeSelectFirstOption() {
            !this.selectedOption && this.options.length > 0 && this.select(this.options[0])
        }
        doFetch = o(async t => {
            if (!n.airportData)
                return [];
            let e = this.inputTarget.value.trim().replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            return this.airportsForSearchTerm(e).map(r => `<li role="option" data-autocomplete-value="${r}">
                ${this.highlightSearchterm(r, e)}
              </li>`).join(`
`)
        }
        , "doFetch");
        airportsForSearchTerm(t) {
            let e = new RegExp("^" + t,"i")
              , s = new RegExp(", " + t,"i")
              , r = new RegExp(t,"i")
              , a = []
              , l = []
              , u = [];
            return n.airportData.forEach(p => {
                e.test(p) ? a.push(p) : s.test(p) ? l.push(p) : r.test(p) && u.push(p)
            }
            ),
            a.concat(l).concat(u).slice(0, 24)
        }
        highlightSearchterm(t, e) {
            if (e.length > 1) {
                let s = new RegExp(`(${e})`,"ig");
                return t.replace(s, "<strong>$1</strong>")
            }
            return t
        }
    }
      , dy = Nu;
    var Bu = {};
    Rt(Bu, {
        default: () => Vu
    });
    var Vu = class extends vt {
        static{o(this, "default")
        }static targets = ["draftRadio", "copyCheckbox"];
        connect() {
            super.connect(),
            this.update()
        }
        update() {
            if (!this.hasCopyCheckboxTarget)
                return;
            let n = !this.draftRadioTargets.some(s => s.checked)
              , t = this.copyCheckboxTarget.querySelector("input[type=checkbox]")
              , e = this.copyCheckboxTarget.querySelector("label");
            t.disabled = n,
            n ? (t.checked = !1,
            e.classList.add("text-black-50")) : e.classList.remove("text-black-50")
        }
    }
    ;
    var ju = {};
    Rt(ju, {
        default: () => Hu
    });
    var Hu = class extends vt {
        static{o(this, "default")
        }static targets = ["fuelTypes", "carTypes", "consumption", "consumptionSuffix", "hideConsumptionButton"];
        static values = {
            selectedFuelType: String,
            selectedCarType: String,
            estimateConsumption: Boolean
        };
        connect() {
            super.connect();
            let n = this.carTypesTarget.querySelector(":scope input:checked");
            this.selectedCarTypeValue = n ? n.value : "",
            this.selectedFuelTypeValue = this.fuelTypesTarget.value,
            this.fuelTypeUnits = JSON.parse(this.data.get("fuel-type-units")),
            this.estimatedConsumptions = JSON.parse(this.data.get("estimated-consumptions")),
            this.estimateConsumptionValue = !!this.selectedCarType
        }
        showConsumptionEstimation() {
            this.estimateConsumptionValue = !0
        }
        hideConsumptionEstimation() {
            this.estimateConsumptionValue = !1,
            this.selectedCarTypeValue = ""
        }
        setFuelType(n) {
            this.selectedFuelTypeValue = n.target.value
        }
        setCarType(n) {
            this.selectedCarTypeValue = n.target.value
        }
        selectedFuelTypeValueChanged() {
            this.updateUI()
        }
        selectedCarTypeValueChanged() {
            this.updateUI()
        }
        estimateConsumptionValueChanged() {
            this.updateUI()
        }
        updateUI() {
            this.updateEstimatedConsumption(),
            this.updateConsumptionSuffix(),
            this.updateEstimationVisibility(),
            this.updateSelectedCarTypes()
        }
        updateEstimatedConsumption() {
            this.selectedFuelTypeValue && this.selectedCarTypeValue && (this.consumptionTarget.value = this.estimatedConsumptions[this.selectedFuelTypeValue][this.selectedCarTypeValue])
        }
        updateConsumptionSuffix() {
            this.selectedFuelTypeValue ? this.consumptionSuffixTarget.innerHTML = this.fuelTypeUnits[this.selectedFuelTypeValue] : this.consumptionSuffixTarget.innerHTML = ""
        }
        updateEstimationVisibility() {
            this.estimateConsumptionValue ? (this.hideConsumptionButtonTarget.setAttribute("hidden", !0),
            this.carTypesTarget.removeAttribute("hidden")) : (this.hideConsumptionButtonTarget.removeAttribute("hidden"),
            this.carTypesTarget.setAttribute("hidden", !0))
        }
        updateSelectedCarTypes() {
            this.carTypesTarget.querySelectorAll("input[type=radio]").forEach(n => {
                n.checked = this.selectedCarTypeValue == n.value
            }
            )
        }
    }
    ;
    var $u = {};
    Rt($u, {
        default: () => Wu
    });
    var Wu = class extends vt {
        static{o(this, "default")
        }static targets = ["fuelTypes", "electricLocation"];
        static values = {
            selectedFuelType: String
        };
        connect() {
            super.connect(),
            this.selectedFuelTypeValue = this.fuelTypesTarget.value
        }
        setFuelType(n) {
            this.selectedFuelTypeValue = n.target.value
        }
        selectedFuelTypeValueChanged() {
            this.selectedFuelTypeValue === "electric" || this.selectedFuelTypeValue === "plug_in_hybrid" ? this.electricLocationTarget.removeAttribute("hidden") : this.electricLocationTarget.setAttribute("hidden", !0)
        }
    }
    ;
    var zu = {};
    Rt(zu, {
        default: () => qu
    });
    var qu = class extends vt {
        static{o(this, "default")
        }static targets = ["tab", "item"];
        static values = {
            tabsInvalidClass: {
                type: String,
                default: "tab-has-errors"
            },
            scrollToTop: Boolean,
            scrollOffset: {
                type: Number,
                default: 130
            }
        };
        connect() {
            super.connect(),
            this.updateNavTabActiveClass(),
            this.element.addEventListener("slid.bs.carousel", () => {
                this.updateNavTabActiveClass()
            }
            ),
            this.updateNavTabsInvalidClasses()
        }
        updateNavTabActiveClass() {
            let n = this.itemTargets.findIndex(t => t.classList.contains("active"));
            this.tabTargets.forEach(t => {
                t.classList.toggle("active", t.dataset.bsSlideTo == n)
            }
            ),
            this.scrollToTopValue && this.scrollToTop()
        }
        scrollToTop() {
            let n = this.element.getBoundingClientRect().top + window.pageYOffset;
            window.scrollTo({
                top: n - this.scrollOffsetValue,
                behavior: "smooth"
            })
        }
        updateNavTabsInvalidClasses() {
            this.tabsInvalidClassValue && this.itemTargets.forEach( (n, t) => {
                this.tabTargets.find(s => s.dataset.bsSlideTo == t).classList.toggle(this.tabsInvalidClassValue, this.hasInvalidInputs(n))
            }
            )
        }
        hasInvalidInputs(n) {
            return n.querySelector(".form-control.is-invalid,         .form-select.is-invalid,         .form-check-input.is-invalid,         .form-range.is-invalid") != null
        }
    }
    ;
    var Ku = {};
    Rt(Ku, {
        default: () => Uu
    });
    var Uu = class extends vt {
        static{o(this, "default")
        }static targets = ["input"];
        clearInputWhenChecked(n) {
            n.target.checked ? this.clearInput() : this.restoreInput()
        }
        clearInputWhenNotChecked(n) {
            n.target.checked ? this.restoreInput() : this.clearInput()
        }
        clearInput() {
            this.inputTargets.forEach(n => {
                n.dataset.valueToRestore = n.value,
                n.value = ""
            }
            )
        }
        restoreInput() {
            this.inputTargets.forEach(n => {
                let t = n.dataset.valueToRestore;
                t && (delete n.dataset.valueToRestore,
                n.value = t)
            }
            )
        }
    }
    ;
    var Xu = {};
    Rt(Xu, {
        default: () => Yu
    });
    var Yu = class extends vt {
        static{o(this, "default")
        }static targets = ["button", "source"];
        static values = {
            successContent: String,
            failureContent: String,
            successDuration: {
                type: Number,
                default: 2e3
            }
        };
        connect() {
            this.hasButtonTarget && (this.originalContent = this.buttonTarget.innerHTML)
        }
        copy(n) {
            n.preventDefault();
            let t = this.sourceTarget.value || this.sourceTarget.innerHTML;
            navigator.clipboard ? navigator.clipboard.writeText(t).then( () => this.copied(!0)) : this.copied(this.copyFallback(t))
        }
        copied(n) {
            if (!this.hasButtonTarget)
                return;
            this.timeout && clearTimeout(this.timeout);
            let t = this.successContentValue || "\u2713";
            n || (t = this.failureContentValue || "X"),
            this.buttonTarget.innerText = t,
            this.timeout = setTimeout( () => {
                this.buttonTarget.innerHTML = this.originalContent
            }
            , 4e3)
        }
        copyFallback(n) {
            var t = document.createElement("textarea");
            t.style.position = "fixed",
            t.style.top = 0,
            t.style.left = 0,
            t.style.width = "2em",
            t.style.height = "2em",
            t.style.padding = 0,
            t.style.border = "none",
            t.style.outline = "none",
            t.style.boxShadow = "none",
            t.style.background = "transparent",
            t.style.color = "transparent",
            t.value = n,
            this.element.appendChild(t),
            t.focus(),
            t.select();
            try {
                return document.execCommand("copy") || console.log("Oops, unable to copy"),
                !0
            } catch {
                return console.log("Oops, unable to copy"),
                !1
            } finally {
                this.element.removeChild(t)
            }
        }
    }
    ;
    var Qu = {};
    Rt(Qu, {
        default: () => Gu
    });
    var Gu = class extends vt {
        static{o(this, "default")
        }static targets = ["number"];
        connect() {
            super.connect()
        }
        increment(n) {
            let t = parseInt(this.numberTarget.value) || 0
              , e = parseInt(n.target.dataset.step);
            this.numberTarget.value = t + e
        }
        set(n) {
            this.numberTarget.value = n.target.dataset.amount
        }
    }
    ;
    var Zu = {};
    Rt(Zu, {
        default: () => Ju
    });
    var Ju = class extends vt {
        static{o(this, "default")
        }static targets = ["button", "textarea"];
        static values = {
            note: String
        };
        connect() {
            super.connect(),
            this.update()
        }
        update() {
            this.buttonTarget.classList.toggle("has-note", this.textareaTarget.value != "")
        }
    }
    ;
    var eh = {};
    Rt(eh, {
        default: () => th
    });
    var th = class extends vt {
        static{o(this, "default")
        }connect() {
            window.addEventListener("scroll", () => {
                let n = window.scrollY;
                this.element.querySelector("img").style.transform = `translateY(${n * .2}px)`
            }
            )
        }
    }
    ;
    var nh = {};
    Rt(nh, {
        default: () => ih
    });
    var ih = class extends vt {
        static{o(this, "default")
        }static targets = ["stateSelect", "regionSelect"];
        static values = {
            associationMap: Object
        };
        connect() {
            super.connect(),
            this.update()
        }
        update() {
            this.regionSelectTarget.value = this.associationMapValue[this.stateSelectTarget.value]
        }
    }
    ;
    var rh = {};
    Rt(rh, {
        default: () => sh
    });
    var sh = class extends vt {
        static{o(this, "default")
        }static targets = ["resultSVG", "details"];
        static values = {
            data: Object
        };
        connect() {
            super.connect(),
            Object.entries(this.dataValue).forEach( ([n,t], e) => {
                this.init_svg_element(n, t, e)
            }
            )
        }
        open_popover(n) {
            let t = n.currentTarget.dataset.key
              , e = this.dataValue[t].svgId
              , s = this.resultSVGTarget.querySelector(`#${e}`);
            $(s).popover("show")
        }
        close_popover(n) {
            $(".dfb-section").popover("hide")
        }
        init_svg_element(n, t, e) {
            let s = this.resultSVGTarget.querySelector(`#${t.svgId}`);
            s.tabIndex = e + 1;
            let r = this.detailsTargets.find(a => a.dataset["dfbCalculator-ResultSvgDetailsKey"] == n);
            $(s).popover({
                content: r,
                html: !0,
                container: "#result_svg",
                trigger: "click"
            }).on("show.bs.popover", a => {
                $(".dfb-section").not(a.target).popover("hide")
            }
            )
        }
    }
    ;
    var lh = {};
    Rt(lh, {
        default: () => ah
    });
    var oh = {};
    Rt(oh, {
        default: () => uo
    });
    function ip(n, t=400) {
        if (n.style.opacity = 0,
        n.style.display == "none" && (n.style.display = n.dataset.originalDisplay || "block"),
        t === 0) {
            n.style.opacity = 1;
            return
        }
        let e = performance.now();
        function s(r) {
            let a = r - e
              , l = Math.min(a / t, 1);
            n.style.opacity = l,
            l < 1 && requestAnimationFrame(s)
        }
        o(s, "tick"),
        requestAnimationFrame(s)
    }
    o(ip, "fadeIn");
    function np(n, t=400) {
        if (t === 0) {
            n.style.opacity = 0,
            n.style.display = "none";
            return
        }
        let e = performance.now();
        function s(r) {
            let a = r - e
              , l = Math.min(a / t, 1);
            n.style.opacity = 1 - l,
            l < 1 ? requestAnimationFrame(s) : (n.dataset.originalDisplay || (n.dataset.originalDisplay = getComputedStyle(n).display),
            n.style.display = "none")
        }
        o(s, "tick"),
        requestAnimationFrame(s)
    }
    o(np, "fadeOut");
    var uo = class extends vt {
        static{o(this, "default")
        }static targets = ["checkbox", "radio", "toggleClass", "toggleAttribute", "showWhenOn", "showWhenOff", "fadeInWhenOn", "fadeInWhenOff", "expandWhenOn", "expandWhenOff", "toggleOnWhenOn", "toggleOnWhenOff"];
        static values = {
            state: Boolean,
            condition: String
        };
        skipAnimation = !0;
        connect() {
            if (super.connect(),
            !this.hasStateValue)
                throw "you must pass a state value to the controller";
            this.radioTargets.forEach(n => {
                n.tagName == "INPUT" && console.error("don't use radio targets on input elements but on the wrapper element")
            }
            )
        }
        toggle() {
            this.stateValue = !this.stateValue
        }
        toggleWithCondition(n) {
            let t = this.conditionValue && this.conditionValue.split(" ");
            if (t && t.length >= 2) {
                let e = n.target && n.target.value;
                switch (t[0]) {
                case ">":
                    this.stateValue = parseFloat(e) > parseFloat(t[1]);
                    break;
                case ">=":
                    this.stateValue = parseFloat(e) >= parseFloat(t[1]);
                    break;
                case "<":
                    this.stateValue = parseFloat(e) < parseFloat(t[1]);
                    break;
                case "<=":
                    this.stateValue = parseFloat(e) >= parseFloat(t[1]);
                    break;
                case "==":
                    this.stateValue = e === t[1];
                    break;
                case "!=":
                    this.stateValue = e !== t[1];
                    break
                }
            }
        }
        toggleByRadio(n) {
            if (!n || !n.target || n.target.type != "radio")
                return;
            let t = this.radioTargets.find(e => e == n.currentTarget);
            if (t) {
                if (this.getRadioButtonValuesForState(t, !0).includes(n.target)) {
                    this.stateValue = !0;
                    return
                }
                this.getRadioButtonValuesForState(t, !1).includes(n.target) && (this.stateValue = !1)
            }
        }
        toggleTrue() {
            this.stateValue = !0
        }
        toggleFalse() {
            this.stateValue = !1
        }
        setState(n, t=!1) {
            this.skipAnimation = t,
            this.stateValue = n
        }
        stateValueChanged() {
            setTimeout( () => {
                this.hasCheckboxTarget && (this.checkboxTarget.checked = this.stateValue),
                this.updateRadioTargets(),
                this.updateToggleClassTargets(),
                this.updateToggleAttributeTargets(),
                this.updateShowTargets(),
                this.updateFadeTargets(),
                this.updateExpandTargets(),
                this.updateToggleControllerTargets(),
                this.skipAnimation = !1
            }
            , 0)
        }
        updateRadioTargets() {
            this.radioTargets.forEach(n => {
                let t = this.getRadioButtonValuesForState(n, this.stateValue);
                t.some(e => e.checked) || t[0] && (t[0].checked = !0)
            }
            )
        }
        getRadioButtonValuesForState(n, t) {
            let e = this.identifierCamelCase()
              , s = n.dataset[`${e}FalseValues`];
            typeof s == "string" && (s = s.split(" "));
            let r = n.dataset[`${e}TrueValues`];
            typeof r == "string" && (r = r.split(" ")),
            !r && !s && (r = ["true", "1"],
            s = ["false", "0"]);
            let a = Array.from(n.querySelectorAll("input[type=radio]"))
              , l = t ? r : s;
            if (l)
                return a.filter(d => l.includes(d.value.toLowerCase()));
            let u = t ? s : r;
            return a.filter(d => !u.includes(d.value.toLowerCase()))
        }
        updateToggleClassTargets() {
            this.toggleClassTargets.forEach(n => {
                let t = n.dataset[this.identifierCamelCase() + "OnClass"];
                t && t.split(" ").forEach(s => {
                    this.stateValue ? n.classList.add(s) : n.classList.remove(s)
                }
                );
                let e = n.dataset[this.identifierCamelCase() + "OffClass"];
                e && e.split(" ").forEach(s => {
                    this.stateValue ? n.classList.remove(s) : n.classList.add(s)
                }
                )
            }
            )
        }
        updateToggleAttributeTargets() {
            this.toggleAttributeTargets.forEach(n => {
                let t = n.dataset.toggleOnAttribute
                  , e = n.dataset.toggleOffAttribute
                  , s = e ? JSON.parse(e) : {}
                  , r = t ? JSON.parse(t) : {};
                this.stateValue && ([s,r] = [r, s]),
                Object.keys(r).forEach(a => {
                    n.removeAttribute(a)
                }
                ),
                Object.entries(s).forEach( ([a,l]) => {
                    n.setAttribute(a, l)
                }
                )
            }
            )
        }
        updateShowTargets() {
            let n = this.showWhenOffTargets
              , t = this.showWhenOnTargets;
            this.stateValue && ([n,t] = [t, n]),
            n.forEach(e => {
                e.removeAttribute("hidden")
            }
            ),
            t.forEach(e => {
                e.setAttribute("hidden", !0)
            }
            )
        }
        updateFadeTargets() {
            let n = this.fadeInWhenOffTargets
              , t = this.fadeInWhenOnTargets;
            this.stateValue && ([t,n] = [n, t]),
            n.forEach(e => {
                ip(e, this.skipAnimation ? 0 : void 0)
            }
            ),
            t.forEach(e => {
                np(e, this.skipAnimation ? 0 : void 0)
            }
            )
        }
        updateExpandTargets() {
            let n = this.expandWhenOffTargets
              , t = this.expandWhenOnTargets;
            this.stateValue && ([t,n] = [n, t]),
            this.skipAnimation ? (n.forEach(e => {
                e.classList.add("show")
            }
            ),
            t.forEach(e => {
                e.classList.remove("show")
            }
            )) : (n.forEach(e => {
                $(e).collapse("show")
            }
            ),
            t.forEach(e => {
                $(e).collapse("hide")
            }
            ))
        }
        updateToggleControllerTargets() {
            this.toggleOnWhenOnTargets.forEach(n => {
                let t = n.dataset[this.identifierCamelCase() + "ToggleController"] || "toggle"
                  , e = n[t];
                e && e.setState(this.stateValue, this.skipAnimation)
            }
            ),
            this.toggleOnWhenOffTargets.forEach(n => {
                let t = n.dataset[this.identifierCamelCase() + "ToggleController"] || "toggle"
                  , e = n[t];
                e && e.setState(!this.stateValue, this.skipAnimation)
            }
            )
        }
    }
    ;
    var ah = class extends uo {
        static{o(this, "default")
        }static values = {
            disabledState: Boolean,
            controllerName: String
        };
        backupState = null;
        stateValueChanged() {
            super.stateValueChanged();
            let n = this.hasControllerNameValue ? this.controllerNameValue : "toggle"
              , t = this.element[n];
            t && (this.stateValue ? (this.backupState = t.stateValue,
            t.setState(this.disabledStateValue)) : this.backupState != null && t.setState(this.backupState))
        }
    }
    ;
    var uh = {};
    Rt(uh, {
        default: () => ch
    });
    var ch = class extends vt {
        static{o(this, "default")
        }static targets = ["metaline"];
        static values = {
            prevScrollpos: Number
        };
        connect() {
            super.connect(),
            this.prevScrollposValue = window.scrollY,
            document.addEventListener("scroll", this.scrollHandler),
            window.addEventListener("resize", this.scrollHandler)
        }
        scrollHandler = o(n => {
            let t = window.scrollY
              , e = this.metalineTarget.offsetHeight
              , s = this.prevScrollposValue < e
              , r = this.prevScrollposValue > t
              , a = n.type == "scroll" ? "top 0.35s linear" : ""
              , l = r ? 0 : -e;
            if (s) {
                a = "";
                let u = [-t, this.element.offsetTop];
                l = r ? Math.max(...u) : Math.min(...u),
                l = Math.max(l, -e)
            }
            this.element.style.transition = a,
            this.element.style.top = `${l}px`,
            this.prevScrollposValue = t
        }
        , "scrollHandler")
    }
    ;
    var dh = {};
    Rt(dh, {
        default: () => hh
    });
    var hh = class extends vt {
        static{o(this, "default")
        }static targets = ["source", "dest"];
        connect() {
            super.connect(),
            this.updateDest()
        }
        update(n) {
            let t = this.sourceTargets.reduce( (s, r) => r == n.target || r.value == "" ? s : s - parseFloat(r.value), 100)
              , e = n.target.value;
            e < 0 && (e = 0),
            e > t && (e = t),
            e != n.target.value && (n.target.value = e),
            this.updateDest()
        }
        updateDest() {
            let n = this.sourceTargets.reduce( (t, e) => t + (e.value == "" ? 0 : parseFloat(e.value)), 0);
            ["INPUT", "TEXTAREA", "SELECT"].includes(this.destTarget.tagName) ? this.destTarget.value = 100 - n : this.destTarget.innerHTML = `${100 - n}%`
        }
    }
    ;
    var ph = {};
    Rt(ph, {
        default: () => fh
    });
    var fh = class extends qe {
        static{o(this, "default")
        }static values = {
            url: String,
            data: Object,
            preventDefault: Boolean
        };
        post(n) {
            this.preventDefaultValue && n.preventDefault(),
            fetch(this.urlValue, {
                method: "POST",
                headers: {
                    "X-CSRF-Token": document.querySelector('meta[name="csrf-token"]').content,
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(this.dataValue)
            })
        }
    }
    ;
    var mh = {};
    Rt(mh, {
        default: () => gh
    });
    var gh = class extends vt {
        static{o(this, "default")
        }static targets = ["carousel", "nav"];
        addNewEvent(n) {
            let t = this.navTarget.querySelectorAll(".nav-item")
              , e = this.carouselTarget.querySelectorAll(".carousel-item, .carousel-hidden-item")
              , s = n.currentTarget.closest(".carousel-item")
              , r = parseInt(s.dataset.carouselSlideToNumber)
              , l = t[r].querySelector(".nav-link");
            $(l).tooltip("dispose"),
            l.setAttribute("title", l.dataset.newTitle),
            $(l).tooltip();
            let u = s.querySelector("[data-title-type=new_event]");
            u.classList.add("d-none"),
            u.classList.remove("d-flex");
            let d = s.querySelector("[data-title-type=present_event]");
            d.classList.remove("d-none"),
            d.classList.add("d-flex"),
            s.toggle.setState(!1, !1),
            r++;
            let p = e[r];
            if (p && p.classList.contains("carousel-hidden-item")) {
                p.dataset.carouselSlideToNumber = r,
                p.classList.remove("carousel-hidden-item", "d-none"),
                p.classList.add("carousel-item");
                let b = t[r];
                b.classList.remove("d-none"),
                b.querySelector(".nav-link").dataset.slideTo = r,
                b.querySelector(".number-as-link-text").innerHTML = r + 1;
                let E = r + 1;
                for (; E < e.length; ) {
                    let x = e[E];
                    if (x.classList.contains("carousel-item")) {
                        r++,
                        x.dataset.carouselSlideToNumber = r;
                        let w = t[E];
                        w.querySelector(".nav-link").dataset.slideTo = r,
                        w.querySelector(".number-as-link-text").innerHTML = r + 1
                    }
                    E++
                }
                $(this.carouselTarget).carousel()
            }
        }
    }
    ;
    var xd = {};
    Rt(xd, {
        default: () => Td
    });
    function Ui() {}
    o(Ui, "noop");
    var bp = (function() {
        let n = 0;
        return function() {
            return n++
        }
    }
    )();
    function zt(n) {
        return n === null || typeof n > "u"
    }
    o(zt, "isNullOrUndef");
    function ee(n) {
        if (Array.isArray && Array.isArray(n))
            return !0;
        let t = Object.prototype.toString.call(n);
        return t.slice(0, 7) === "[object" && t.slice(-6) === "Array]"
    }
    o(ee, "isArray");
    function Ht(n) {
        return n !== null && Object.prototype.toString.call(n) === "[object Object]"
    }
    o(Ht, "isObject");
    var fe = o(n => (typeof n == "number" || n instanceof Number) && isFinite(+n), "isNumberFinite");
    function ri(n, t) {
        return fe(n) ? n : t
    }
    o(ri, "finiteOrDefault");
    function It(n, t) {
        return typeof n > "u" ? t : n
    }
    o(It, "valueOrDefault");
    var yp = o( (n, t) => typeof n == "string" && n.endsWith("%") ? parseFloat(n) / 100 : n / t, "toPercentage")
      , xh = o( (n, t) => typeof n == "string" && n.endsWith("%") ? parseFloat(n) / 100 * t : +n, "toDimension");
    function ie(n, t, e) {
        if (n && typeof n.call == "function")
            return n.apply(e, t)
    }
    o(ie, "callback");
    function Jt(n, t, e, s) {
        let r, a, l;
        if (ee(n))
            if (a = n.length,
            s)
                for (r = a - 1; r >= 0; r--)
                    t.call(e, n[r], r);
            else
                for (r = 0; r < a; r++)
                    t.call(e, n[r], r);
        else if (Ht(n))
            for (l = Object.keys(n),
            a = l.length,
            r = 0; r < a; r++)
                t.call(e, n[l[r]], l[r])
    }
    o(Jt, "each");
    function mo(n, t) {
        let e, s, r, a;
        if (!n || !t || n.length !== t.length)
            return !1;
        for (e = 0,
        s = n.length; e < s; ++e)
            if (r = n[e],
            a = t[e],
            r.datasetIndex !== a.datasetIndex || r.index !== a.index)
                return !1;
        return !0
    }
    o(mo, "_elementsEqual");
    function Fa(n) {
        if (ee(n))
            return n.map(Fa);
        if (Ht(n)) {
            let t = Object.create(null)
              , e = Object.keys(n)
              , s = e.length
              , r = 0;
            for (; r < s; ++r)
                t[e[r]] = Fa(n[e[r]]);
            return t
        }
        return n
    }
    o(Fa, "clone$1");
    function _p(n) {
        return ["__proto__", "prototype", "constructor"].indexOf(n) === -1
    }
    o(_p, "isValidKey");
    function fy(n, t, e, s) {
        if (!_p(n))
            return;
        let r = t[n]
          , a = e[n];
        Ht(r) && Ht(a) ? er(r, a, s) : t[n] = Fa(a)
    }
    o(fy, "_merger");
    function er(n, t, e) {
        let s = ee(t) ? t : [t]
          , r = s.length;
        if (!Ht(n))
            return n;
        e = e || {};
        let a = e.merger || fy;
        for (let l = 0; l < r; ++l) {
            if (t = s[l],
            !Ht(t))
                continue;
            let u = Object.keys(t);
            for (let d = 0, p = u.length; d < p; ++d)
                a(u[d], n, t, e)
        }
        return n
    }
    o(er, "merge");
    function sr(n, t) {
        return er(n, t, {
            merger: py
        })
    }
    o(sr, "mergeIf");
    function py(n, t, e) {
        if (!_p(n))
            return;
        let s = t[n]
          , r = e[n];
        Ht(s) && Ht(r) ? sr(s, r) : Object.prototype.hasOwnProperty.call(t, n) || (t[n] = Fa(r))
    }
    o(py, "_mergerIf");
    var sp = {
        "": n => n,
        x: o(n => n.x, "x"),
        y: o(n => n.y, "y")
    };
    function gn(n, t) {
        return (sp[t] || (sp[t] = gy(t)))(n)
    }
    o(gn, "resolveObjectKey");
    function gy(n) {
        let t = my(n);
        return e => {
            for (let s of t) {
                if (s === "")
                    break;
                e = e && e[s]
            }
            return e
        }
    }
    o(gy, "_getKeyResolver");
    function my(n) {
        let t = n.split(".")
          , e = []
          , s = "";
        for (let r of t)
            s += r,
            s.endsWith("\\") ? s = s.slice(0, -1) + "." : (e.push(s),
            s = "");
        return e
    }
    o(my, "_splitKey");
    function ja(n) {
        return n.charAt(0).toUpperCase() + n.slice(1)
    }
    o(ja, "_capitalize");
    var si = o(n => typeof n < "u", "defined")
      , pn = o(n => typeof n == "function", "isFunction")
      , wh = o( (n, t) => {
        if (n.size !== t.size)
            return !1;
        for (let e of n)
            if (!t.has(e))
                return !1;
        return !0
    }
    , "setsEqual");
    function Ep(n) {
        return n.type === "mouseup" || n.type === "click" || n.type === "contextmenu"
    }
    o(Ep, "_isClickEvent");
    var ae = Math.PI
      , te = 2 * ae
      , vy = te + ae
      , Va = Number.POSITIVE_INFINITY
      , by = ae / 180
      , he = ae / 2
      , ho = ae / 4
      , rp = ae * 2 / 3
      , oi = Math.log10
      , Oi = Math.sign;
    function Ch(n) {
        let t = Math.round(n);
        n = rr(n, t, n / 1e3) ? t : n;
        let e = Math.pow(10, Math.floor(oi(n)))
          , s = n / e;
        return (s <= 1 ? 1 : s <= 2 ? 2 : s <= 5 ? 5 : 10) * e
    }
    o(Ch, "niceNum");
    function Sp(n) {
        let t = [], e = Math.sqrt(n), s;
        for (s = 1; s < e; s++)
            n % s === 0 && (t.push(s),
            t.push(n / s));
        return e === (e | 0) && t.push(e),
        t.sort( (r, a) => r - a).pop(),
        t
    }
    o(Sp, "_factorize");
    function ms(n) {
        return !isNaN(parseFloat(n)) && isFinite(n)
    }
    o(ms, "isNumber");
    function rr(n, t, e) {
        return Math.abs(n - t) < e
    }
    o(rr, "almostEquals");
    function Tp(n, t) {
        let e = Math.round(n);
        return e - t <= n && e + t >= n
    }
    o(Tp, "almostWhole");
    function Ah(n, t, e) {
        let s, r, a;
        for (s = 0,
        r = n.length; s < r; s++)
            a = n[s][e],
            isNaN(a) || (t.min = Math.min(t.min, a),
            t.max = Math.max(t.max, a))
    }
    o(Ah, "_setMinAndMaxByKey");
    function _i(n) {
        return n * (ae / 180)
    }
    o(_i, "toRadians");
    function Wa(n) {
        return n * (180 / ae)
    }
    o(Wa, "toDegrees");
    function kh(n) {
        if (!fe(n))
            return;
        let t = 1
          , e = 0;
        for (; Math.round(n * t) / t !== n; )
            t *= 10,
            e++;
        return e
    }
    o(kh, "_decimalPlaces");
    function Mh(n, t) {
        let e = t.x - n.x
          , s = t.y - n.y
          , r = Math.sqrt(e * e + s * s)
          , a = Math.atan2(s, e);
        return a < -.5 * ae && (a += te),
        {
            angle: a,
            distance: r
        }
    }
    o(Mh, "getAngleFromPoint");
    function Ba(n, t) {
        return Math.sqrt(Math.pow(t.x - n.x, 2) + Math.pow(t.y - n.y, 2))
    }
    o(Ba, "distanceBetweenPoints");
    function yy(n, t) {
        return (n - t + vy) % te - ae
    }
    o(yy, "_angleDiff");
    function ze(n) {
        return (n % te + te) % te
    }
    o(ze, "_normalizeAngle");
    function or(n, t, e, s) {
        let r = ze(n)
          , a = ze(t)
          , l = ze(e)
          , u = ze(a - r)
          , d = ze(l - r)
          , p = ze(r - a)
          , b = ze(r - l);
        return r === a || r === l || s && a === l || u > d && p < b
    }
    o(or, "_angleBetween");
    function be(n, t, e) {
        return Math.max(t, Math.min(e, n))
    }
    o(be, "_limitValue");
    function xp(n) {
        return be(n, -32768, 32767)
    }
    o(xp, "_int16Range");
    function Ki(n, t, e, s=1e-6) {
        return n >= Math.min(t, e) - s && n <= Math.max(t, e) + s
    }
    o(Ki, "_isBetween");
    function $a(n, t, e) {
        e = e || (l => n[l] < t);
        let s = n.length - 1, r = 0, a;
        for (; s - r > 1; )
            a = r + s >> 1,
            e(a) ? r = a : s = a;
        return {
            lo: r,
            hi: s
        }
    }
    o($a, "_lookup");
    var zi = o( (n, t, e, s) => $a(n, e, s ? r => n[r][t] <= e : r => n[r][t] < e), "_lookupByKey")
      , wp = o( (n, t, e) => $a(n, e, s => n[s][t] >= e), "_rlookupByKey");
    function Cp(n, t, e) {
        let s = 0
          , r = n.length;
        for (; s < r && n[s] < t; )
            s++;
        for (; r > s && n[r - 1] > e; )
            r--;
        return s > 0 || r < n.length ? n.slice(s, r) : n
    }
    o(Cp, "_filterBetween");
    var Ap = ["push", "pop", "shift", "splice", "unshift"];
    function kp(n, t) {
        if (n._chartjs) {
            n._chartjs.listeners.push(t);
            return
        }
        Object.defineProperty(n, "_chartjs", {
            configurable: !0,
            enumerable: !1,
            value: {
                listeners: [t]
            }
        }),
        Ap.forEach(e => {
            let s = "_onData" + ja(e)
              , r = n[e];
            Object.defineProperty(n, e, {
                configurable: !0,
                enumerable: !1,
                value(...a) {
                    let l = r.apply(this, a);
                    return n._chartjs.listeners.forEach(u => {
                        typeof u[s] == "function" && u[s](...a)
                    }
                    ),
                    l
                }
            })
        }
        )
    }
    o(kp, "listenArrayEvents");
    function Oh(n, t) {
        let e = n._chartjs;
        if (!e)
            return;
        let s = e.listeners
          , r = s.indexOf(t);
        r !== -1 && s.splice(r, 1),
        !(s.length > 0) && (Ap.forEach(a => {
            delete n[a]
        }
        ),
        delete n._chartjs)
    }
    o(Oh, "unlistenArrayEvents");
    function Lh(n) {
        let t = new Set, e, s;
        for (e = 0,
        s = n.length; e < s; ++e)
            t.add(n[e]);
        return t.size === s ? n : Array.from(t)
    }
    o(Lh, "_arrayUnique");
    var Dh = (function() {
        return typeof window > "u" ? function(n) {
            return n()
        }
        : window.requestAnimationFrame
    }
    )();
    function Ph(n, t, e) {
        let s = e || (l => Array.prototype.slice.call(l))
          , r = !1
          , a = [];
        return function(...l) {
            a = s(l),
            r || (r = !0,
            Dh.call(window, () => {
                r = !1,
                n.apply(t, a)
            }
            ))
        }
    }
    o(Ph, "throttled");
    function Mp(n, t) {
        let e;
        return function(...s) {
            return t ? (clearTimeout(e),
            e = setTimeout(n, t, s)) : n.apply(this, s),
            t
        }
    }
    o(Mp, "debounce");
    var qa = o(n => n === "start" ? "left" : n === "end" ? "right" : "center", "_toLeftRightCenter")
      , ke = o( (n, t, e) => n === "start" ? t : n === "end" ? e : (t + e) / 2, "_alignStartEnd")
      , Op = o( (n, t, e, s) => n === (s ? "left" : "right") ? e : n === "center" ? (t + e) / 2 : t, "_textX");
    function Rh(n, t, e) {
        let s = t.length
          , r = 0
          , a = s;
        if (n._sorted) {
            let {iScale: l, _parsed: u} = n
              , d = l.axis
              , {min: p, max: b, minDefined: E, maxDefined: x} = l.getUserBounds();
            E && (r = be(Math.min(zi(u, l.axis, p).lo, e ? s : zi(t, d, l.getPixelForValue(p)).lo), 0, s - 1)),
            x ? a = be(Math.max(zi(u, l.axis, b, !0).hi + 1, e ? 0 : zi(t, d, l.getPixelForValue(b), !0).hi + 1), r, s) - r : a = s - r
        }
        return {
            start: r,
            count: a
        }
    }
    o(Rh, "_getStartAndCountOfVisiblePoints");
    function Ih(n) {
        let {xScale: t, yScale: e, _scaleRanges: s} = n
          , r = {
            xmin: t.min,
            xmax: t.max,
            ymin: e.min,
            ymax: e.max
        };
        if (!s)
            return n._scaleRanges = r,
            !0;
        let a = s.xmin !== t.min || s.xmax !== t.max || s.ymin !== e.min || s.ymax !== e.max;
        return Object.assign(s, r),
        a
    }
    o(Ih, "_scaleRangesChanged");
    var Da = o(n => n === 0 || n === 1, "atEdge")
      , op = o( (n, t, e) => -(Math.pow(2, 10 * (n -= 1)) * Math.sin((n - t) * te / e)), "elasticIn")
      , ap = o( (n, t, e) => Math.pow(2, -10 * n) * Math.sin((n - t) * te / e) + 1, "elasticOut")
      , tr = {
        linear: o(n => n, "linear"),
        easeInQuad: o(n => n * n, "easeInQuad"),
        easeOutQuad: o(n => -n * (n - 2), "easeOutQuad"),
        easeInOutQuad: o(n => (n /= .5) < 1 ? .5 * n * n : -.5 * (--n * (n - 2) - 1), "easeInOutQuad"),
        easeInCubic: o(n => n * n * n, "easeInCubic"),
        easeOutCubic: o(n => (n -= 1) * n * n + 1, "easeOutCubic"),
        easeInOutCubic: o(n => (n /= .5) < 1 ? .5 * n * n * n : .5 * ((n -= 2) * n * n + 2), "easeInOutCubic"),
        easeInQuart: o(n => n * n * n * n, "easeInQuart"),
        easeOutQuart: o(n => -((n -= 1) * n * n * n - 1), "easeOutQuart"),
        easeInOutQuart: o(n => (n /= .5) < 1 ? .5 * n * n * n * n : -.5 * ((n -= 2) * n * n * n - 2), "easeInOutQuart"),
        easeInQuint: o(n => n * n * n * n * n, "easeInQuint"),
        easeOutQuint: o(n => (n -= 1) * n * n * n * n + 1, "easeOutQuint"),
        easeInOutQuint: o(n => (n /= .5) < 1 ? .5 * n * n * n * n * n : .5 * ((n -= 2) * n * n * n * n + 2), "easeInOutQuint"),
        easeInSine: o(n => -Math.cos(n * he) + 1, "easeInSine"),
        easeOutSine: o(n => Math.sin(n * he), "easeOutSine"),
        easeInOutSine: o(n => -.5 * (Math.cos(ae * n) - 1), "easeInOutSine"),
        easeInExpo: o(n => n === 0 ? 0 : Math.pow(2, 10 * (n - 1)), "easeInExpo"),
        easeOutExpo: o(n => n === 1 ? 1 : -Math.pow(2, -10 * n) + 1, "easeOutExpo"),
        easeInOutExpo: o(n => Da(n) ? n : n < .5 ? .5 * Math.pow(2, 10 * (n * 2 - 1)) : .5 * (-Math.pow(2, -10 * (n * 2 - 1)) + 2), "easeInOutExpo"),
        easeInCirc: o(n => n >= 1 ? n : -(Math.sqrt(1 - n * n) - 1), "easeInCirc"),
        easeOutCirc: o(n => Math.sqrt(1 - (n -= 1) * n), "easeOutCirc"),
        easeInOutCirc: o(n => (n /= .5) < 1 ? -.5 * (Math.sqrt(1 - n * n) - 1) : .5 * (Math.sqrt(1 - (n -= 2) * n) + 1), "easeInOutCirc"),
        easeInElastic: o(n => Da(n) ? n : op(n, .075, .3), "easeInElastic"),
        easeOutElastic: o(n => Da(n) ? n : ap(n, .075, .3), "easeOutElastic"),
        easeInOutElastic(n) {
            return Da(n) ? n : n < .5 ? .5 * op(n * 2, .1125, .45) : .5 + .5 * ap(n * 2 - 1, .1125, .45)
        },
        easeInBack(n) {
            return n * n * ((1.70158 + 1) * n - 1.70158)
        },
        easeOutBack(n) {
            return (n -= 1) * n * ((1.70158 + 1) * n + 1.70158) + 1
        },
        easeInOutBack(n) {
            let t = 1.70158;
            return (n /= .5) < 1 ? .5 * (n * n * (((t *= 1.525) + 1) * n - t)) : .5 * ((n -= 2) * n * (((t *= 1.525) + 1) * n + t) + 2)
        },
        easeInBounce: o(n => 1 - tr.easeOutBounce(1 - n), "easeInBounce"),
        easeOutBounce(n) {
            return n < 1 / 2.75 ? 7.5625 * n * n : n < 2 / 2.75 ? 7.5625 * (n -= 1.5 / 2.75) * n + .75 : n < 2.5 / 2.75 ? 7.5625 * (n -= 2.25 / 2.75) * n + .9375 : 7.5625 * (n -= 2.625 / 2.75) * n + .984375
        },
        easeInOutBounce: o(n => n < .5 ? tr.easeInBounce(n * 2) * .5 : tr.easeOutBounce(n * 2 - 1) * .5 + .5, "easeInOutBounce")
    };
    function vo(n) {
        return n + .5 | 0
    }
    o(vo, "round");
    var Nn = o( (n, t, e) => Math.max(Math.min(n, e), t), "lim");
    function fo(n) {
        return Nn(vo(n * 2.55), 0, 255)
    }
    o(fo, "p2b");
    function Fn(n) {
        return Nn(vo(n * 255), 0, 255)
    }
    o(Fn, "n2b");
    function fn(n) {
        return Nn(vo(n / 2.55) / 100, 0, 1)
    }
    o(fn, "b2n");
    function lp(n) {
        return Nn(vo(n * 100), 0, 100)
    }
    o(lp, "n2p");
    var yi = {
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        A: 10,
        B: 11,
        C: 12,
        D: 13,
        E: 14,
        F: 15,
        a: 10,
        b: 11,
        c: 12,
        d: 13,
        e: 14,
        f: 15
    }
      , Eh = [..."0123456789ABCDEF"]
      , _y = o(n => Eh[n & 15], "h1")
      , Ey = o(n => Eh[(n & 240) >> 4] + Eh[n & 15], "h2")
      , Pa = o(n => (n & 240) >> 4 === (n & 15), "eq")
      , Sy = o(n => Pa(n.r) && Pa(n.g) && Pa(n.b) && Pa(n.a), "isShort");
    function Ty(n) {
        var t = n.length, e;
        return n[0] === "#" && (t === 4 || t === 5 ? e = {
            r: 255 & yi[n[1]] * 17,
            g: 255 & yi[n[2]] * 17,
            b: 255 & yi[n[3]] * 17,
            a: t === 5 ? yi[n[4]] * 17 : 255
        } : (t === 7 || t === 9) && (e = {
            r: yi[n[1]] << 4 | yi[n[2]],
            g: yi[n[3]] << 4 | yi[n[4]],
            b: yi[n[5]] << 4 | yi[n[6]],
            a: t === 9 ? yi[n[7]] << 4 | yi[n[8]] : 255
        })),
        e
    }
    o(Ty, "hexParse");
    var xy = o( (n, t) => n < 255 ? t(n) : "", "alpha");
    function wy(n) {
        var t = Sy(n) ? _y : Ey;
        return n ? "#" + t(n.r) + t(n.g) + t(n.b) + xy(n.a, t) : void 0
    }
    o(wy, "hexString");
    var Cy = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
    function Lp(n, t, e) {
        let s = t * Math.min(e, 1 - e)
          , r = o( (a, l=(a + n / 30) % 12) => e - s * Math.max(Math.min(l - 3, 9 - l, 1), -1), "f");
        return [r(0), r(8), r(4)]
    }
    o(Lp, "hsl2rgbn");
    function Ay(n, t, e) {
        let s = o( (r, a=(r + n / 60) % 6) => e - e * t * Math.max(Math.min(a, 4 - a, 1), 0), "f");
        return [s(5), s(3), s(1)]
    }
    o(Ay, "hsv2rgbn");
    function ky(n, t, e) {
        let s = Lp(n, 1, .5), r;
        for (t + e > 1 && (r = 1 / (t + e),
        t *= r,
        e *= r),
        r = 0; r < 3; r++)
            s[r] *= 1 - t - e,
            s[r] += t;
        return s
    }
    o(ky, "hwb2rgbn");
    function My(n, t, e, s, r) {
        return n === r ? (t - e) / s + (t < e ? 6 : 0) : t === r ? (e - n) / s + 2 : (n - t) / s + 4
    }
    o(My, "hueValue");
    function Nh(n) {
        let e = n.r / 255, s = n.g / 255, r = n.b / 255, a = Math.max(e, s, r), l = Math.min(e, s, r), u = (a + l) / 2, d, p, b;
        return a !== l && (b = a - l,
        p = u > .5 ? b / (2 - a - l) : b / (a + l),
        d = My(e, s, r, b, a),
        d = d * 60 + .5),
        [d | 0, p || 0, u]
    }
    o(Nh, "rgb2hsl");
    function Fh(n, t, e, s) {
        return (Array.isArray(t) ? n(t[0], t[1], t[2]) : n(t, e, s)).map(Fn)
    }
    o(Fh, "calln");
    function Vh(n, t, e) {
        return Fh(Lp, n, t, e)
    }
    o(Vh, "hsl2rgb");
    function Oy(n, t, e) {
        return Fh(ky, n, t, e)
    }
    o(Oy, "hwb2rgb");
    function Ly(n, t, e) {
        return Fh(Ay, n, t, e)
    }
    o(Ly, "hsv2rgb");
    function Dp(n) {
        return (n % 360 + 360) % 360
    }
    o(Dp, "hue");
    function Dy(n) {
        let t = Cy.exec(n), e = 255, s;
        if (!t)
            return;
        t[5] !== s && (e = t[6] ? fo(+t[5]) : Fn(+t[5]));
        let r = Dp(+t[2])
          , a = +t[3] / 100
          , l = +t[4] / 100;
        return t[1] === "hwb" ? s = Oy(r, a, l) : t[1] === "hsv" ? s = Ly(r, a, l) : s = Vh(r, a, l),
        {
            r: s[0],
            g: s[1],
            b: s[2],
            a: e
        }
    }
    o(Dy, "hueParse");
    function Py(n, t) {
        var e = Nh(n);
        e[0] = Dp(e[0] + t),
        e = Vh(e),
        n.r = e[0],
        n.g = e[1],
        n.b = e[2]
    }
    o(Py, "rotate");
    function Ry(n) {
        if (!n)
            return;
        let t = Nh(n)
          , e = t[0]
          , s = lp(t[1])
          , r = lp(t[2]);
        return n.a < 255 ? `hsla(${e}, ${s}%, ${r}%, ${fn(n.a)})` : `hsl(${e}, ${s}%, ${r}%)`
    }
    o(Ry, "hslString");
    var cp = {
        x: "dark",
        Z: "light",
        Y: "re",
        X: "blu",
        W: "gr",
        V: "medium",
        U: "slate",
        A: "ee",
        T: "ol",
        S: "or",
        B: "ra",
        C: "lateg",
        D: "ights",
        R: "in",
        Q: "turquois",
        E: "hi",
        P: "ro",
        O: "al",
        N: "le",
        M: "de",
        L: "yello",
        F: "en",
        K: "ch",
        G: "arks",
        H: "ea",
        I: "ightg",
        J: "wh"
    }
      , up = {
        OiceXe: "f0f8ff",
        antiquewEte: "faebd7",
        aqua: "ffff",
        aquamarRe: "7fffd4",
        azuY: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "0",
        blanKedOmond: "ffebcd",
        Xe: "ff",
        XeviTet: "8a2be2",
        bPwn: "a52a2a",
        burlywood: "deb887",
        caMtXe: "5f9ea0",
        KartYuse: "7fff00",
        KocTate: "d2691e",
        cSO: "ff7f50",
        cSnflowerXe: "6495ed",
        cSnsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "ffff",
        xXe: "8b",
        xcyan: "8b8b",
        xgTMnPd: "b8860b",
        xWay: "a9a9a9",
        xgYF: "6400",
        xgYy: "a9a9a9",
        xkhaki: "bdb76b",
        xmagFta: "8b008b",
        xTivegYF: "556b2f",
        xSange: "ff8c00",
        xScEd: "9932cc",
        xYd: "8b0000",
        xsOmon: "e9967a",
        xsHgYF: "8fbc8f",
        xUXe: "483d8b",
        xUWay: "2f4f4f",
        xUgYy: "2f4f4f",
        xQe: "ced1",
        xviTet: "9400d3",
        dAppRk: "ff1493",
        dApskyXe: "bfff",
        dimWay: "696969",
        dimgYy: "696969",
        dodgerXe: "1e90ff",
        fiYbrick: "b22222",
        flSOwEte: "fffaf0",
        foYstWAn: "228b22",
        fuKsia: "ff00ff",
        gaRsbSo: "dcdcdc",
        ghostwEte: "f8f8ff",
        gTd: "ffd700",
        gTMnPd: "daa520",
        Way: "808080",
        gYF: "8000",
        gYFLw: "adff2f",
        gYy: "808080",
        honeyMw: "f0fff0",
        hotpRk: "ff69b4",
        RdianYd: "cd5c5c",
        Rdigo: "4b0082",
        ivSy: "fffff0",
        khaki: "f0e68c",
        lavFMr: "e6e6fa",
        lavFMrXsh: "fff0f5",
        lawngYF: "7cfc00",
        NmoncEffon: "fffacd",
        ZXe: "add8e6",
        ZcSO: "f08080",
        Zcyan: "e0ffff",
        ZgTMnPdLw: "fafad2",
        ZWay: "d3d3d3",
        ZgYF: "90ee90",
        ZgYy: "d3d3d3",
        ZpRk: "ffb6c1",
        ZsOmon: "ffa07a",
        ZsHgYF: "20b2aa",
        ZskyXe: "87cefa",
        ZUWay: "778899",
        ZUgYy: "778899",
        ZstAlXe: "b0c4de",
        ZLw: "ffffe0",
        lime: "ff00",
        limegYF: "32cd32",
        lRF: "faf0e6",
        magFta: "ff00ff",
        maPon: "800000",
        VaquamarRe: "66cdaa",
        VXe: "cd",
        VScEd: "ba55d3",
        VpurpN: "9370db",
        VsHgYF: "3cb371",
        VUXe: "7b68ee",
        VsprRggYF: "fa9a",
        VQe: "48d1cc",
        VviTetYd: "c71585",
        midnightXe: "191970",
        mRtcYam: "f5fffa",
        mistyPse: "ffe4e1",
        moccasR: "ffe4b5",
        navajowEte: "ffdead",
        navy: "80",
        Tdlace: "fdf5e6",
        Tive: "808000",
        TivedBb: "6b8e23",
        Sange: "ffa500",
        SangeYd: "ff4500",
        ScEd: "da70d6",
        pOegTMnPd: "eee8aa",
        pOegYF: "98fb98",
        pOeQe: "afeeee",
        pOeviTetYd: "db7093",
        papayawEp: "ffefd5",
        pHKpuff: "ffdab9",
        peru: "cd853f",
        pRk: "ffc0cb",
        plum: "dda0dd",
        powMrXe: "b0e0e6",
        purpN: "800080",
        YbeccapurpN: "663399",
        Yd: "ff0000",
        Psybrown: "bc8f8f",
        PyOXe: "4169e1",
        saddNbPwn: "8b4513",
        sOmon: "fa8072",
        sandybPwn: "f4a460",
        sHgYF: "2e8b57",
        sHshell: "fff5ee",
        siFna: "a0522d",
        silver: "c0c0c0",
        skyXe: "87ceeb",
        UXe: "6a5acd",
        UWay: "708090",
        UgYy: "708090",
        snow: "fffafa",
        sprRggYF: "ff7f",
        stAlXe: "4682b4",
        tan: "d2b48c",
        teO: "8080",
        tEstN: "d8bfd8",
        tomato: "ff6347",
        Qe: "40e0d0",
        viTet: "ee82ee",
        JHt: "f5deb3",
        wEte: "ffffff",
        wEtesmoke: "f5f5f5",
        Lw: "ffff00",
        LwgYF: "9acd32"
    };
    function Iy() {
        let n = {}, t = Object.keys(up), e = Object.keys(cp), s, r, a, l, u;
        for (s = 0; s < t.length; s++) {
            for (l = u = t[s],
            r = 0; r < e.length; r++)
                a = e[r],
                u = u.replace(a, cp[a]);
            a = parseInt(up[l], 16),
            n[u] = [a >> 16 & 255, a >> 8 & 255, a & 255]
        }
        return n
    }
    o(Iy, "unpack");
    var Ra;
    function Ny(n) {
        Ra || (Ra = Iy(),
        Ra.transparent = [0, 0, 0, 0]);
        let t = Ra[n.toLowerCase()];
        return t && {
            r: t[0],
            g: t[1],
            b: t[2],
            a: t.length === 4 ? t[3] : 255
        }
    }
    o(Ny, "nameParse");
    var Fy = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
    function Vy(n) {
        let t = Fy.exec(n), e = 255, s, r, a;
        if (t) {
            if (t[7] !== s) {
                let l = +t[7];
                e = t[8] ? fo(l) : Nn(l * 255, 0, 255)
            }
            return s = +t[1],
            r = +t[3],
            a = +t[5],
            s = 255 & (t[2] ? fo(s) : Nn(s, 0, 255)),
            r = 255 & (t[4] ? fo(r) : Nn(r, 0, 255)),
            a = 255 & (t[6] ? fo(a) : Nn(a, 0, 255)),
            {
                r: s,
                g: r,
                b: a,
                a: e
            }
        }
    }
    o(Vy, "rgbParse");
    function By(n) {
        return n && (n.a < 255 ? `rgba(${n.r}, ${n.g}, ${n.b}, ${fn(n.a)})` : `rgb(${n.r}, ${n.g}, ${n.b})`)
    }
    o(By, "rgbString");
    var vh = o(n => n <= .0031308 ? n * 12.92 : Math.pow(n, 1 / 2.4) * 1.055 - .055, "to")
      , Zs = o(n => n <= .04045 ? n / 12.92 : Math.pow((n + .055) / 1.055, 2.4), "from");
    function Hy(n, t, e) {
        let s = Zs(fn(n.r))
          , r = Zs(fn(n.g))
          , a = Zs(fn(n.b));
        return {
            r: Fn(vh(s + e * (Zs(fn(t.r)) - s))),
            g: Fn(vh(r + e * (Zs(fn(t.g)) - r))),
            b: Fn(vh(a + e * (Zs(fn(t.b)) - a))),
            a: n.a + e * (t.a - n.a)
        }
    }
    o(Hy, "interpolate");
    function Ia(n, t, e) {
        if (n) {
            let s = Nh(n);
            s[t] = Math.max(0, Math.min(s[t] + s[t] * e, t === 0 ? 360 : 1)),
            s = Vh(s),
            n.r = s[0],
            n.g = s[1],
            n.b = s[2]
        }
    }
    o(Ia, "modHSL");
    function Pp(n, t) {
        return n && Object.assign(t || {}, n)
    }
    o(Pp, "clone");
    function hp(n) {
        var t = {
            r: 0,
            g: 0,
            b: 0,
            a: 255
        };
        return Array.isArray(n) ? n.length >= 3 && (t = {
            r: n[0],
            g: n[1],
            b: n[2],
            a: 255
        },
        n.length > 3 && (t.a = Fn(n[3]))) : (t = Pp(n, {
            r: 0,
            g: 0,
            b: 0,
            a: 1
        }),
        t.a = Fn(t.a)),
        t
    }
    o(hp, "fromObject");
    function jy(n) {
        return n.charAt(0) === "r" ? Vy(n) : Dy(n)
    }
    o(jy, "functionParse");
    var Sh = class n {
        static{o(this, "Color")
        }constructor(t) {
            if (t instanceof n)
                return t;
            let e = typeof t, s;
            e === "object" ? s = hp(t) : e === "string" && (s = Ty(t) || Ny(t) || jy(t)),
            this._rgb = s,
            this._valid = !!s
        }
        get valid() {
            return this._valid
        }
        get rgb() {
            var t = Pp(this._rgb);
            return t && (t.a = fn(t.a)),
            t
        }
        set rgb(t) {
            this._rgb = hp(t)
        }
        rgbString() {
            return this._valid ? By(this._rgb) : void 0
        }
        hexString() {
            return this._valid ? wy(this._rgb) : void 0
        }
        hslString() {
            return this._valid ? Ry(this._rgb) : void 0
        }
        mix(t, e) {
            if (t) {
                let s = this.rgb, r = t.rgb, a, l = e === a ? .5 : e, u = 2 * l - 1, d = s.a - r.a, p = ((u * d === -1 ? u : (u + d) / (1 + u * d)) + 1) / 2;
                a = 1 - p,
                s.r = 255 & p * s.r + a * r.r + .5,
                s.g = 255 & p * s.g + a * r.g + .5,
                s.b = 255 & p * s.b + a * r.b + .5,
                s.a = l * s.a + (1 - l) * r.a,
                this.rgb = s
            }
            return this
        }
        interpolate(t, e) {
            return t && (this._rgb = Hy(this._rgb, t._rgb, e)),
            this
        }
        clone() {
            return new n(this.rgb)
        }
        alpha(t) {
            return this._rgb.a = Fn(t),
            this
        }
        clearer(t) {
            let e = this._rgb;
            return e.a *= 1 - t,
            this
        }
        greyscale() {
            let t = this._rgb
              , e = vo(t.r * .3 + t.g * .59 + t.b * .11);
            return t.r = t.g = t.b = e,
            this
        }
        opaquer(t) {
            let e = this._rgb;
            return e.a *= 1 + t,
            this
        }
        negate() {
            let t = this._rgb;
            return t.r = 255 - t.r,
            t.g = 255 - t.g,
            t.b = 255 - t.b,
            this
        }
        lighten(t) {
            return Ia(this._rgb, 2, t),
            this
        }
        darken(t) {
            return Ia(this._rgb, 2, -t),
            this
        }
        saturate(t) {
            return Ia(this._rgb, 1, t),
            this
        }
        desaturate(t) {
            return Ia(this._rgb, 1, -t),
            this
        }
        rotate(t) {
            return Py(this._rgb, t),
            this
        }
    }
    ;
    function Rp(n) {
        return new Sh(n)
    }
    o(Rp, "index_esm");
    function Ip(n) {
        if (n && typeof n == "object") {
            let t = n.toString();
            return t === "[object CanvasPattern]" || t === "[object CanvasGradient]"
        }
        return !1
    }
    o(Ip, "isPatternOrGradient");
    function Bh(n) {
        return Ip(n) ? n : Rp(n)
    }
    o(Bh, "color");
    function bh(n) {
        return Ip(n) ? n : Rp(n).saturate(.5).darken(.1).hexString()
    }
    o(bh, "getHoverColor");
    var Vn = Object.create(null)
      , za = Object.create(null);
    function po(n, t) {
        if (!t)
            return n;
        let e = t.split(".");
        for (let s = 0, r = e.length; s < r; ++s) {
            let a = e[s];
            n = n[a] || (n[a] = Object.create(null))
        }
        return n
    }
    o(po, "getScope$1");
    function yh(n, t, e) {
        return typeof t == "string" ? er(po(n, t), e) : er(po(n, ""), t)
    }
    o(yh, "set");
    var Th = class {
        static{o(this, "Defaults")
        }constructor(t) {
            this.animation = void 0,
            this.backgroundColor = "rgba(0,0,0,0.1)",
            this.borderColor = "rgba(0,0,0,0.1)",
            this.color = "#666",
            this.datasets = {},
            this.devicePixelRatio = e => e.chart.platform.getDevicePixelRatio(),
            this.elements = {},
            this.events = ["mousemove", "mouseout", "click", "touchstart", "touchmove"],
            this.font = {
                family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
                size: 12,
                style: "normal",
                lineHeight: 1.2,
                weight: null
            },
            this.hover = {},
            this.hoverBackgroundColor = (e, s) => bh(s.backgroundColor),
            this.hoverBorderColor = (e, s) => bh(s.borderColor),
            this.hoverColor = (e, s) => bh(s.color),
            this.indexAxis = "x",
            this.interaction = {
                mode: "nearest",
                intersect: !0,
                includeInvisible: !1
            },
            this.maintainAspectRatio = !0,
            this.onHover = null,
            this.onClick = null,
            this.parsing = !0,
            this.plugins = {},
            this.responsive = !0,
            this.scale = void 0,
            this.scales = {},
            this.showLine = !0,
            this.drawActiveElementsOnTop = !0,
            this.describe(t)
        }
        set(t, e) {
            return yh(this, t, e)
        }
        get(t) {
            return po(this, t)
        }
        describe(t, e) {
            return yh(za, t, e)
        }
        override(t, e) {
            return yh(Vn, t, e)
        }
        route(t, e, s, r) {
            let a = po(this, t)
              , l = po(this, s)
              , u = "_" + e;
            Object.defineProperties(a, {
                [u]: {
                    value: a[e],
                    writable: !0
                },
                [e]: {
                    enumerable: !0,
                    get() {
                        let d = this[u]
                          , p = l[r];
                        return Ht(d) ? Object.assign({}, p, d) : It(d, p)
                    },
                    set(d) {
                        this[u] = d
                    }
                }
            })
        }
    }
      , jt = new Th({
        _scriptable: o(n => !n.startsWith("on"), "_scriptable"),
        _indexable: o(n => n !== "events", "_indexable"),
        hover: {
            _fallback: "interaction"
        },
        interaction: {
            _scriptable: !1,
            _indexable: !1
        }
    });
    function Wy(n) {
        return !n || zt(n.size) || zt(n.family) ? null : (n.style ? n.style + " " : "") + (n.weight ? n.weight + " " : "") + n.size + "px " + n.family
    }
    o(Wy, "toFontString");
    function go(n, t, e, s, r) {
        let a = t[r];
        return a || (a = t[r] = n.measureText(r).width,
        e.push(r)),
        a > s && (s = a),
        s
    }
    o(go, "_measureText");
    function Np(n, t, e, s) {
        s = s || {};
        let r = s.data = s.data || {}
          , a = s.garbageCollect = s.garbageCollect || [];
        s.font !== t && (r = s.data = {},
        a = s.garbageCollect = [],
        s.font = t),
        n.save(),
        n.font = t;
        let l = 0, u = e.length, d, p, b, E, x;
        for (d = 0; d < u; d++)
            if (E = e[d],
            E != null && ee(E) !== !0)
                l = go(n, r, a, l, E);
            else if (ee(E))
                for (p = 0,
                b = E.length; p < b; p++)
                    x = E[p],
                    x != null && !ee(x) && (l = go(n, r, a, l, x));
        n.restore();
        let w = a.length / 2;
        if (w > e.length) {
            for (d = 0; d < w; d++)
                delete r[a[d]];
            a.splice(0, w)
        }
        return l
    }
    o(Np, "_longestText");
    function Bn(n, t, e) {
        let s = n.currentDevicePixelRatio
          , r = e !== 0 ? Math.max(e / 2, .5) : 0;
        return Math.round((t - r) * s) / s + r
    }
    o(Bn, "_alignPixel");
    function Hh(n, t) {
        t = t || n.getContext("2d"),
        t.save(),
        t.resetTransform(),
        t.clearRect(0, 0, n.width, n.height),
        t.restore()
    }
    o(Hh, "clearCanvas");
    function Ua(n, t, e, s) {
        jh(n, t, e, s, null)
    }
    o(Ua, "drawPoint");
    function jh(n, t, e, s, r) {
        let a, l, u, d, p, b, E = t.pointStyle, x = t.rotation, w = t.radius, C = (x || 0) * by;
        if (E && typeof E == "object" && (a = E.toString(),
        a === "[object HTMLImageElement]" || a === "[object HTMLCanvasElement]")) {
            n.save(),
            n.translate(e, s),
            n.rotate(C),
            n.drawImage(E, -E.width / 2, -E.height / 2, E.width, E.height),
            n.restore();
            return
        }
        if (!(isNaN(w) || w <= 0)) {
            switch (n.beginPath(),
            E) {
            default:
                r ? n.ellipse(e, s, r / 2, w, 0, 0, te) : n.arc(e, s, w, 0, te),
                n.closePath();
                break;
            case "triangle":
                n.moveTo(e + Math.sin(C) * w, s - Math.cos(C) * w),
                C += rp,
                n.lineTo(e + Math.sin(C) * w, s - Math.cos(C) * w),
                C += rp,
                n.lineTo(e + Math.sin(C) * w, s - Math.cos(C) * w),
                n.closePath();
                break;
            case "rectRounded":
                p = w * .516,
                d = w - p,
                l = Math.cos(C + ho) * d,
                u = Math.sin(C + ho) * d,
                n.arc(e - l, s - u, p, C - ae, C - he),
                n.arc(e + u, s - l, p, C - he, C),
                n.arc(e + l, s + u, p, C, C + he),
                n.arc(e - u, s + l, p, C + he, C + ae),
                n.closePath();
                break;
            case "rect":
                if (!x) {
                    d = Math.SQRT1_2 * w,
                    b = r ? r / 2 : d,
                    n.rect(e - b, s - d, 2 * b, 2 * d);
                    break
                }
                C += ho;
            case "rectRot":
                l = Math.cos(C) * w,
                u = Math.sin(C) * w,
                n.moveTo(e - l, s - u),
                n.lineTo(e + u, s - l),
                n.lineTo(e + l, s + u),
                n.lineTo(e - u, s + l),
                n.closePath();
                break;
            case "crossRot":
                C += ho;
            case "cross":
                l = Math.cos(C) * w,
                u = Math.sin(C) * w,
                n.moveTo(e - l, s - u),
                n.lineTo(e + l, s + u),
                n.moveTo(e + u, s - l),
                n.lineTo(e - u, s + l);
                break;
            case "star":
                l = Math.cos(C) * w,
                u = Math.sin(C) * w,
                n.moveTo(e - l, s - u),
                n.lineTo(e + l, s + u),
                n.moveTo(e + u, s - l),
                n.lineTo(e - u, s + l),
                C += ho,
                l = Math.cos(C) * w,
                u = Math.sin(C) * w,
                n.moveTo(e - l, s - u),
                n.lineTo(e + l, s + u),
                n.moveTo(e + u, s - l),
                n.lineTo(e - u, s + l);
                break;
            case "line":
                l = r ? r / 2 : Math.cos(C) * w,
                u = Math.sin(C) * w,
                n.moveTo(e - l, s - u),
                n.lineTo(e + l, s + u);
                break;
            case "dash":
                n.moveTo(e, s),
                n.lineTo(e + Math.cos(C) * w, s + Math.sin(C) * w);
                break
            }
            n.fill(),
            t.borderWidth > 0 && n.stroke()
        }
    }
    o(jh, "drawPointLegend");
    function ir(n, t, e) {
        return e = e || .5,
        !t || n && n.x > t.left - e && n.x < t.right + e && n.y > t.top - e && n.y < t.bottom + e
    }
    o(ir, "_isPointInArea");
    function bo(n, t) {
        n.save(),
        n.beginPath(),
        n.rect(t.left, t.top, t.right - t.left, t.bottom - t.top),
        n.clip()
    }
    o(bo, "clipArea");
    function yo(n) {
        n.restore()
    }
    o(yo, "unclipArea");
    function Fp(n, t, e, s, r) {
        if (!t)
            return n.lineTo(e.x, e.y);
        if (r === "middle") {
            let a = (t.x + e.x) / 2;
            n.lineTo(a, t.y),
            n.lineTo(a, e.y)
        } else
            r === "after" != !!s ? n.lineTo(t.x, e.y) : n.lineTo(e.x, t.y);
        n.lineTo(e.x, e.y)
    }
    o(Fp, "_steppedLineTo");
    function Vp(n, t, e, s) {
        if (!t)
            return n.lineTo(e.x, e.y);
        n.bezierCurveTo(s ? t.cp1x : t.cp2x, s ? t.cp1y : t.cp2y, s ? e.cp2x : e.cp1x, s ? e.cp2y : e.cp1y, e.x, e.y)
    }
    o(Vp, "_bezierCurveTo");
    function Hn(n, t, e, s, r, a={}) {
        let l = ee(t) ? t : [t], u = a.strokeWidth > 0 && a.strokeColor !== "", d, p;
        for (n.save(),
        n.font = r.string,
        $y(n, a),
        d = 0; d < l.length; ++d)
            p = l[d],
            u && (a.strokeColor && (n.strokeStyle = a.strokeColor),
            zt(a.strokeWidth) || (n.lineWidth = a.strokeWidth),
            n.strokeText(p, e, s, a.maxWidth)),
            n.fillText(p, e, s, a.maxWidth),
            qy(n, e, s, p, a),
            s += r.lineHeight;
        n.restore()
    }
    o(Hn, "renderText");
    function $y(n, t) {
        t.translation && n.translate(t.translation[0], t.translation[1]),
        zt(t.rotation) || n.rotate(t.rotation),
        t.color && (n.fillStyle = t.color),
        t.textAlign && (n.textAlign = t.textAlign),
        t.textBaseline && (n.textBaseline = t.textBaseline)
    }
    o($y, "setRenderOpts");
    function qy(n, t, e, s, r) {
        if (r.strikethrough || r.underline) {
            let a = n.measureText(s)
              , l = t - a.actualBoundingBoxLeft
              , u = t + a.actualBoundingBoxRight
              , d = e - a.actualBoundingBoxAscent
              , p = e + a.actualBoundingBoxDescent
              , b = r.strikethrough ? (d + p) / 2 : p;
            n.strokeStyle = n.fillStyle,
            n.beginPath(),
            n.lineWidth = r.decorationWidth || 2,
            n.moveTo(l, b),
            n.lineTo(u, b),
            n.stroke()
        }
    }
    o(qy, "decorateText");
    function ar(n, t) {
        let {x: e, y: s, w: r, h: a, radius: l} = t;
        n.arc(e + l.topLeft, s + l.topLeft, l.topLeft, -he, ae, !0),
        n.lineTo(e, s + a - l.bottomLeft),
        n.arc(e + l.bottomLeft, s + a - l.bottomLeft, l.bottomLeft, ae, he, !0),
        n.lineTo(e + r - l.bottomRight, s + a),
        n.arc(e + r - l.bottomRight, s + a - l.bottomRight, l.bottomRight, he, 0, !0),
        n.lineTo(e + r, s + l.topRight),
        n.arc(e + r - l.topRight, s + l.topRight, l.topRight, 0, -he, !0),
        n.lineTo(e + l.topLeft, s)
    }
    o(ar, "addRoundedRectPath");
    var zy = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/)
      , Uy = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);
    function Ky(n, t) {
        let e = ("" + n).match(zy);
        if (!e || e[1] === "normal")
            return t * 1.2;
        switch (n = +e[2],
        e[3]) {
        case "px":
            return n;
        case "%":
            n /= 100;
            break
        }
        return t * n
    }
    o(Ky, "toLineHeight");
    var Yy = o(n => +n || 0, "numberOrZero");
    function Ka(n, t) {
        let e = {}
          , s = Ht(t)
          , r = s ? Object.keys(t) : t
          , a = Ht(n) ? s ? l => It(n[l], n[t[l]]) : l => n[l] : () => n;
        for (let l of r)
            e[l] = Yy(a(l));
        return e
    }
    o(Ka, "_readValueToProps");
    function Wh(n) {
        return Ka(n, {
            top: "y",
            right: "x",
            bottom: "y",
            left: "x"
        })
    }
    o(Wh, "toTRBL");
    function jn(n) {
        return Ka(n, ["topLeft", "topRight", "bottomLeft", "bottomRight"])
    }
    o(jn, "toTRBLCorners");
    function Me(n) {
        let t = Wh(n);
        return t.width = t.left + t.right,
        t.height = t.top + t.bottom,
        t
    }
    o(Me, "toPadding");
    function ge(n, t) {
        n = n || {},
        t = t || jt.font;
        let e = It(n.size, t.size);
        typeof e == "string" && (e = parseInt(e, 10));
        let s = It(n.style, t.style);
        s && !("" + s).match(Uy) && (console.warn('Invalid font style specified: "' + s + '"'),
        s = "");
        let r = {
            family: It(n.family, t.family),
            lineHeight: Ky(It(n.lineHeight, t.lineHeight), e),
            size: e,
            style: s,
            weight: It(n.weight, t.weight),
            string: ""
        };
        return r.string = Wy(r),
        r
    }
    o(ge, "toFont");
    function lr(n, t, e, s) {
        let r = !0, a, l, u;
        for (a = 0,
        l = n.length; a < l; ++a)
            if (u = n[a],
            u !== void 0 && (t !== void 0 && typeof u == "function" && (u = u(t),
            r = !1),
            e !== void 0 && ee(u) && (u = u[e % u.length],
            r = !1),
            u !== void 0))
                return s && !r && (s.cacheable = !1),
                u
    }
    o(lr, "resolve");
    function Bp(n, t, e) {
        let {min: s, max: r} = n
          , a = xh(t, (r - s) / 2)
          , l = o( (u, d) => e && u === 0 ? 0 : u + d, "keepZero");
        return {
            min: l(s, -Math.abs(a)),
            max: l(r, a)
        }
    }
    o(Bp, "_addGrace");
    function mn(n, t) {
        return Object.assign(Object.create(n), t)
    }
    o(mn, "createContext");
    function Ya(n, t=[""], e=n, s, r= () => n[0]) {
        si(s) || (s = Wp("_fallback", n));
        let a = {
            [Symbol.toStringTag]: "Object",
            _cacheable: !0,
            _scopes: n,
            _rootScopes: e,
            _fallback: s,
            _getTarget: r,
            override: o(l => Ya([l, ...n], t, e, s), "override")
        };
        return new Proxy(a,{
            deleteProperty(l, u) {
                return delete l[u],
                delete l._keys,
                delete n[0][u],
                !0
            },
            get(l, u) {
                return Hp(l, u, () => i_(u, t, n, l))
            },
            getOwnPropertyDescriptor(l, u) {
                return Reflect.getOwnPropertyDescriptor(l._scopes[0], u)
            },
            getPrototypeOf() {
                return Reflect.getPrototypeOf(n[0])
            },
            has(l, u) {
                return fp(l).includes(u)
            },
            ownKeys(l) {
                return fp(l)
            },
            set(l, u, d) {
                let p = l._storage || (l._storage = r());
                return l[u] = p[u] = d,
                delete l._keys,
                !0
            }
        })
    }
    o(Ya, "_createResolver");
    function gs(n, t, e, s) {
        let r = {
            _cacheable: !1,
            _proxy: n,
            _context: t,
            _subProxy: e,
            _stack: new Set,
            _descriptors: $h(n, s),
            setContext: o(a => gs(n, a, e, s), "setContext"),
            override: o(a => gs(n.override(a), t, e, s), "override")
        };
        return new Proxy(r,{
            deleteProperty(a, l) {
                return delete a[l],
                delete n[l],
                !0
            },
            get(a, l, u) {
                return Hp(a, l, () => Gy(a, l, u))
            },
            getOwnPropertyDescriptor(a, l) {
                return a._descriptors.allKeys ? Reflect.has(n, l) ? {
                    enumerable: !0,
                    configurable: !0
                } : void 0 : Reflect.getOwnPropertyDescriptor(n, l)
            },
            getPrototypeOf() {
                return Reflect.getPrototypeOf(n)
            },
            has(a, l) {
                return Reflect.has(n, l)
            },
            ownKeys() {
                return Reflect.ownKeys(n)
            },
            set(a, l, u) {
                return n[l] = u,
                delete a[l],
                !0
            }
        })
    }
    o(gs, "_attachContext");
    function $h(n, t={
        scriptable: !0,
        indexable: !0
    }) {
        let {_scriptable: e=t.scriptable, _indexable: s=t.indexable, _allKeys: r=t.allKeys} = n;
        return {
            allKeys: r,
            scriptable: e,
            indexable: s,
            isScriptable: pn(e) ? e : () => e,
            isIndexable: pn(s) ? s : () => s
        }
    }
    o($h, "_descriptors");
    var Xy = o( (n, t) => n ? n + ja(t) : t, "readKey")
      , qh = o( (n, t) => Ht(t) && n !== "adapters" && (Object.getPrototypeOf(t) === null || t.constructor === Object), "needsSubResolver");
    function Hp(n, t, e) {
        if (Object.prototype.hasOwnProperty.call(n, t))
            return n[t];
        let s = e();
        return n[t] = s,
        s
    }
    o(Hp, "_cached");
    function Gy(n, t, e) {
        let {_proxy: s, _context: r, _subProxy: a, _descriptors: l} = n
          , u = s[t];
        return pn(u) && l.isScriptable(t) && (u = Qy(t, u, n, e)),
        ee(u) && u.length && (u = Jy(t, u, n, l.isIndexable)),
        qh(t, u) && (u = gs(u, r, a && a[t], l)),
        u
    }
    o(Gy, "_resolveWithContext");
    function Qy(n, t, e, s) {
        let {_proxy: r, _context: a, _subProxy: l, _stack: u} = e;
        if (u.has(n))
            throw new Error("Recursion detected: " + Array.from(u).join("->") + "->" + n);
        return u.add(n),
        t = t(a, l || s),
        u.delete(n),
        qh(n, t) && (t = zh(r._scopes, r, n, t)),
        t
    }
    o(Qy, "_resolveScriptable");
    function Jy(n, t, e, s) {
        let {_proxy: r, _context: a, _subProxy: l, _descriptors: u} = e;
        if (si(a.index) && s(n))
            t = t[a.index % t.length];
        else if (Ht(t[0])) {
            let d = t
              , p = r._scopes.filter(b => b !== d);
            t = [];
            for (let b of d) {
                let E = zh(p, r, n, b);
                t.push(gs(E, a, l && l[n], u))
            }
        }
        return t
    }
    o(Jy, "_resolveArray");
    function jp(n, t, e) {
        return pn(n) ? n(t, e) : n
    }
    o(jp, "resolveFallback");
    var Zy = o( (n, t) => n === !0 ? t : typeof n == "string" ? gn(t, n) : void 0, "getScope");
    function t_(n, t, e, s, r) {
        for (let a of t) {
            let l = Zy(e, a);
            if (l) {
                n.add(l);
                let u = jp(l._fallback, e, r);
                if (si(u) && u !== e && u !== s)
                    return u
            } else if (l === !1 && si(s) && e !== s)
                return null
        }
        return !1
    }
    o(t_, "addScopes");
    function zh(n, t, e, s) {
        let r = t._rootScopes
          , a = jp(t._fallback, e, s)
          , l = [...n, ...r]
          , u = new Set;
        u.add(s);
        let d = dp(u, l, e, a || e, s);
        return d === null || si(a) && a !== e && (d = dp(u, l, a, d, s),
        d === null) ? !1 : Ya(Array.from(u), [""], r, a, () => e_(t, e, s))
    }
    o(zh, "createSubResolver");
    function dp(n, t, e, s, r) {
        for (; e; )
            e = t_(n, t, e, s, r);
        return e
    }
    o(dp, "addScopesFromKey");
    function e_(n, t, e) {
        let s = n._getTarget();
        t in s || (s[t] = {});
        let r = s[t];
        return ee(r) && Ht(e) ? e : r
    }
    o(e_, "subGetTarget");
    function i_(n, t, e, s) {
        let r;
        for (let a of t)
            if (r = Wp(Xy(a, n), e),
            si(r))
                return qh(n, r) ? zh(e, s, n, r) : r
    }
    o(i_, "_resolveWithPrefixes");
    function Wp(n, t) {
        for (let e of t) {
            if (!e)
                continue;
            let s = e[n];
            if (si(s))
                return s
        }
    }
    o(Wp, "_resolve");
    function fp(n) {
        let t = n._keys;
        return t || (t = n._keys = n_(n._scopes)),
        t
    }
    o(fp, "getKeysFromAllScopes");
    function n_(n) {
        let t = new Set;
        for (let e of n)
            for (let s of Object.keys(e).filter(r => !r.startsWith("_")))
                t.add(s);
        return Array.from(t)
    }
    o(n_, "resolveKeysFromAllScopes");
    function Uh(n, t, e, s) {
        let {iScale: r} = n, {key: a="r"} = this._parsing, l = new Array(s), u, d, p, b;
        for (u = 0,
        d = s; u < d; ++u)
            p = u + e,
            b = t[p],
            l[u] = {
                r: r.parse(gn(b, a), p)
            };
        return l
    }
    o(Uh, "_parseObjectDataRadialScale");
    var s_ = Number.EPSILON || 1e-14
      , nr = o( (n, t) => t < n.length && !n[t].skip && n[t], "getPoint")
      , $p = o(n => n === "x" ? "y" : "x", "getValueAxis");
    function r_(n, t, e, s) {
        let r = n.skip ? t : n
          , a = t
          , l = e.skip ? t : e
          , u = Ba(a, r)
          , d = Ba(l, a)
          , p = u / (u + d)
          , b = d / (u + d);
        p = isNaN(p) ? 0 : p,
        b = isNaN(b) ? 0 : b;
        let E = s * p
          , x = s * b;
        return {
            previous: {
                x: a.x - E * (l.x - r.x),
                y: a.y - E * (l.y - r.y)
            },
            next: {
                x: a.x + x * (l.x - r.x),
                y: a.y + x * (l.y - r.y)
            }
        }
    }
    o(r_, "splineCurve");
    function o_(n, t, e) {
        let s = n.length, r, a, l, u, d, p = nr(n, 0);
        for (let b = 0; b < s - 1; ++b)
            if (d = p,
            p = nr(n, b + 1),
            !(!d || !p)) {
                if (rr(t[b], 0, s_)) {
                    e[b] = e[b + 1] = 0;
                    continue
                }
                r = e[b] / t[b],
                a = e[b + 1] / t[b],
                u = Math.pow(r, 2) + Math.pow(a, 2),
                !(u <= 9) && (l = 3 / Math.sqrt(u),
                e[b] = r * l * t[b],
                e[b + 1] = a * l * t[b])
            }
    }
    o(o_, "monotoneAdjust");
    function a_(n, t, e="x") {
        let s = $p(e), r = n.length, a, l, u, d = nr(n, 0);
        for (let p = 0; p < r; ++p) {
            if (l = u,
            u = d,
            d = nr(n, p + 1),
            !u)
                continue;
            let b = u[e]
              , E = u[s];
            l && (a = (b - l[e]) / 3,
            u[`cp1${e}`] = b - a,
            u[`cp1${s}`] = E - a * t[p]),
            d && (a = (d[e] - b) / 3,
            u[`cp2${e}`] = b + a,
            u[`cp2${s}`] = E + a * t[p])
        }
    }
    o(a_, "monotoneCompute");
    function l_(n, t="x") {
        let e = $p(t), s = n.length, r = Array(s).fill(0), a = Array(s), l, u, d, p = nr(n, 0);
        for (l = 0; l < s; ++l)
            if (u = d,
            d = p,
            p = nr(n, l + 1),
            !!d) {
                if (p) {
                    let b = p[t] - d[t];
                    r[l] = b !== 0 ? (p[e] - d[e]) / b : 0
                }
                a[l] = u ? p ? Oi(r[l - 1]) !== Oi(r[l]) ? 0 : (r[l - 1] + r[l]) / 2 : r[l - 1] : r[l]
            }
        o_(n, r, a),
        a_(n, a, t)
    }
    o(l_, "splineCurveMonotone");
    function Na(n, t, e) {
        return Math.max(Math.min(n, e), t)
    }
    o(Na, "capControlPoint");
    function c_(n, t) {
        let e, s, r, a, l, u = ir(n[0], t);
        for (e = 0,
        s = n.length; e < s; ++e)
            l = a,
            a = u,
            u = e < s - 1 && ir(n[e + 1], t),
            a && (r = n[e],
            l && (r.cp1x = Na(r.cp1x, t.left, t.right),
            r.cp1y = Na(r.cp1y, t.top, t.bottom)),
            u && (r.cp2x = Na(r.cp2x, t.left, t.right),
            r.cp2y = Na(r.cp2y, t.top, t.bottom)))
    }
    o(c_, "capBezierPoints");
    function qp(n, t, e, s, r) {
        let a, l, u, d;
        if (t.spanGaps && (n = n.filter(p => !p.skip)),
        t.cubicInterpolationMode === "monotone")
            l_(n, r);
        else {
            let p = s ? n[n.length - 1] : n[0];
            for (a = 0,
            l = n.length; a < l; ++a)
                u = n[a],
                d = r_(p, u, n[Math.min(a + 1, l - (s ? 0 : 1)) % l], t.tension),
                u.cp1x = d.previous.x,
                u.cp1y = d.previous.y,
                u.cp2x = d.next.x,
                u.cp2y = d.next.y,
                p = u
        }
        t.capBezierPoints && c_(n, e)
    }
    o(qp, "_updateBezierControlPoints");
    function Kh() {
        return typeof window < "u" && typeof document < "u"
    }
    o(Kh, "_isDomSupported");
    function Xa(n) {
        let t = n.parentNode;
        return t && t.toString() === "[object ShadowRoot]" && (t = t.host),
        t
    }
    o(Xa, "_getParentNode");
    function Ha(n, t, e) {
        let s;
        return typeof n == "string" ? (s = parseInt(n, 10),
        n.indexOf("%") !== -1 && (s = s / 100 * t.parentNode[e])) : s = n,
        s
    }
    o(Ha, "parseMaxStyle");
    var Ga = o(n => window.getComputedStyle(n, null), "getComputedStyle");
    function u_(n, t) {
        return Ga(n).getPropertyValue(t)
    }
    o(u_, "getStyle");
    var h_ = ["top", "right", "bottom", "left"];
    function ps(n, t, e) {
        let s = {};
        e = e ? "-" + e : "";
        for (let r = 0; r < 4; r++) {
            let a = h_[r];
            s[a] = parseFloat(n[t + "-" + a + e]) || 0
        }
        return s.width = s.left + s.right,
        s.height = s.top + s.bottom,
        s
    }
    o(ps, "getPositionedStyle");
    var d_ = o( (n, t, e) => (n > 0 || t > 0) && (!e || !e.shadowRoot), "useOffsetPos");
    function f_(n, t) {
        let e = n.touches, s = e && e.length ? e[0] : n, {offsetX: r, offsetY: a} = s, l = !1, u, d;
        if (d_(r, a, n.target))
            u = r,
            d = a;
        else {
            let p = t.getBoundingClientRect();
            u = s.clientX - p.left,
            d = s.clientY - p.top,
            l = !0
        }
        return {
            x: u,
            y: d,
            box: l
        }
    }
    o(f_, "getCanvasPosition");
    function Wn(n, t) {
        if ("native"in n)
            return n;
        let {canvas: e, currentDevicePixelRatio: s} = t
          , r = Ga(e)
          , a = r.boxSizing === "border-box"
          , l = ps(r, "padding")
          , u = ps(r, "border", "width")
          , {x: d, y: p, box: b} = f_(n, e)
          , E = l.left + (b && u.left)
          , x = l.top + (b && u.top)
          , {width: w, height: C} = t;
        return a && (w -= l.width + u.width,
        C -= l.height + u.height),
        {
            x: Math.round((d - E) / w * e.width / s),
            y: Math.round((p - x) / C * e.height / s)
        }
    }
    o(Wn, "getRelativePosition");
    function p_(n, t, e) {
        let s, r;
        if (t === void 0 || e === void 0) {
            let a = Xa(n);
            if (!a)
                t = n.clientWidth,
                e = n.clientHeight;
            else {
                let l = a.getBoundingClientRect()
                  , u = Ga(a)
                  , d = ps(u, "border", "width")
                  , p = ps(u, "padding");
                t = l.width - p.width - d.width,
                e = l.height - p.height - d.height,
                s = Ha(u.maxWidth, a, "clientWidth"),
                r = Ha(u.maxHeight, a, "clientHeight")
            }
        }
        return {
            width: t,
            height: e,
            maxWidth: s || Va,
            maxHeight: r || Va
        }
    }
    o(p_, "getContainerSize");
    var _h = o(n => Math.round(n * 10) / 10, "round1");
    function zp(n, t, e, s) {
        let r = Ga(n)
          , a = ps(r, "margin")
          , l = Ha(r.maxWidth, n, "clientWidth") || Va
          , u = Ha(r.maxHeight, n, "clientHeight") || Va
          , d = p_(n, t, e)
          , {width: p, height: b} = d;
        if (r.boxSizing === "content-box") {
            let E = ps(r, "border", "width")
              , x = ps(r, "padding");
            p -= x.width + E.width,
            b -= x.height + E.height
        }
        return p = Math.max(0, p - a.width),
        b = Math.max(0, s ? Math.floor(p / s) : b - a.height),
        p = _h(Math.min(p, l, d.maxWidth)),
        b = _h(Math.min(b, u, d.maxHeight)),
        p && !b && (b = _h(p / 2)),
        {
            width: p,
            height: b
        }
    }
    o(zp, "getMaximumSize");
    function Yh(n, t, e) {
        let s = t || 1
          , r = Math.floor(n.height * s)
          , a = Math.floor(n.width * s);
        n.height = r / s,
        n.width = a / s;
        let l = n.canvas;
        return l.style && (e || !l.style.height && !l.style.width) && (l.style.height = `${n.height}px`,
        l.style.width = `${n.width}px`),
        n.currentDevicePixelRatio !== s || l.height !== r || l.width !== a ? (n.currentDevicePixelRatio = s,
        l.height = r,
        l.width = a,
        n.ctx.setTransform(s, 0, 0, s, 0, 0),
        !0) : !1
    }
    o(Yh, "retinaScale");
    var Up = (function() {
        let n = !1;
        try {
            let t = {
                get passive() {
                    return n = !0,
                    !1
                }
            };
            window.addEventListener("test", null, t),
            window.removeEventListener("test", null, t)
        } catch {}
        return n
    }
    )();
    function Xh(n, t) {
        let e = u_(n, t)
          , s = e && e.match(/^(\d+)(\.\d+)?px$/);
        return s ? +s[1] : void 0
    }
    o(Xh, "readUsedSize");
    function In(n, t, e, s) {
        return {
            x: n.x + e * (t.x - n.x),
            y: n.y + e * (t.y - n.y)
        }
    }
    o(In, "_pointInLine");
    function Kp(n, t, e, s) {
        return {
            x: n.x + e * (t.x - n.x),
            y: s === "middle" ? e < .5 ? n.y : t.y : s === "after" ? e < 1 ? n.y : t.y : e > 0 ? t.y : n.y
        }
    }
    o(Kp, "_steppedInterpolation");
    function Yp(n, t, e, s) {
        let r = {
            x: n.cp2x,
            y: n.cp2y
        }
          , a = {
            x: t.cp1x,
            y: t.cp1y
        }
          , l = In(n, r, e)
          , u = In(r, a, e)
          , d = In(a, t, e)
          , p = In(l, u, e)
          , b = In(u, d, e);
        return In(p, b, e)
    }
    o(Yp, "_bezierInterpolation");
    var pp = new Map;
    function g_(n, t) {
        t = t || {};
        let e = n + JSON.stringify(t)
          , s = pp.get(e);
        return s || (s = new Intl.NumberFormat(n,t),
        pp.set(e, s)),
        s
    }
    o(g_, "getNumberFormat");
    function cr(n, t, e) {
        return g_(t, e).format(n)
    }
    o(cr, "formatNumber");
    var m_ = o(function(n, t) {
        return {
            x(e) {
                return n + n + t - e
            },
            setWidth(e) {
                t = e
            },
            textAlign(e) {
                return e === "center" ? e : e === "right" ? "left" : "right"
            },
            xPlus(e, s) {
                return e - s
            },
            leftForLtr(e, s) {
                return e - s
            }
        }
    }, "getRightToLeftAdapter")
      , v_ = o(function() {
        return {
            x(n) {
                return n
            },
            setWidth(n) {},
            textAlign(n) {
                return n
            },
            xPlus(n, t) {
                return n + t
            },
            leftForLtr(n, t) {
                return n
            }
        }
    }, "getLeftToRightAdapter");
    function vs(n, t, e) {
        return n ? m_(t, e) : v_()
    }
    o(vs, "getRtlAdapter");
    function Gh(n, t) {
        let e, s;
        (t === "ltr" || t === "rtl") && (e = n.canvas.style,
        s = [e.getPropertyValue("direction"), e.getPropertyPriority("direction")],
        e.setProperty("direction", t, "important"),
        n.prevTextDirection = s)
    }
    o(Gh, "overrideTextDirection");
    function Qh(n, t) {
        t !== void 0 && (delete n.prevTextDirection,
        n.canvas.style.setProperty("direction", t[0], t[1]))
    }
    o(Qh, "restoreTextDirection");
    function Xp(n) {
        return n === "angle" ? {
            between: or,
            compare: yy,
            normalize: ze
        } : {
            between: Ki,
            compare: o( (t, e) => t - e, "compare"),
            normalize: o(t => t, "normalize")
        }
    }
    o(Xp, "propertyFn");
    function gp({start: n, end: t, count: e, loop: s, style: r}) {
        return {
            start: n % e,
            end: t % e,
            loop: s && (t - n + 1) % e === 0,
            style: r
        }
    }
    o(gp, "normalizeSegment");
    function b_(n, t, e) {
        let {property: s, start: r, end: a} = e, {between: l, normalize: u} = Xp(s), d = t.length, {start: p, end: b, loop: E} = n, x, w;
        if (E) {
            for (p += d,
            b += d,
            x = 0,
            w = d; x < w && l(u(t[p % d][s]), r, a); ++x)
                p--,
                b--;
            p %= d,
            b %= d
        }
        return b < p && (b += d),
        {
            start: p,
            end: b,
            loop: E,
            style: n.style
        }
    }
    o(b_, "getSegment");
    function Jh(n, t, e) {
        if (!e)
            return [n];
        let {property: s, start: r, end: a} = e, l = t.length, {compare: u, between: d, normalize: p} = Xp(s), {start: b, end: E, loop: x, style: w} = b_(n, t, e), C = [], I = !1, L = null, k, F, z, j = o( () => d(r, z, k) && u(r, z) !== 0, "startIsBefore"), H = o( () => u(a, k) === 0 || d(a, z, k), "endIsBefore"), f = o( () => I || j(), "shouldStart"), Y = o( () => !I || H(), "shouldStop");
        for (let Q = b, ot = b; Q <= E; ++Q)
            F = t[Q % l],
            !F.skip && (k = p(F[s]),
            k !== z && (I = d(k, r, a),
            L === null && f() && (L = u(k, r) === 0 ? Q : ot),
            L !== null && Y() && (C.push(gp({
                start: L,
                end: Q,
                loop: x,
                count: l,
                style: w
            })),
            L = null),
            ot = Q,
            z = k));
        return L !== null && C.push(gp({
            start: L,
            end: E,
            loop: x,
            count: l,
            style: w
        })),
        C
    }
    o(Jh, "_boundSegment");
    function Zh(n, t) {
        let e = []
          , s = n.segments;
        for (let r = 0; r < s.length; r++) {
            let a = Jh(s[r], n.points, t);
            a.length && e.push(...a)
        }
        return e
    }
    o(Zh, "_boundSegments");
    function y_(n, t, e, s) {
        let r = 0
          , a = t - 1;
        if (e && !s)
            for (; r < t && !n[r].skip; )
                r++;
        for (; r < t && n[r].skip; )
            r++;
        for (r %= t,
        e && (a += r); a > r && n[a % t].skip; )
            a--;
        return a %= t,
        {
            start: r,
            end: a
        }
    }
    o(y_, "findStartAndEnd");
    function __(n, t, e, s) {
        let r = n.length, a = [], l = t, u = n[t], d;
        for (d = t + 1; d <= e; ++d) {
            let p = n[d % r];
            p.skip || p.stop ? u.skip || (s = !1,
            a.push({
                start: t % r,
                end: (d - 1) % r,
                loop: s
            }),
            t = l = p.stop ? d : null) : (l = d,
            u.skip && (t = d)),
            u = p
        }
        return l !== null && a.push({
            start: t % r,
            end: l % r,
            loop: s
        }),
        a
    }
    o(__, "solidSegments");
    function Gp(n, t) {
        let e = n.points
          , s = n.options.spanGaps
          , r = e.length;
        if (!r)
            return [];
        let a = !!n._loop
          , {start: l, end: u} = y_(e, r, a, s);
        if (s === !0)
            return mp(n, [{
                start: l,
                end: u,
                loop: a
            }], e, t);
        let d = u < l ? u + r : u
          , p = !!n._fullLoop && l === 0 && u === r - 1;
        return mp(n, __(e, l, d, p), e, t)
    }
    o(Gp, "_computeSegments");
    function mp(n, t, e, s) {
        return !s || !s.setContext || !e ? t : E_(n, t, e, s)
    }
    o(mp, "splitByStyles");
    function E_(n, t, e, s) {
        let r = n._chart.getContext()
          , a = vp(n.options)
          , {_datasetIndex: l, options: {spanGaps: u}} = n
          , d = e.length
          , p = []
          , b = a
          , E = t[0].start
          , x = E;
        function w(C, I, L, k) {
            let F = u ? -1 : 1;
            if (C !== I) {
                for (C += d; e[C % d].skip; )
                    C -= F;
                for (; e[I % d].skip; )
                    I += F;
                C % d !== I % d && (p.push({
                    start: C % d,
                    end: I % d,
                    loop: L,
                    style: k
                }),
                b = k,
                E = I % d)
            }
        }
        o(w, "addStyle");
        for (let C of t) {
            E = u ? E : C.start;
            let I = e[E % d], L;
            for (x = E + 1; x <= C.end; x++) {
                let k = e[x % d];
                L = vp(s.setContext(mn(r, {
                    type: "segment",
                    p0: I,
                    p1: k,
                    p0DataIndex: (x - 1) % d,
                    p1DataIndex: x % d,
                    datasetIndex: l
                }))),
                S_(L, b) && w(E, x - 1, C.loop, b),
                I = k,
                b = L
            }
            E < x - 1 && w(E, x - 1, C.loop, b)
        }
        return p
    }
    o(E_, "doSplitByStyles");
    function vp(n) {
        return {
            backgroundColor: n.backgroundColor,
            borderCapStyle: n.borderCapStyle,
            borderDash: n.borderDash,
            borderDashOffset: n.borderDashOffset,
            borderJoinStyle: n.borderJoinStyle,
            borderWidth: n.borderWidth,
            borderColor: n.borderColor
        }
    }
    o(vp, "readStyle");
    function S_(n, t) {
        return t && JSON.stringify(n) !== JSON.stringify(t)
    }
    o(S_, "styleChanged");
    var cd = class {
        static{o(this, "Animator")
        }constructor() {
            this._request = null,
            this._charts = new Map,
            this._running = !1,
            this._lastDate = void 0
        }
        _notify(t, e, s, r) {
            let a = e.listeners[r]
              , l = e.duration;
            a.forEach(u => u({
                chart: t,
                initial: e.initial,
                numSteps: l,
                currentStep: Math.min(s - e.start, l)
            }))
        }
        _refresh() {
            this._request || (this._running = !0,
            this._request = Dh.call(window, () => {
                this._update(),
                this._request = null,
                this._running && this._refresh()
            }
            ))
        }
        _update(t=Date.now()) {
            let e = 0;
            this._charts.forEach( (s, r) => {
                if (!s.running || !s.items.length)
                    return;
                let a = s.items, l = a.length - 1, u = !1, d;
                for (; l >= 0; --l)
                    d = a[l],
                    d._active ? (d._total > s.duration && (s.duration = d._total),
                    d.tick(t),
                    u = !0) : (a[l] = a[a.length - 1],
                    a.pop());
                u && (r.draw(),
                this._notify(r, s, t, "progress")),
                a.length || (s.running = !1,
                this._notify(r, s, t, "complete"),
                s.initial = !1),
                e += a.length
            }
            ),
            this._lastDate = t,
            e === 0 && (this._running = !1)
        }
        _getAnims(t) {
            let e = this._charts
              , s = e.get(t);
            return s || (s = {
                running: !1,
                initial: !0,
                items: [],
                listeners: {
                    complete: [],
                    progress: []
                }
            },
            e.set(t, s)),
            s
        }
        listen(t, e, s) {
            this._getAnims(t).listeners[e].push(s)
        }
        add(t, e) {
            !e || !e.length || this._getAnims(t).items.push(...e)
        }
        has(t) {
            return this._getAnims(t).items.length > 0
        }
        start(t) {
            let e = this._charts.get(t);
            e && (e.running = !0,
            e.start = Date.now(),
            e.duration = e.items.reduce( (s, r) => Math.max(s, r._duration), 0),
            this._refresh())
        }
        running(t) {
            if (!this._running)
                return !1;
            let e = this._charts.get(t);
            return !(!e || !e.running || !e.items.length)
        }
        stop(t) {
            let e = this._charts.get(t);
            if (!e || !e.items.length)
                return;
            let s = e.items
              , r = s.length - 1;
            for (; r >= 0; --r)
                s[r].cancel();
            e.items = [],
            this._notify(t, e, Date.now(), "complete")
        }
        remove(t) {
            return this._charts.delete(t)
        }
    }
      , vn = new cd
      , Qp = "transparent"
      , T_ = {
        boolean(n, t, e) {
            return e > .5 ? t : n
        },
        color(n, t, e) {
            let s = Bh(n || Qp)
              , r = s.valid && Bh(t || Qp);
            return r && r.valid ? r.mix(s, e).hexString() : t
        },
        number(n, t, e) {
            return n + (t - n) * e
        }
    }
      , ud = class {
        static{o(this, "Animation")
        }constructor(t, e, s, r) {
            let a = e[s];
            r = lr([t.to, r, a, t.from]);
            let l = lr([t.from, a, r]);
            this._active = !0,
            this._fn = t.fn || T_[t.type || typeof l],
            this._easing = tr[t.easing] || tr.linear,
            this._start = Math.floor(Date.now() + (t.delay || 0)),
            this._duration = this._total = Math.floor(t.duration),
            this._loop = !!t.loop,
            this._target = e,
            this._prop = s,
            this._from = l,
            this._to = r,
            this._promises = void 0
        }
        active() {
            return this._active
        }
        update(t, e, s) {
            if (this._active) {
                this._notify(!1);
                let r = this._target[this._prop]
                  , a = s - this._start
                  , l = this._duration - a;
                this._start = s,
                this._duration = Math.floor(Math.max(l, t.duration)),
                this._total += a,
                this._loop = !!t.loop,
                this._to = lr([t.to, e, r, t.from]),
                this._from = lr([t.from, r, e])
            }
        }
        cancel() {
            this._active && (this.tick(Date.now()),
            this._active = !1,
            this._notify(!1))
        }
        tick(t) {
            let e = t - this._start, s = this._duration, r = this._prop, a = this._from, l = this._loop, u = this._to, d;
            if (this._active = a !== u && (l || e < s),
            !this._active) {
                this._target[r] = u,
                this._notify(!0);
                return
            }
            if (e < 0) {
                this._target[r] = a;
                return
            }
            d = e / s % 2,
            d = l && d > 1 ? 2 - d : d,
            d = this._easing(Math.min(1, Math.max(0, d))),
            this._target[r] = this._fn(a, u, d)
        }
        wait() {
            let t = this._promises || (this._promises = []);
            return new Promise( (e, s) => {
                t.push({
                    res: e,
                    rej: s
                })
            }
            )
        }
        _notify(t) {
            let e = t ? "res" : "rej"
              , s = this._promises || [];
            for (let r = 0; r < s.length; r++)
                s[r][e]()
        }
    }
      , x_ = ["x", "y", "borderWidth", "radius", "tension"]
      , w_ = ["color", "borderColor", "backgroundColor"];
    jt.set("animation", {
        delay: void 0,
        duration: 1e3,
        easing: "easeOutQuart",
        fn: void 0,
        from: void 0,
        loop: void 0,
        to: void 0,
        type: void 0
    });
    var C_ = Object.keys(jt.animation);
    jt.describe("animation", {
        _fallback: !1,
        _indexable: !1,
        _scriptable: o(n => n !== "onProgress" && n !== "onComplete" && n !== "fn", "_scriptable")
    });
    jt.set("animations", {
        colors: {
            type: "color",
            properties: w_
        },
        numbers: {
            type: "number",
            properties: x_
        }
    });
    jt.describe("animations", {
        _fallback: "animation"
    });
    jt.set("transitions", {
        active: {
            animation: {
                duration: 400
            }
        },
        resize: {
            animation: {
                duration: 0
            }
        },
        show: {
            animations: {
                colors: {
                    from: "transparent"
                },
                visible: {
                    type: "boolean",
                    duration: 0
                }
            }
        },
        hide: {
            animations: {
                colors: {
                    to: "transparent"
                },
                visible: {
                    type: "boolean",
                    easing: "linear",
                    fn: o(n => n | 0, "fn")
                }
            }
        }
    });
    var sl = class {
        static{o(this, "Animations")
        }constructor(t, e) {
            this._chart = t,
            this._properties = new Map,
            this.configure(e)
        }
        configure(t) {
            if (!Ht(t))
                return;
            let e = this._properties;
            Object.getOwnPropertyNames(t).forEach(s => {
                let r = t[s];
                if (!Ht(r))
                    return;
                let a = {};
                for (let l of C_)
                    a[l] = r[l];
                (ee(r.properties) && r.properties || [s]).forEach(l => {
                    (l === s || !e.has(l)) && e.set(l, a)
                }
                )
            }
            )
        }
        _animateOptions(t, e) {
            let s = e.options
              , r = k_(t, s);
            if (!r)
                return [];
            let a = this._createAnimations(r, s);
            return s.$shared && A_(t.options.$animations, s).then( () => {
                t.options = s
            }
            , () => {}
            ),
            a
        }
        _createAnimations(t, e) {
            let s = this._properties, r = [], a = t.$animations || (t.$animations = {}), l = Object.keys(e), u = Date.now(), d;
            for (d = l.length - 1; d >= 0; --d) {
                let p = l[d];
                if (p.charAt(0) === "$")
                    continue;
                if (p === "options") {
                    r.push(...this._animateOptions(t, e));
                    continue
                }
                let b = e[p]
                  , E = a[p]
                  , x = s.get(p);
                if (E)
                    if (x && E.active()) {
                        E.update(x, b, u);
                        continue
                    } else
                        E.cancel();
                if (!x || !x.duration) {
                    t[p] = b;
                    continue
                }
                a[p] = E = new ud(x,t,p,b),
                r.push(E)
            }
            return r
        }
        update(t, e) {
            if (this._properties.size === 0) {
                Object.assign(t, e);
                return
            }
            let s = this._createAnimations(t, e);
            if (s.length)
                return vn.add(this._chart, s),
                !0
        }
    }
    ;
    function A_(n, t) {
        let e = []
          , s = Object.keys(t);
        for (let r = 0; r < s.length; r++) {
            let a = n[s[r]];
            a && a.active() && e.push(a.wait())
        }
        return Promise.all(e)
    }
    o(A_, "awaitAll");
    function k_(n, t) {
        if (!t)
            return;
        let e = n.options;
        if (!e) {
            n.options = t;
            return
        }
        return e.$shared && (n.options = e = Object.assign({}, e, {
            $shared: !1,
            $animations: {}
        })),
        e
    }
    o(k_, "resolveTargetOptions");
    function Jp(n, t) {
        let e = n && n.options || {}
          , s = e.reverse
          , r = e.min === void 0 ? t : 0
          , a = e.max === void 0 ? t : 0;
        return {
            start: s ? a : r,
            end: s ? r : a
        }
    }
    o(Jp, "scaleClip");
    function M_(n, t, e) {
        if (e === !1)
            return !1;
        let s = Jp(n, e)
          , r = Jp(t, e);
        return {
            top: r.end,
            right: s.end,
            bottom: r.start,
            left: s.start
        }
    }
    o(M_, "defaultClip");
    function O_(n) {
        let t, e, s, r;
        return Ht(n) ? (t = n.top,
        e = n.right,
        s = n.bottom,
        r = n.left) : t = e = s = r = n,
        {
            top: t,
            right: e,
            bottom: s,
            left: r,
            disabled: n === !1
        }
    }
    o(O_, "toClip");
    function Wg(n, t) {
        let e = [], s = n._getSortedDatasetMetas(t), r, a;
        for (r = 0,
        a = s.length; r < a; ++r)
            e.push(s[r].index);
        return e
    }
    o(Wg, "getSortedDatasetIndices");
    function Zp(n, t, e, s={}) {
        let r = n.keys, a = s.mode === "single", l, u, d, p;
        if (t !== null) {
            for (l = 0,
            u = r.length; l < u; ++l) {
                if (d = +r[l],
                d === e) {
                    if (s.all)
                        continue;
                    break
                }
                p = n.values[d],
                fe(p) && (a || t === 0 || Oi(t) === Oi(p)) && (t += p)
            }
            return t
        }
    }
    o(Zp, "applyStack");
    function L_(n) {
        let t = Object.keys(n), e = new Array(t.length), s, r, a;
        for (s = 0,
        r = t.length; s < r; ++s)
            a = t[s],
            e[s] = {
                x: a,
                y: n[a]
            };
        return e
    }
    o(L_, "convertObjectDataToArray");
    function tg(n, t) {
        let e = n && n.options.stacked;
        return e || e === void 0 && t.stack !== void 0
    }
    o(tg, "isStacked");
    function D_(n, t, e) {
        return `${n.id}.${t.id}.${e.stack || e.type}`
    }
    o(D_, "getStackKey");
    function P_(n) {
        let {min: t, max: e, minDefined: s, maxDefined: r} = n.getUserBounds();
        return {
            min: s ? t : Number.NEGATIVE_INFINITY,
            max: r ? e : Number.POSITIVE_INFINITY
        }
    }
    o(P_, "getUserBounds");
    function R_(n, t, e) {
        let s = n[t] || (n[t] = {});
        return s[e] || (s[e] = {})
    }
    o(R_, "getOrCreateStack");
    function eg(n, t, e, s) {
        for (let r of t.getMatchingVisibleMetas(s).reverse()) {
            let a = n[r.index];
            if (e && a > 0 || !e && a < 0)
                return r.index
        }
        return null
    }
    o(eg, "getLastIndexInStack");
    function ig(n, t) {
        let {chart: e, _cachedMeta: s} = n, r = e._stacks || (e._stacks = {}), {iScale: a, vScale: l, index: u} = s, d = a.axis, p = l.axis, b = D_(a, l, s), E = t.length, x;
        for (let w = 0; w < E; ++w) {
            let C = t[w]
              , {[d]: I, [p]: L} = C
              , k = C._stacks || (C._stacks = {});
            x = k[p] = R_(r, b, I),
            x[u] = L,
            x._top = eg(x, l, !0, s.type),
            x._bottom = eg(x, l, !1, s.type)
        }
    }
    o(ig, "updateStacks");
    function td(n, t) {
        let e = n.scales;
        return Object.keys(e).filter(s => e[s].axis === t).shift()
    }
    o(td, "getFirstScaleId");
    function I_(n, t) {
        return mn(n, {
            active: !1,
            dataset: void 0,
            datasetIndex: t,
            index: t,
            mode: "default",
            type: "dataset"
        })
    }
    o(I_, "createDatasetContext");
    function N_(n, t, e) {
        return mn(n, {
            active: !1,
            dataIndex: t,
            parsed: void 0,
            raw: void 0,
            element: e,
            index: t,
            mode: "default",
            type: "data"
        })
    }
    o(N_, "createDataContext");
    function _o(n, t) {
        let e = n.controller.index
          , s = n.vScale && n.vScale.axis;
        if (s) {
            t = t || n._parsed;
            for (let r of t) {
                let a = r._stacks;
                if (!a || a[s] === void 0 || a[s][e] === void 0)
                    return;
                delete a[s][e]
            }
        }
    }
    o(_o, "clearStacks");
    var ed = o(n => n === "reset" || n === "none", "isDirectUpdateMode")
      , ng = o( (n, t) => t ? n : Object.assign({}, n), "cloneIfNotShared")
      , F_ = o( (n, t, e) => n && !t.hidden && t._stacked && {
        keys: Wg(e, !0),
        values: null
    }, "createStack")
      , ai = class {
        static{o(this, "DatasetController")
        }constructor(t, e) {
            this.chart = t,
            this._ctx = t.ctx,
            this.index = e,
            this._cachedDataOpts = {},
            this._cachedMeta = this.getMeta(),
            this._type = this._cachedMeta.type,
            this.options = void 0,
            this._parsing = !1,
            this._data = void 0,
            this._objectData = void 0,
            this._sharedOptions = void 0,
            this._drawStart = void 0,
            this._drawCount = void 0,
            this.enableOptionSharing = !1,
            this.supportsDecimation = !1,
            this.$context = void 0,
            this._syncList = [],
            this.initialize()
        }
        initialize() {
            let t = this._cachedMeta;
            this.configure(),
            this.linkScales(),
            t._stacked = tg(t.vScale, t),
            this.addElements()
        }
        updateIndex(t) {
            this.index !== t && _o(this._cachedMeta),
            this.index = t
        }
        linkScales() {
            let t = this.chart
              , e = this._cachedMeta
              , s = this.getDataset()
              , r = o( (E, x, w, C) => E === "x" ? x : E === "r" ? C : w, "chooseId")
              , a = e.xAxisID = It(s.xAxisID, td(t, "x"))
              , l = e.yAxisID = It(s.yAxisID, td(t, "y"))
              , u = e.rAxisID = It(s.rAxisID, td(t, "r"))
              , d = e.indexAxis
              , p = e.iAxisID = r(d, a, l, u)
              , b = e.vAxisID = r(d, l, a, u);
            e.xScale = this.getScaleForId(a),
            e.yScale = this.getScaleForId(l),
            e.rScale = this.getScaleForId(u),
            e.iScale = this.getScaleForId(p),
            e.vScale = this.getScaleForId(b)
        }
        getDataset() {
            return this.chart.data.datasets[this.index]
        }
        getMeta() {
            return this.chart.getDatasetMeta(this.index)
        }
        getScaleForId(t) {
            return this.chart.scales[t]
        }
        _getOtherScale(t) {
            let e = this._cachedMeta;
            return t === e.iScale ? e.vScale : e.iScale
        }
        reset() {
            this._update("reset")
        }
        _destroy() {
            let t = this._cachedMeta;
            this._data && Oh(this._data, this),
            t._stacked && _o(t)
        }
        _dataCheck() {
            let t = this.getDataset()
              , e = t.data || (t.data = [])
              , s = this._data;
            if (Ht(e))
                this._data = L_(e);
            else if (s !== e) {
                if (s) {
                    Oh(s, this);
                    let r = this._cachedMeta;
                    _o(r),
                    r._parsed = []
                }
                e && Object.isExtensible(e) && kp(e, this),
                this._syncList = [],
                this._data = e
            }
        }
        addElements() {
            let t = this._cachedMeta;
            this._dataCheck(),
            this.datasetElementType && (t.dataset = new this.datasetElementType)
        }
        buildOrUpdateElements(t) {
            let e = this._cachedMeta
              , s = this.getDataset()
              , r = !1;
            this._dataCheck();
            let a = e._stacked;
            e._stacked = tg(e.vScale, e),
            e.stack !== s.stack && (r = !0,
            _o(e),
            e.stack = s.stack),
            this._resyncElements(t),
            (r || a !== e._stacked) && ig(this, e._parsed)
        }
        configure() {
            let t = this.chart.config
              , e = t.datasetScopeKeys(this._type)
              , s = t.getOptionScopes(this.getDataset(), e, !0);
            this.options = t.createResolver(s, this.getContext()),
            this._parsing = this.options.parsing,
            this._cachedDataOpts = {}
        }
        parse(t, e) {
            let {_cachedMeta: s, _data: r} = this, {iScale: a, _stacked: l} = s, u = a.axis, d = t === 0 && e === r.length ? !0 : s._sorted, p = t > 0 && s._parsed[t - 1], b, E, x;
            if (this._parsing === !1)
                s._parsed = r,
                s._sorted = !0,
                x = r;
            else {
                ee(r[t]) ? x = this.parseArrayData(s, r, t, e) : Ht(r[t]) ? x = this.parseObjectData(s, r, t, e) : x = this.parsePrimitiveData(s, r, t, e);
                let w = o( () => E[u] === null || p && E[u] < p[u], "isNotInOrderComparedToPrev");
                for (b = 0; b < e; ++b)
                    s._parsed[b + t] = E = x[b],
                    d && (w() && (d = !1),
                    p = E);
                s._sorted = d
            }
            l && ig(this, x)
        }
        parsePrimitiveData(t, e, s, r) {
            let {iScale: a, vScale: l} = t, u = a.axis, d = l.axis, p = a.getLabels(), b = a === l, E = new Array(r), x, w, C;
            for (x = 0,
            w = r; x < w; ++x)
                C = x + s,
                E[x] = {
                    [u]: b || a.parse(p[C], C),
                    [d]: l.parse(e[C], C)
                };
            return E
        }
        parseArrayData(t, e, s, r) {
            let {xScale: a, yScale: l} = t, u = new Array(r), d, p, b, E;
            for (d = 0,
            p = r; d < p; ++d)
                b = d + s,
                E = e[b],
                u[d] = {
                    x: a.parse(E[0], b),
                    y: l.parse(E[1], b)
                };
            return u
        }
        parseObjectData(t, e, s, r) {
            let {xScale: a, yScale: l} = t, {xAxisKey: u="x", yAxisKey: d="y"} = this._parsing, p = new Array(r), b, E, x, w;
            for (b = 0,
            E = r; b < E; ++b)
                x = b + s,
                w = e[x],
                p[b] = {
                    x: a.parse(gn(w, u), x),
                    y: l.parse(gn(w, d), x)
                };
            return p
        }
        getParsed(t) {
            return this._cachedMeta._parsed[t]
        }
        getDataElement(t) {
            return this._cachedMeta.data[t]
        }
        applyStack(t, e, s) {
            let r = this.chart
              , a = this._cachedMeta
              , l = e[t.axis]
              , u = {
                keys: Wg(r, !0),
                values: e._stacks[t.axis]
            };
            return Zp(u, l, a.index, {
                mode: s
            })
        }
        updateRangeFromParsed(t, e, s, r) {
            let a = s[e.axis]
              , l = a === null ? NaN : a
              , u = r && s._stacks[e.axis];
            r && u && (r.values = u,
            l = Zp(r, a, this._cachedMeta.index)),
            t.min = Math.min(t.min, l),
            t.max = Math.max(t.max, l)
        }
        getMinMax(t, e) {
            let s = this._cachedMeta, r = s._parsed, a = s._sorted && t === s.iScale, l = r.length, u = this._getOtherScale(t), d = F_(e, s, this.chart), p = {
                min: Number.POSITIVE_INFINITY,
                max: Number.NEGATIVE_INFINITY
            }, {min: b, max: E} = P_(u), x, w;
            function C() {
                w = r[x];
                let I = w[u.axis];
                return !fe(w[t.axis]) || b > I || E < I
            }
            for (o(C, "_skip"),
            x = 0; x < l && !(!C() && (this.updateRangeFromParsed(p, t, w, d),
            a)); ++x)
                ;
            if (a) {
                for (x = l - 1; x >= 0; --x)
                    if (!C()) {
                        this.updateRangeFromParsed(p, t, w, d);
                        break
                    }
            }
            return p
        }
        getAllParsedValues(t) {
            let e = this._cachedMeta._parsed, s = [], r, a, l;
            for (r = 0,
            a = e.length; r < a; ++r)
                l = e[r][t.axis],
                fe(l) && s.push(l);
            return s
        }
        getMaxOverflow() {
            return !1
        }
        getLabelAndValue(t) {
            let e = this._cachedMeta
              , s = e.iScale
              , r = e.vScale
              , a = this.getParsed(t);
            return {
                label: s ? "" + s.getLabelForValue(a[s.axis]) : "",
                value: r ? "" + r.getLabelForValue(a[r.axis]) : ""
            }
        }
        _update(t) {
            let e = this._cachedMeta;
            this.update(t || "default"),
            e._clip = O_(It(this.options.clip, M_(e.xScale, e.yScale, this.getMaxOverflow())))
        }
        update(t) {}
        draw() {
            let t = this._ctx, e = this.chart, s = this._cachedMeta, r = s.data || [], a = e.chartArea, l = [], u = this._drawStart || 0, d = this._drawCount || r.length - u, p = this.options.drawActiveElementsOnTop, b;
            for (s.dataset && s.dataset.draw(t, a, u, d),
            b = u; b < u + d; ++b) {
                let E = r[b];
                E.hidden || (E.active && p ? l.push(E) : E.draw(t, a))
            }
            for (b = 0; b < l.length; ++b)
                l[b].draw(t, a)
        }
        getStyle(t, e) {
            let s = e ? "active" : "default";
            return t === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(s) : this.resolveDataElementOptions(t || 0, s)
        }
        getContext(t, e, s) {
            let r = this.getDataset(), a;
            if (t >= 0 && t < this._cachedMeta.data.length) {
                let l = this._cachedMeta.data[t];
                a = l.$context || (l.$context = N_(this.getContext(), t, l)),
                a.parsed = this.getParsed(t),
                a.raw = r.data[t],
                a.index = a.dataIndex = t
            } else
                a = this.$context || (this.$context = I_(this.chart.getContext(), this.index)),
                a.dataset = r,
                a.index = a.datasetIndex = this.index;
            return a.active = !!e,
            a.mode = s,
            a
        }
        resolveDatasetElementOptions(t) {
            return this._resolveElementOptions(this.datasetElementType.id, t)
        }
        resolveDataElementOptions(t, e) {
            return this._resolveElementOptions(this.dataElementType.id, e, t)
        }
        _resolveElementOptions(t, e="default", s) {
            let r = e === "active"
              , a = this._cachedDataOpts
              , l = t + "-" + e
              , u = a[l]
              , d = this.enableOptionSharing && si(s);
            if (u)
                return ng(u, d);
            let p = this.chart.config
              , b = p.datasetElementScopeKeys(this._type, t)
              , E = r ? [`${t}Hover`, "hover", t, ""] : [t, ""]
              , x = p.getOptionScopes(this.getDataset(), b)
              , w = Object.keys(jt.elements[t])
              , C = o( () => this.getContext(s, r), "context")
              , I = p.resolveNamedOptions(x, w, C, E);
            return I.$shared && (I.$shared = d,
            a[l] = Object.freeze(ng(I, d))),
            I
        }
        _resolveAnimations(t, e, s) {
            let r = this.chart
              , a = this._cachedDataOpts
              , l = `animation-${e}`
              , u = a[l];
            if (u)
                return u;
            let d;
            if (r.options.animation !== !1) {
                let b = this.chart.config
                  , E = b.datasetAnimationScopeKeys(this._type, e)
                  , x = b.getOptionScopes(this.getDataset(), E);
                d = b.createResolver(x, this.getContext(t, s, e))
            }
            let p = new sl(r,d && d.animations);
            return d && d._cacheable && (a[l] = Object.freeze(p)),
            p
        }
        getSharedOptions(t) {
            if (t.$shared)
                return this._sharedOptions || (this._sharedOptions = Object.assign({}, t))
        }
        includeOptions(t, e) {
            return !e || ed(t) || this.chart._animationsDisabled
        }
        _getSharedOptions(t, e) {
            let s = this.resolveDataElementOptions(t, e)
              , r = this._sharedOptions
              , a = this.getSharedOptions(s)
              , l = this.includeOptions(e, a) || a !== r;
            return this.updateSharedOptions(a, e, s),
            {
                sharedOptions: a,
                includeOptions: l
            }
        }
        updateElement(t, e, s, r) {
            ed(r) ? Object.assign(t, s) : this._resolveAnimations(e, r).update(t, s)
        }
        updateSharedOptions(t, e, s) {
            t && !ed(e) && this._resolveAnimations(void 0, e).update(t, s)
        }
        _setStyle(t, e, s, r) {
            t.active = r;
            let a = this.getStyle(e, r);
            this._resolveAnimations(e, s, r).update(t, {
                options: !r && this.getSharedOptions(a) || a
            })
        }
        removeHoverStyle(t, e, s) {
            this._setStyle(t, s, "active", !1)
        }
        setHoverStyle(t, e, s) {
            this._setStyle(t, s, "active", !0)
        }
        _removeDatasetHoverStyle() {
            let t = this._cachedMeta.dataset;
            t && this._setStyle(t, void 0, "active", !1)
        }
        _setDatasetHoverStyle() {
            let t = this._cachedMeta.dataset;
            t && this._setStyle(t, void 0, "active", !0)
        }
        _resyncElements(t) {
            let e = this._data
              , s = this._cachedMeta.data;
            for (let[u,d,p] of this._syncList)
                this[u](d, p);
            this._syncList = [];
            let r = s.length
              , a = e.length
              , l = Math.min(a, r);
            l && this.parse(0, l),
            a > r ? this._insertElements(r, a - r, t) : a < r && this._removeElements(a, r - a)
        }
        _insertElements(t, e, s=!0) {
            let r = this._cachedMeta, a = r.data, l = t + e, u, d = o(p => {
                for (p.length += e,
                u = p.length - 1; u >= l; u--)
                    p[u] = p[u - e]
            }
            , "move");
            for (d(a),
            u = t; u < l; ++u)
                a[u] = new this.dataElementType;
            this._parsing && d(r._parsed),
            this.parse(t, e),
            s && this.updateElements(a, t, e, "reset")
        }
        updateElements(t, e, s, r) {}
        _removeElements(t, e) {
            let s = this._cachedMeta;
            if (this._parsing) {
                let r = s._parsed.splice(t, e);
                s._stacked && _o(s, r)
            }
            s.data.splice(t, e)
        }
        _sync(t) {
            if (this._parsing)
                this._syncList.push(t);
            else {
                let[e,s,r] = t;
                this[e](s, r)
            }
            this.chart._dataChanges.push([this.index, ...t])
        }
        _onDataPush() {
            let t = arguments.length;
            this._sync(["_insertElements", this.getDataset().data.length - t, t])
        }
        _onDataPop() {
            this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1])
        }
        _onDataShift() {
            this._sync(["_removeElements", 0, 1])
        }
        _onDataSplice(t, e) {
            e && this._sync(["_removeElements", t, e]);
            let s = arguments.length - 2;
            s && this._sync(["_insertElements", t, s])
        }
        _onDataUnshift() {
            this._sync(["_insertElements", 0, arguments.length])
        }
    }
    ;
    ai.defaults = {};
    ai.prototype.datasetElementType = null;
    ai.prototype.dataElementType = null;
    function V_(n, t) {
        if (!n._cache.$bar) {
            let e = n.getMatchingVisibleMetas(t)
              , s = [];
            for (let r = 0, a = e.length; r < a; r++)
                s = s.concat(e[r].controller.getAllParsedValues(n));
            n._cache.$bar = Lh(s.sort( (r, a) => r - a))
        }
        return n._cache.$bar
    }
    o(V_, "getAllScaleValues");
    function B_(n) {
        let t = n.iScale, e = V_(t, n.type), s = t._length, r, a, l, u, d = o( () => {
            l === 32767 || l === -32768 || (si(u) && (s = Math.min(s, Math.abs(l - u) || s)),
            u = l)
        }
        , "updateMinAndPrev");
        for (r = 0,
        a = e.length; r < a; ++r)
            l = t.getPixelForValue(e[r]),
            d();
        for (u = void 0,
        r = 0,
        a = t.ticks.length; r < a; ++r)
            l = t.getPixelForTick(r),
            d();
        return s
    }
    o(B_, "computeMinSampleSize");
    function H_(n, t, e, s) {
        let r = e.barThickness, a, l;
        return zt(r) ? (a = t.min * e.categoryPercentage,
        l = e.barPercentage) : (a = r * s,
        l = 1),
        {
            chunk: a / s,
            ratio: l,
            start: t.pixels[n] - a / 2
        }
    }
    o(H_, "computeFitCategoryTraits");
    function j_(n, t, e, s) {
        let r = t.pixels
          , a = r[n]
          , l = n > 0 ? r[n - 1] : null
          , u = n < r.length - 1 ? r[n + 1] : null
          , d = e.categoryPercentage;
        l === null && (l = a - (u === null ? t.end - t.start : u - a)),
        u === null && (u = a + a - l);
        let p = a - (a - Math.min(l, u)) / 2 * d;
        return {
            chunk: Math.abs(u - l) / 2 * d / s,
            ratio: e.barPercentage,
            start: p
        }
    }
    o(j_, "computeFlexCategoryTraits");
    function W_(n, t, e, s) {
        let r = e.parse(n[0], s)
          , a = e.parse(n[1], s)
          , l = Math.min(r, a)
          , u = Math.max(r, a)
          , d = l
          , p = u;
        Math.abs(l) > Math.abs(u) && (d = u,
        p = l),
        t[e.axis] = p,
        t._custom = {
            barStart: d,
            barEnd: p,
            start: r,
            end: a,
            min: l,
            max: u
        }
    }
    o(W_, "parseFloatBar");
    function $g(n, t, e, s) {
        return ee(n) ? W_(n, t, e, s) : t[e.axis] = e.parse(n, s),
        t
    }
    o($g, "parseValue");
    function sg(n, t, e, s) {
        let r = n.iScale, a = n.vScale, l = r.getLabels(), u = r === a, d = [], p, b, E, x;
        for (p = e,
        b = e + s; p < b; ++p)
            x = t[p],
            E = {},
            E[r.axis] = u || r.parse(l[p], p),
            d.push($g(x, E, a, p));
        return d
    }
    o(sg, "parseArrayOrPrimitive");
    function id(n) {
        return n && n.barStart !== void 0 && n.barEnd !== void 0
    }
    o(id, "isFloatBar");
    function $_(n, t, e) {
        return n !== 0 ? Oi(n) : (t.isHorizontal() ? 1 : -1) * (t.min >= e ? 1 : -1)
    }
    o($_, "barSign");
    function q_(n) {
        let t, e, s, r, a;
        return n.horizontal ? (t = n.base > n.x,
        e = "left",
        s = "right") : (t = n.base < n.y,
        e = "bottom",
        s = "top"),
        t ? (r = "end",
        a = "start") : (r = "start",
        a = "end"),
        {
            start: e,
            end: s,
            reverse: t,
            top: r,
            bottom: a
        }
    }
    o(q_, "borderProps");
    function z_(n, t, e, s) {
        let r = t.borderSkipped
          , a = {};
        if (!r) {
            n.borderSkipped = a;
            return
        }
        if (r === !0) {
            n.borderSkipped = {
                top: !0,
                right: !0,
                bottom: !0,
                left: !0
            };
            return
        }
        let {start: l, end: u, reverse: d, top: p, bottom: b} = q_(n);
        r === "middle" && e && (n.enableBorderRadius = !0,
        (e._top || 0) === s ? r = p : (e._bottom || 0) === s ? r = b : (a[rg(b, l, u, d)] = !0,
        r = p)),
        a[rg(r, l, u, d)] = !0,
        n.borderSkipped = a
    }
    o(z_, "setBorderSkipped");
    function rg(n, t, e, s) {
        return s ? (n = U_(n, t, e),
        n = og(n, e, t)) : n = og(n, t, e),
        n
    }
    o(rg, "parseEdge");
    function U_(n, t, e) {
        return n === t ? e : n === e ? t : n
    }
    o(U_, "swap");
    function og(n, t, e) {
        return n === "start" ? t : n === "end" ? e : n
    }
    o(og, "startEnd");
    function K_(n, {inflateAmount: t}, e) {
        n.inflateAmount = t === "auto" ? e === 1 ? .33 : 0 : t
    }
    o(K_, "setInflateAmount");
    var dr = class extends ai {
        static{o(this, "BarController")
        }parsePrimitiveData(t, e, s, r) {
            return sg(t, e, s, r)
        }
        parseArrayData(t, e, s, r) {
            return sg(t, e, s, r)
        }
        parseObjectData(t, e, s, r) {
            let {iScale: a, vScale: l} = t, {xAxisKey: u="x", yAxisKey: d="y"} = this._parsing, p = a.axis === "x" ? u : d, b = l.axis === "x" ? u : d, E = [], x, w, C, I;
            for (x = s,
            w = s + r; x < w; ++x)
                I = e[x],
                C = {},
                C[a.axis] = a.parse(gn(I, p), x),
                E.push($g(gn(I, b), C, l, x));
            return E
        }
        updateRangeFromParsed(t, e, s, r) {
            super.updateRangeFromParsed(t, e, s, r);
            let a = s._custom;
            a && e === this._cachedMeta.vScale && (t.min = Math.min(t.min, a.min),
            t.max = Math.max(t.max, a.max))
        }
        getMaxOverflow() {
            return 0
        }
        getLabelAndValue(t) {
            let e = this._cachedMeta
              , {iScale: s, vScale: r} = e
              , a = this.getParsed(t)
              , l = a._custom
              , u = id(l) ? "[" + l.start + ", " + l.end + "]" : "" + r.getLabelForValue(a[r.axis]);
            return {
                label: "" + s.getLabelForValue(a[s.axis]),
                value: u
            }
        }
        initialize() {
            this.enableOptionSharing = !0,
            super.initialize();
            let t = this._cachedMeta;
            t.stack = this.getDataset().stack
        }
        update(t) {
            let e = this._cachedMeta;
            this.updateElements(e.data, 0, e.data.length, t)
        }
        updateElements(t, e, s, r) {
            let a = r === "reset"
              , {index: l, _cachedMeta: {vScale: u}} = this
              , d = u.getBasePixel()
              , p = u.isHorizontal()
              , b = this._getRuler()
              , {sharedOptions: E, includeOptions: x} = this._getSharedOptions(e, r);
            for (let w = e; w < e + s; w++) {
                let C = this.getParsed(w)
                  , I = a || zt(C[u.axis]) ? {
                    base: d,
                    head: d
                } : this._calculateBarValuePixels(w)
                  , L = this._calculateBarIndexPixels(w, b)
                  , k = (C._stacks || {})[u.axis]
                  , F = {
                    horizontal: p,
                    base: I.base,
                    enableBorderRadius: !k || id(C._custom) || l === k._top || l === k._bottom,
                    x: p ? I.head : L.center,
                    y: p ? L.center : I.head,
                    height: p ? L.size : Math.abs(I.size),
                    width: p ? Math.abs(I.size) : L.size
                };
                x && (F.options = E || this.resolveDataElementOptions(w, t[w].active ? "active" : r));
                let z = F.options || t[w].options;
                z_(F, z, k, l),
                K_(F, z, b.ratio),
                this.updateElement(t[w], w, F, r)
            }
        }
        _getStacks(t, e) {
            let {iScale: s} = this._cachedMeta
              , r = s.getMatchingVisibleMetas(this._type).filter(d => d.controller.options.grouped)
              , a = s.options.stacked
              , l = []
              , u = o(d => {
                let p = d.controller.getParsed(e)
                  , b = p && p[d.vScale.axis];
                if (zt(b) || isNaN(b))
                    return !0
            }
            , "skipNull");
            for (let d of r)
                if (!(e !== void 0 && u(d)) && ((a === !1 || l.indexOf(d.stack) === -1 || a === void 0 && d.stack === void 0) && l.push(d.stack),
                d.index === t))
                    break;
            return l.length || l.push(void 0),
            l
        }
        _getStackCount(t) {
            return this._getStacks(void 0, t).length
        }
        _getStackIndex(t, e, s) {
            let r = this._getStacks(t, s)
              , a = e !== void 0 ? r.indexOf(e) : -1;
            return a === -1 ? r.length - 1 : a
        }
        _getRuler() {
            let t = this.options, e = this._cachedMeta, s = e.iScale, r = [], a, l;
            for (a = 0,
            l = e.data.length; a < l; ++a)
                r.push(s.getPixelForValue(this.getParsed(a)[s.axis], a));
            let u = t.barThickness;
            return {
                min: u || B_(e),
                pixels: r,
                start: s._startPixel,
                end: s._endPixel,
                stackCount: this._getStackCount(),
                scale: s,
                grouped: t.grouped,
                ratio: u ? 1 : t.categoryPercentage * t.barPercentage
            }
        }
        _calculateBarValuePixels(t) {
            let {_cachedMeta: {vScale: e, _stacked: s}, options: {base: r, minBarLength: a}} = this, l = r || 0, u = this.getParsed(t), d = u._custom, p = id(d), b = u[e.axis], E = 0, x = s ? this.applyStack(e, u, s) : b, w, C;
            x !== b && (E = x - b,
            x = b),
            p && (b = d.barStart,
            x = d.barEnd - d.barStart,
            b !== 0 && Oi(b) !== Oi(d.barEnd) && (E = 0),
            E += b);
            let I = !zt(r) && !p ? r : E
              , L = e.getPixelForValue(I);
            if (this.chart.getDataVisibility(t) ? w = e.getPixelForValue(E + x) : w = L,
            C = w - L,
            Math.abs(C) < a) {
                C = $_(C, e, l) * a,
                b === l && (L -= C / 2);
                let k = e.getPixelForDecimal(0)
                  , F = e.getPixelForDecimal(1)
                  , z = Math.min(k, F)
                  , j = Math.max(k, F);
                L = Math.max(Math.min(L, j), z),
                w = L + C
            }
            if (L === e.getPixelForValue(l)) {
                let k = Oi(C) * e.getLineWidthForValue(l) / 2;
                L += k,
                C -= k
            }
            return {
                size: C,
                base: L,
                head: w,
                center: w + C / 2
            }
        }
        _calculateBarIndexPixels(t, e) {
            let s = e.scale, r = this.options, a = r.skipNull, l = It(r.maxBarThickness, 1 / 0), u, d;
            if (e.grouped) {
                let p = a ? this._getStackCount(t) : e.stackCount
                  , b = r.barThickness === "flex" ? j_(t, e, r, p) : H_(t, e, r, p)
                  , E = this._getStackIndex(this.index, this._cachedMeta.stack, a ? t : void 0);
                u = b.start + b.chunk * E + b.chunk / 2,
                d = Math.min(l, b.chunk * b.ratio)
            } else
                u = s.getPixelForValue(this.getParsed(t)[s.axis], t),
                d = Math.min(l, e.min * e.ratio);
            return {
                base: u - d / 2,
                head: u + d / 2,
                center: u,
                size: d
            }
        }
        draw() {
            let t = this._cachedMeta
              , e = t.vScale
              , s = t.data
              , r = s.length
              , a = 0;
            for (; a < r; ++a)
                this.getParsed(a)[e.axis] !== null && s[a].draw(this._ctx)
        }
    }
    ;
    dr.id = "bar";
    dr.defaults = {
        datasetElementType: !1,
        dataElementType: "bar",
        categoryPercentage: .8,
        barPercentage: .9,
        grouped: !0,
        animations: {
            numbers: {
                type: "number",
                properties: ["x", "y", "base", "width", "height"]
            }
        }
    };
    dr.overrides = {
        scales: {
            _index_: {
                type: "category",
                offset: !0,
                grid: {
                    offset: !0
                }
            },
            _value_: {
                type: "linear",
                beginAtZero: !0
            }
        }
    };
    var fr = class extends ai {
        static{o(this, "BubbleController")
        }initialize() {
            this.enableOptionSharing = !0,
            super.initialize()
        }
        parsePrimitiveData(t, e, s, r) {
            let a = super.parsePrimitiveData(t, e, s, r);
            for (let l = 0; l < a.length; l++)
                a[l]._custom = this.resolveDataElementOptions(l + s).radius;
            return a
        }
        parseArrayData(t, e, s, r) {
            let a = super.parseArrayData(t, e, s, r);
            for (let l = 0; l < a.length; l++) {
                let u = e[s + l];
                a[l]._custom = It(u[2], this.resolveDataElementOptions(l + s).radius)
            }
            return a
        }
        parseObjectData(t, e, s, r) {
            let a = super.parseObjectData(t, e, s, r);
            for (let l = 0; l < a.length; l++) {
                let u = e[s + l];
                a[l]._custom = It(u && u.r && +u.r, this.resolveDataElementOptions(l + s).radius)
            }
            return a
        }
        getMaxOverflow() {
            let t = this._cachedMeta.data
              , e = 0;
            for (let s = t.length - 1; s >= 0; --s)
                e = Math.max(e, t[s].size(this.resolveDataElementOptions(s)) / 2);
            return e > 0 && e
        }
        getLabelAndValue(t) {
            let e = this._cachedMeta
              , {xScale: s, yScale: r} = e
              , a = this.getParsed(t)
              , l = s.getLabelForValue(a.x)
              , u = r.getLabelForValue(a.y)
              , d = a._custom;
            return {
                label: e.label,
                value: "(" + l + ", " + u + (d ? ", " + d : "") + ")"
            }
        }
        update(t) {
            let e = this._cachedMeta.data;
            this.updateElements(e, 0, e.length, t)
        }
        updateElements(t, e, s, r) {
            let a = r === "reset"
              , {iScale: l, vScale: u} = this._cachedMeta
              , {sharedOptions: d, includeOptions: p} = this._getSharedOptions(e, r)
              , b = l.axis
              , E = u.axis;
            for (let x = e; x < e + s; x++) {
                let w = t[x]
                  , C = !a && this.getParsed(x)
                  , I = {}
                  , L = I[b] = a ? l.getPixelForDecimal(.5) : l.getPixelForValue(C[b])
                  , k = I[E] = a ? u.getBasePixel() : u.getPixelForValue(C[E]);
                I.skip = isNaN(L) || isNaN(k),
                p && (I.options = d || this.resolveDataElementOptions(x, w.active ? "active" : r),
                a && (I.options.radius = 0)),
                this.updateElement(w, x, I, r)
            }
        }
        resolveDataElementOptions(t, e) {
            let s = this.getParsed(t)
              , r = super.resolveDataElementOptions(t, e);
            r.$shared && (r = Object.assign({}, r, {
                $shared: !1
            }));
            let a = r.radius;
            return e !== "active" && (r.radius = 0),
            r.radius += It(s && s._custom, a),
            r
        }
    }
    ;
    fr.id = "bubble";
    fr.defaults = {
        datasetElementType: !1,
        dataElementType: "point",
        animations: {
            numbers: {
                type: "number",
                properties: ["x", "y", "borderWidth", "radius"]
            }
        }
    };
    fr.overrides = {
        scales: {
            x: {
                type: "linear"
            },
            y: {
                type: "linear"
            }
        },
        plugins: {
            tooltip: {
                callbacks: {
                    title() {
                        return ""
                    }
                }
            }
        }
    };
    function Y_(n, t, e) {
        let s = 1
          , r = 1
          , a = 0
          , l = 0;
        if (t < te) {
            let u = n
              , d = u + t
              , p = Math.cos(u)
              , b = Math.sin(u)
              , E = Math.cos(d)
              , x = Math.sin(d)
              , w = o( (z, j, H) => or(z, u, d, !0) ? 1 : Math.max(j, j * e, H, H * e), "calcMax")
              , C = o( (z, j, H) => or(z, u, d, !0) ? -1 : Math.min(j, j * e, H, H * e), "calcMin")
              , I = w(0, p, E)
              , L = w(he, b, x)
              , k = C(ae, p, E)
              , F = C(ae + he, b, x);
            s = (I - k) / 2,
            r = (L - F) / 2,
            a = -(I + k) / 2,
            l = -(L + F) / 2
        }
        return {
            ratioX: s,
            ratioY: r,
            offsetX: a,
            offsetY: l
        }
    }
    o(Y_, "getRatioAndOffset");
    var zn = class extends ai {
        static{o(this, "DoughnutController")
        }constructor(t, e) {
            super(t, e),
            this.enableOptionSharing = !0,
            this.innerRadius = void 0,
            this.outerRadius = void 0,
            this.offsetX = void 0,
            this.offsetY = void 0
        }
        linkScales() {}
        parse(t, e) {
            let s = this.getDataset().data
              , r = this._cachedMeta;
            if (this._parsing === !1)
                r._parsed = s;
            else {
                let a = o(d => +s[d], "getter");
                if (Ht(s[t])) {
                    let {key: d="value"} = this._parsing;
                    a = o(p => +gn(s[p], d), "getter")
                }
                let l, u;
                for (l = t,
                u = t + e; l < u; ++l)
                    r._parsed[l] = a(l)
            }
        }
        _getRotation() {
            return _i(this.options.rotation - 90)
        }
        _getCircumference() {
            return _i(this.options.circumference)
        }
        _getRotationExtents() {
            let t = te
              , e = -te;
            for (let s = 0; s < this.chart.data.datasets.length; ++s)
                if (this.chart.isDatasetVisible(s)) {
                    let r = this.chart.getDatasetMeta(s).controller
                      , a = r._getRotation()
                      , l = r._getCircumference();
                    t = Math.min(t, a),
                    e = Math.max(e, a + l)
                }
            return {
                rotation: t,
                circumference: e - t
            }
        }
        update(t) {
            let e = this.chart
              , {chartArea: s} = e
              , r = this._cachedMeta
              , a = r.data
              , l = this.getMaxBorderWidth() + this.getMaxOffset(a) + this.options.spacing
              , u = Math.max((Math.min(s.width, s.height) - l) / 2, 0)
              , d = Math.min(yp(this.options.cutout, u), 1)
              , p = this._getRingWeight(this.index)
              , {circumference: b, rotation: E} = this._getRotationExtents()
              , {ratioX: x, ratioY: w, offsetX: C, offsetY: I} = Y_(E, b, d)
              , L = (s.width - l) / x
              , k = (s.height - l) / w
              , F = Math.max(Math.min(L, k) / 2, 0)
              , z = xh(this.options.radius, F)
              , j = Math.max(z * d, 0)
              , H = (z - j) / this._getVisibleDatasetWeightTotal();
            this.offsetX = C * z,
            this.offsetY = I * z,
            r.total = this.calculateTotal(),
            this.outerRadius = z - H * this._getRingWeightOffset(this.index),
            this.innerRadius = Math.max(this.outerRadius - H * p, 0),
            this.updateElements(a, 0, a.length, t)
        }
        _circumference(t, e) {
            let s = this.options
              , r = this._cachedMeta
              , a = this._getCircumference();
            return e && s.animation.animateRotate || !this.chart.getDataVisibility(t) || r._parsed[t] === null || r.data[t].hidden ? 0 : this.calculateCircumference(r._parsed[t] * a / te)
        }
        updateElements(t, e, s, r) {
            let a = r === "reset", l = this.chart, u = l.chartArea, p = l.options.animation, b = (u.left + u.right) / 2, E = (u.top + u.bottom) / 2, x = a && p.animateScale, w = x ? 0 : this.innerRadius, C = x ? 0 : this.outerRadius, {sharedOptions: I, includeOptions: L} = this._getSharedOptions(e, r), k = this._getRotation(), F;
            for (F = 0; F < e; ++F)
                k += this._circumference(F, a);
            for (F = e; F < e + s; ++F) {
                let z = this._circumference(F, a)
                  , j = t[F]
                  , H = {
                    x: b + this.offsetX,
                    y: E + this.offsetY,
                    startAngle: k,
                    endAngle: k + z,
                    circumference: z,
                    outerRadius: C,
                    innerRadius: w
                };
                L && (H.options = I || this.resolveDataElementOptions(F, j.active ? "active" : r)),
                k += z,
                this.updateElement(j, F, H, r)
            }
        }
        calculateTotal() {
            let t = this._cachedMeta, e = t.data, s = 0, r;
            for (r = 0; r < e.length; r++) {
                let a = t._parsed[r];
                a !== null && !isNaN(a) && this.chart.getDataVisibility(r) && !e[r].hidden && (s += Math.abs(a))
            }
            return s
        }
        calculateCircumference(t) {
            let e = this._cachedMeta.total;
            return e > 0 && !isNaN(t) ? te * (Math.abs(t) / e) : 0
        }
        getLabelAndValue(t) {
            let e = this._cachedMeta
              , s = this.chart
              , r = s.data.labels || []
              , a = cr(e._parsed[t], s.options.locale);
            return {
                label: r[t] || "",
                value: a
            }
        }
        getMaxBorderWidth(t) {
            let e = 0, s = this.chart, r, a, l, u, d;
            if (!t) {
                for (r = 0,
                a = s.data.datasets.length; r < a; ++r)
                    if (s.isDatasetVisible(r)) {
                        l = s.getDatasetMeta(r),
                        t = l.data,
                        u = l.controller;
                        break
                    }
            }
            if (!t)
                return 0;
            for (r = 0,
            a = t.length; r < a; ++r)
                d = u.resolveDataElementOptions(r),
                d.borderAlign !== "inner" && (e = Math.max(e, d.borderWidth || 0, d.hoverBorderWidth || 0));
            return e
        }
        getMaxOffset(t) {
            let e = 0;
            for (let s = 0, r = t.length; s < r; ++s) {
                let a = this.resolveDataElementOptions(s);
                e = Math.max(e, a.offset || 0, a.hoverOffset || 0)
            }
            return e
        }
        _getRingWeightOffset(t) {
            let e = 0;
            for (let s = 0; s < t; ++s)
                this.chart.isDatasetVisible(s) && (e += this._getRingWeight(s));
            return e
        }
        _getRingWeight(t) {
            return Math.max(It(this.chart.data.datasets[t].weight, 1), 0)
        }
        _getVisibleDatasetWeightTotal() {
            return this._getRingWeightOffset(this.chart.data.datasets.length) || 1
        }
    }
    ;
    zn.id = "doughnut";
    zn.defaults = {
        datasetElementType: !1,
        dataElementType: "arc",
        animation: {
            animateRotate: !0,
            animateScale: !1
        },
        animations: {
            numbers: {
                type: "number",
                properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
            }
        },
        cutout: "50%",
        rotation: 0,
        circumference: 360,
        radius: "100%",
        spacing: 0,
        indexAxis: "r"
    };
    zn.descriptors = {
        _scriptable: o(n => n !== "spacing", "_scriptable"),
        _indexable: o(n => n !== "spacing", "_indexable")
    };
    zn.overrides = {
        aspectRatio: 1,
        plugins: {
            legend: {
                labels: {
                    generateLabels(n) {
                        let t = n.data;
                        if (t.labels.length && t.datasets.length) {
                            let {labels: {pointStyle: e}} = n.legend.options;
                            return t.labels.map( (s, r) => {
                                let l = n.getDatasetMeta(0).controller.getStyle(r);
                                return {
                                    text: s,
                                    fillStyle: l.backgroundColor,
                                    strokeStyle: l.borderColor,
                                    lineWidth: l.borderWidth,
                                    pointStyle: e,
                                    hidden: !n.getDataVisibility(r),
                                    index: r
                                }
                            }
                            )
                        }
                        return []
                    }
                },
                onClick(n, t, e) {
                    e.chart.toggleDataVisibility(t.index),
                    e.chart.update()
                }
            },
            tooltip: {
                callbacks: {
                    title() {
                        return ""
                    },
                    label(n) {
                        let t = n.label
                          , e = ": " + n.formattedValue;
                        return ee(t) ? (t = t.slice(),
                        t[0] += e) : t += e,
                        t
                    }
                }
            }
        }
    };
    var pr = class extends ai {
        static{o(this, "LineController")
        }initialize() {
            this.enableOptionSharing = !0,
            this.supportsDecimation = !0,
            super.initialize()
        }
        update(t) {
            let e = this._cachedMeta
              , {dataset: s, data: r=[], _dataset: a} = e
              , l = this.chart._animationsDisabled
              , {start: u, count: d} = Rh(e, r, l);
            this._drawStart = u,
            this._drawCount = d,
            Ih(e) && (u = 0,
            d = r.length),
            s._chart = this.chart,
            s._datasetIndex = this.index,
            s._decimated = !!a._decimated,
            s.points = r;
            let p = this.resolveDatasetElementOptions(t);
            this.options.showLine || (p.borderWidth = 0),
            p.segment = this.options.segment,
            this.updateElement(s, void 0, {
                animated: !l,
                options: p
            }, t),
            this.updateElements(r, u, d, t)
        }
        updateElements(t, e, s, r) {
            let a = r === "reset"
              , {iScale: l, vScale: u, _stacked: d, _dataset: p} = this._cachedMeta
              , {sharedOptions: b, includeOptions: E} = this._getSharedOptions(e, r)
              , x = l.axis
              , w = u.axis
              , {spanGaps: C, segment: I} = this.options
              , L = ms(C) ? C : Number.POSITIVE_INFINITY
              , k = this.chart._animationsDisabled || a || r === "none"
              , F = e > 0 && this.getParsed(e - 1);
            for (let z = e; z < e + s; ++z) {
                let j = t[z]
                  , H = this.getParsed(z)
                  , f = k ? j : {}
                  , Y = zt(H[w])
                  , Q = f[x] = l.getPixelForValue(H[x], z)
                  , ot = f[w] = a || Y ? u.getBasePixel() : u.getPixelForValue(d ? this.applyStack(u, H, d) : H[w], z);
                f.skip = isNaN(Q) || isNaN(ot) || Y,
                f.stop = z > 0 && Math.abs(H[x] - F[x]) > L,
                I && (f.parsed = H,
                f.raw = p.data[z]),
                E && (f.options = b || this.resolveDataElementOptions(z, j.active ? "active" : r)),
                k || this.updateElement(j, z, f, r),
                F = H
            }
        }
        getMaxOverflow() {
            let t = this._cachedMeta
              , e = t.dataset
              , s = e.options && e.options.borderWidth || 0
              , r = t.data || [];
            if (!r.length)
                return s;
            let a = r[0].size(this.resolveDataElementOptions(0))
              , l = r[r.length - 1].size(this.resolveDataElementOptions(r.length - 1));
            return Math.max(s, a, l) / 2
        }
        draw() {
            let t = this._cachedMeta;
            t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis),
            super.draw()
        }
    }
    ;
    pr.id = "line";
    pr.defaults = {
        datasetElementType: "line",
        dataElementType: "point",
        showLine: !0,
        spanGaps: !1
    };
    pr.overrides = {
        scales: {
            _index_: {
                type: "category"
            },
            _value_: {
                type: "linear"
            }
        }
    };
    var gr = class extends ai {
        static{o(this, "PolarAreaController")
        }constructor(t, e) {
            super(t, e),
            this.innerRadius = void 0,
            this.outerRadius = void 0
        }
        getLabelAndValue(t) {
            let e = this._cachedMeta
              , s = this.chart
              , r = s.data.labels || []
              , a = cr(e._parsed[t].r, s.options.locale);
            return {
                label: r[t] || "",
                value: a
            }
        }
        parseObjectData(t, e, s, r) {
            return Uh.bind(this)(t, e, s, r)
        }
        update(t) {
            let e = this._cachedMeta.data;
            this._updateRadius(),
            this.updateElements(e, 0, e.length, t)
        }
        getMinMax() {
            let t = this._cachedMeta
              , e = {
                min: Number.POSITIVE_INFINITY,
                max: Number.NEGATIVE_INFINITY
            };
            return t.data.forEach( (s, r) => {
                let a = this.getParsed(r).r;
                !isNaN(a) && this.chart.getDataVisibility(r) && (a < e.min && (e.min = a),
                a > e.max && (e.max = a))
            }
            ),
            e
        }
        _updateRadius() {
            let t = this.chart
              , e = t.chartArea
              , s = t.options
              , r = Math.min(e.right - e.left, e.bottom - e.top)
              , a = Math.max(r / 2, 0)
              , l = Math.max(s.cutoutPercentage ? a / 100 * s.cutoutPercentage : 1, 0)
              , u = (a - l) / t.getVisibleDatasetCount();
            this.outerRadius = a - u * this.index,
            this.innerRadius = this.outerRadius - u
        }
        updateElements(t, e, s, r) {
            let a = r === "reset", l = this.chart, d = l.options.animation, p = this._cachedMeta.rScale, b = p.xCenter, E = p.yCenter, x = p.getIndexAngle(0) - .5 * ae, w = x, C, I = 360 / this.countVisibleElements();
            for (C = 0; C < e; ++C)
                w += this._computeAngle(C, r, I);
            for (C = e; C < e + s; C++) {
                let L = t[C]
                  , k = w
                  , F = w + this._computeAngle(C, r, I)
                  , z = l.getDataVisibility(C) ? p.getDistanceFromCenterForValue(this.getParsed(C).r) : 0;
                w = F,
                a && (d.animateScale && (z = 0),
                d.animateRotate && (k = F = x));
                let j = {
                    x: b,
                    y: E,
                    innerRadius: 0,
                    outerRadius: z,
                    startAngle: k,
                    endAngle: F,
                    options: this.resolveDataElementOptions(C, L.active ? "active" : r)
                };
                this.updateElement(L, C, j, r)
            }
        }
        countVisibleElements() {
            let t = this._cachedMeta
              , e = 0;
            return t.data.forEach( (s, r) => {
                !isNaN(this.getParsed(r).r) && this.chart.getDataVisibility(r) && e++
            }
            ),
            e
        }
        _computeAngle(t, e, s) {
            return this.chart.getDataVisibility(t) ? _i(this.resolveDataElementOptions(t, e).angle || s) : 0
        }
    }
    ;
    gr.id = "polarArea";
    gr.defaults = {
        dataElementType: "arc",
        animation: {
            animateRotate: !0,
            animateScale: !0
        },
        animations: {
            numbers: {
                type: "number",
                properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
            }
        },
        indexAxis: "r",
        startAngle: 0
    };
    gr.overrides = {
        aspectRatio: 1,
        plugins: {
            legend: {
                labels: {
                    generateLabels(n) {
                        let t = n.data;
                        if (t.labels.length && t.datasets.length) {
                            let {labels: {pointStyle: e}} = n.legend.options;
                            return t.labels.map( (s, r) => {
                                let l = n.getDatasetMeta(0).controller.getStyle(r);
                                return {
                                    text: s,
                                    fillStyle: l.backgroundColor,
                                    strokeStyle: l.borderColor,
                                    lineWidth: l.borderWidth,
                                    pointStyle: e,
                                    hidden: !n.getDataVisibility(r),
                                    index: r
                                }
                            }
                            )
                        }
                        return []
                    }
                },
                onClick(n, t, e) {
                    e.chart.toggleDataVisibility(t.index),
                    e.chart.update()
                }
            },
            tooltip: {
                callbacks: {
                    title() {
                        return ""
                    },
                    label(n) {
                        return n.chart.data.labels[n.dataIndex] + ": " + n.formattedValue
                    }
                }
            }
        },
        scales: {
            r: {
                type: "radialLinear",
                angleLines: {
                    display: !1
                },
                beginAtZero: !0,
                grid: {
                    circular: !0
                },
                pointLabels: {
                    display: !1
                },
                startAngle: 0
            }
        }
    };
    var Ao = class extends zn {
        static{o(this, "PieController")
        }
    }
    ;
    Ao.id = "pie";
    Ao.defaults = {
        cutout: 0,
        rotation: 0,
        circumference: 360,
        radius: "100%"
    };
    var mr = class extends ai {
        static{o(this, "RadarController")
        }getLabelAndValue(t) {
            let e = this._cachedMeta.vScale
              , s = this.getParsed(t);
            return {
                label: e.getLabels()[t],
                value: "" + e.getLabelForValue(s[e.axis])
            }
        }
        parseObjectData(t, e, s, r) {
            return Uh.bind(this)(t, e, s, r)
        }
        update(t) {
            let e = this._cachedMeta
              , s = e.dataset
              , r = e.data || []
              , a = e.iScale.getLabels();
            if (s.points = r,
            t !== "resize") {
                let l = this.resolveDatasetElementOptions(t);
                this.options.showLine || (l.borderWidth = 0);
                let u = {
                    _loop: !0,
                    _fullLoop: a.length === r.length,
                    options: l
                };
                this.updateElement(s, void 0, u, t)
            }
            this.updateElements(r, 0, r.length, t)
        }
        updateElements(t, e, s, r) {
            let a = this._cachedMeta.rScale
              , l = r === "reset";
            for (let u = e; u < e + s; u++) {
                let d = t[u]
                  , p = this.resolveDataElementOptions(u, d.active ? "active" : r)
                  , b = a.getPointPositionForValue(u, this.getParsed(u).r)
                  , E = l ? a.xCenter : b.x
                  , x = l ? a.yCenter : b.y
                  , w = {
                    x: E,
                    y: x,
                    angle: b.angle,
                    skip: isNaN(E) || isNaN(x),
                    options: p
                };
                this.updateElement(d, u, w, r)
            }
        }
    }
    ;
    mr.id = "radar";
    mr.defaults = {
        datasetElementType: "line",
        dataElementType: "point",
        indexAxis: "r",
        showLine: !0,
        elements: {
            line: {
                fill: "start"
            }
        }
    };
    mr.overrides = {
        aspectRatio: 1,
        scales: {
            r: {
                type: "radialLinear"
            }
        }
    };
    var li = class {
        static{o(this, "Element")
        }constructor() {
            this.x = void 0,
            this.y = void 0,
            this.active = !1,
            this.options = void 0,
            this.$animations = void 0
        }
        tooltipPosition(t) {
            let {x: e, y: s} = this.getProps(["x", "y"], t);
            return {
                x: e,
                y: s
            }
        }
        hasValue() {
            return ms(this.x) && ms(this.y)
        }
        getProps(t, e) {
            let s = this.$animations;
            if (!e || !s)
                return this;
            let r = {};
            return t.forEach(a => {
                r[a] = s[a] && s[a].active() ? s[a]._to : this[a]
            }
            ),
            r
        }
    }
    ;
    li.defaults = {};
    li.defaultRoutes = void 0;
    var qg = {
        values(n) {
            return ee(n) ? n : "" + n
        },
        numeric(n, t, e) {
            if (n === 0)
                return "0";
            let s = this.chart.options.locale, r, a = n;
            if (e.length > 1) {
                let p = Math.max(Math.abs(e[0].value), Math.abs(e[e.length - 1].value));
                (p < 1e-4 || p > 1e15) && (r = "scientific"),
                a = X_(n, e)
            }
            let l = oi(Math.abs(a))
              , u = Math.max(Math.min(-1 * Math.floor(l), 20), 0)
              , d = {
                notation: r,
                minimumFractionDigits: u,
                maximumFractionDigits: u
            };
            return Object.assign(d, this.options.ticks.format),
            cr(n, s, d)
        },
        logarithmic(n, t, e) {
            if (n === 0)
                return "0";
            let s = n / Math.pow(10, Math.floor(oi(n)));
            return s === 1 || s === 2 || s === 5 ? qg.numeric.call(this, n, t, e) : ""
        }
    };
    function X_(n, t) {
        let e = t.length > 3 ? t[2].value - t[1].value : t[1].value - t[0].value;
        return Math.abs(e) >= 1 && n !== Math.floor(n) && (e = n - Math.floor(n)),
        e
    }
    o(X_, "calculateDelta");
    var ul = {
        formatters: qg
    };
    jt.set("scale", {
        display: !0,
        offset: !1,
        reverse: !1,
        beginAtZero: !1,
        bounds: "ticks",
        grace: 0,
        grid: {
            display: !0,
            lineWidth: 1,
            drawBorder: !0,
            drawOnChartArea: !0,
            drawTicks: !0,
            tickLength: 8,
            tickWidth: o( (n, t) => t.lineWidth, "tickWidth"),
            tickColor: o( (n, t) => t.color, "tickColor"),
            offset: !1,
            borderDash: [],
            borderDashOffset: 0,
            borderWidth: 1
        },
        title: {
            display: !1,
            text: "",
            padding: {
                top: 4,
                bottom: 4
            }
        },
        ticks: {
            minRotation: 0,
            maxRotation: 50,
            mirror: !1,
            textStrokeWidth: 0,
            textStrokeColor: "",
            padding: 3,
            display: !0,
            autoSkip: !0,
            autoSkipPadding: 3,
            labelOffset: 0,
            callback: ul.formatters.values,
            minor: {},
            major: {},
            align: "center",
            crossAlign: "near",
            showLabelBackdrop: !1,
            backdropColor: "rgba(255, 255, 255, 0.75)",
            backdropPadding: 2
        }
    });
    jt.route("scale.ticks", "color", "", "color");
    jt.route("scale.grid", "color", "", "borderColor");
    jt.route("scale.grid", "borderColor", "", "borderColor");
    jt.route("scale.title", "color", "", "color");
    jt.describe("scale", {
        _fallback: !1,
        _scriptable: o(n => !n.startsWith("before") && !n.startsWith("after") && n !== "callback" && n !== "parser", "_scriptable"),
        _indexable: o(n => n !== "borderDash" && n !== "tickBorderDash", "_indexable")
    });
    jt.describe("scales", {
        _fallback: "scale"
    });
    jt.describe("scale.ticks", {
        _scriptable: o(n => n !== "backdropPadding" && n !== "callback", "_scriptable"),
        _indexable: o(n => n !== "backdropPadding", "_indexable")
    });
    function G_(n, t) {
        let e = n.options.ticks
          , s = e.maxTicksLimit || Q_(n)
          , r = e.major.enabled ? Z_(t) : []
          , a = r.length
          , l = r[0]
          , u = r[a - 1]
          , d = [];
        if (a > s)
            return tE(t, d, r, a / s),
            d;
        let p = J_(r, t, s);
        if (a > 0) {
            let b, E, x = a > 1 ? Math.round((u - l) / (a - 1)) : null;
            for (Qa(t, d, p, zt(x) ? 0 : l - x, l),
            b = 0,
            E = a - 1; b < E; b++)
                Qa(t, d, p, r[b], r[b + 1]);
            return Qa(t, d, p, u, zt(x) ? t.length : u + x),
            d
        }
        return Qa(t, d, p),
        d
    }
    o(G_, "autoSkip");
    function Q_(n) {
        let t = n.options.offset
          , e = n._tickSize()
          , s = n._length / e + (t ? 0 : 1)
          , r = n._maxLength / e;
        return Math.floor(Math.min(s, r))
    }
    o(Q_, "determineMaxTicks");
    function J_(n, t, e) {
        let s = eE(n)
          , r = t.length / e;
        if (!s)
            return Math.max(r, 1);
        let a = Sp(s);
        for (let l = 0, u = a.length - 1; l < u; l++) {
            let d = a[l];
            if (d > r)
                return d
        }
        return Math.max(r, 1)
    }
    o(J_, "calculateSpacing");
    function Z_(n) {
        let t = [], e, s;
        for (e = 0,
        s = n.length; e < s; e++)
            n[e].major && t.push(e);
        return t
    }
    o(Z_, "getMajorIndices");
    function tE(n, t, e, s) {
        let r = 0, a = e[0], l;
        for (s = Math.ceil(s),
        l = 0; l < n.length; l++)
            l === a && (t.push(n[l]),
            r++,
            a = e[r * s])
    }
    o(tE, "skipMajors");
    function Qa(n, t, e, s, r) {
        let a = It(s, 0), l = Math.min(It(r, n.length), n.length), u = 0, d, p, b;
        for (e = Math.ceil(e),
        r && (d = r - s,
        e = d / Math.floor(d / e)),
        b = a; b < 0; )
            u++,
            b = Math.round(a + u * e);
        for (p = Math.max(a, 0); p < l; p++)
            p === b && (t.push(n[p]),
            u++,
            b = Math.round(a + u * e))
    }
    o(Qa, "skip");
    function eE(n) {
        let t = n.length, e, s;
        if (t < 2)
            return !1;
        for (s = n[0],
        e = 1; e < t; ++e)
            if (n[e] - n[e - 1] !== s)
                return !1;
        return s
    }
    o(eE, "getEvenSpacing");
    var iE = o(n => n === "left" ? "right" : n === "right" ? "left" : n, "reverseAlign")
      , ag = o( (n, t, e) => t === "top" || t === "left" ? n[t] + e : n[t] - e, "offsetFromEdge");
    function lg(n, t) {
        let e = []
          , s = n.length / t
          , r = n.length
          , a = 0;
        for (; a < r; a += s)
            e.push(n[Math.floor(a)]);
        return e
    }
    o(lg, "sample");
    function nE(n, t, e) {
        let s = n.ticks.length, r = Math.min(t, s - 1), a = n._startPixel, l = n._endPixel, u = 1e-6, d = n.getPixelForTick(r), p;
        if (!(e && (s === 1 ? p = Math.max(d - a, l - d) : t === 0 ? p = (n.getPixelForTick(1) - d) / 2 : p = (d - n.getPixelForTick(r - 1)) / 2,
        d += r < t ? p : -p,
        d < a - u || d > l + u)))
            return d
    }
    o(nE, "getPixelForGridLine");
    function sE(n, t) {
        Jt(n, e => {
            let s = e.gc, r = s.length / 2, a;
            if (r > t) {
                for (a = 0; a < r; ++a)
                    delete e.data[s[a]];
                s.splice(0, r)
            }
        }
        )
    }
    o(sE, "garbageCollect");
    function Eo(n) {
        return n.drawTicks ? n.tickLength : 0
    }
    o(Eo, "getTickMarkLength");
    function cg(n, t) {
        if (!n.display)
            return 0;
        let e = ge(n.font, t)
          , s = Me(n.padding);
        return (ee(n.text) ? n.text.length : 1) * e.lineHeight + s.height
    }
    o(cg, "getTitleHeight");
    function rE(n, t) {
        return mn(n, {
            scale: t,
            type: "scale"
        })
    }
    o(rE, "createScaleContext");
    function oE(n, t, e) {
        return mn(n, {
            tick: e,
            index: t,
            type: "tick"
        })
    }
    o(oE, "createTickContext");
    function aE(n, t, e) {
        let s = qa(n);
        return (e && t !== "right" || !e && t === "right") && (s = iE(s)),
        s
    }
    o(aE, "titleAlign");
    function lE(n, t, e, s) {
        let {top: r, left: a, bottom: l, right: u, chart: d} = n, {chartArea: p, scales: b} = d, E = 0, x, w, C, I = l - r, L = u - a;
        if (n.isHorizontal()) {
            if (w = ke(s, a, u),
            Ht(e)) {
                let k = Object.keys(e)[0]
                  , F = e[k];
                C = b[k].getPixelForValue(F) + I - t
            } else
                e === "center" ? C = (p.bottom + p.top) / 2 + I - t : C = ag(n, e, t);
            x = u - a
        } else {
            if (Ht(e)) {
                let k = Object.keys(e)[0]
                  , F = e[k];
                w = b[k].getPixelForValue(F) - L + t
            } else
                e === "center" ? w = (p.left + p.right) / 2 - L + t : w = ag(n, e, t);
            C = ke(s, l, r),
            E = e === "left" ? -he : he
        }
        return {
            titleX: w,
            titleY: C,
            maxWidth: x,
            rotation: E
        }
    }
    o(lE, "titleArgs");
    var ys = class n extends li {
        static{o(this, "Scale")
        }constructor(t) {
            super(),
            this.id = t.id,
            this.type = t.type,
            this.options = void 0,
            this.ctx = t.ctx,
            this.chart = t.chart,
            this.top = void 0,
            this.bottom = void 0,
            this.left = void 0,
            this.right = void 0,
            this.width = void 0,
            this.height = void 0,
            this._margins = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            },
            this.maxWidth = void 0,
            this.maxHeight = void 0,
            this.paddingTop = void 0,
            this.paddingBottom = void 0,
            this.paddingLeft = void 0,
            this.paddingRight = void 0,
            this.axis = void 0,
            this.labelRotation = void 0,
            this.min = void 0,
            this.max = void 0,
            this._range = void 0,
            this.ticks = [],
            this._gridLineItems = null,
            this._labelItems = null,
            this._labelSizes = null,
            this._length = 0,
            this._maxLength = 0,
            this._longestTextCache = {},
            this._startPixel = void 0,
            this._endPixel = void 0,
            this._reversePixels = !1,
            this._userMax = void 0,
            this._userMin = void 0,
            this._suggestedMax = void 0,
            this._suggestedMin = void 0,
            this._ticksLength = 0,
            this._borderValue = 0,
            this._cache = {},
            this._dataLimitsCached = !1,
            this.$context = void 0
        }
        init(t) {
            this.options = t.setContext(this.getContext()),
            this.axis = t.axis,
            this._userMin = this.parse(t.min),
            this._userMax = this.parse(t.max),
            this._suggestedMin = this.parse(t.suggestedMin),
            this._suggestedMax = this.parse(t.suggestedMax)
        }
        parse(t, e) {
            return t
        }
        getUserBounds() {
            let {_userMin: t, _userMax: e, _suggestedMin: s, _suggestedMax: r} = this;
            return t = ri(t, Number.POSITIVE_INFINITY),
            e = ri(e, Number.NEGATIVE_INFINITY),
            s = ri(s, Number.POSITIVE_INFINITY),
            r = ri(r, Number.NEGATIVE_INFINITY),
            {
                min: ri(t, s),
                max: ri(e, r),
                minDefined: fe(t),
                maxDefined: fe(e)
            }
        }
        getMinMax(t) {
            let {min: e, max: s, minDefined: r, maxDefined: a} = this.getUserBounds(), l;
            if (r && a)
                return {
                    min: e,
                    max: s
                };
            let u = this.getMatchingVisibleMetas();
            for (let d = 0, p = u.length; d < p; ++d)
                l = u[d].controller.getMinMax(this, t),
                r || (e = Math.min(e, l.min)),
                a || (s = Math.max(s, l.max));
            return e = a && e > s ? s : e,
            s = r && e > s ? e : s,
            {
                min: ri(e, ri(s, e)),
                max: ri(s, ri(e, s))
            }
        }
        getPadding() {
            return {
                left: this.paddingLeft || 0,
                top: this.paddingTop || 0,
                right: this.paddingRight || 0,
                bottom: this.paddingBottom || 0
            }
        }
        getTicks() {
            return this.ticks
        }
        getLabels() {
            let t = this.chart.data;
            return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || []
        }
        beforeLayout() {
            this._cache = {},
            this._dataLimitsCached = !1
        }
        beforeUpdate() {
            ie(this.options.beforeUpdate, [this])
        }
        update(t, e, s) {
            let {beginAtZero: r, grace: a, ticks: l} = this.options
              , u = l.sampleSize;
            this.beforeUpdate(),
            this.maxWidth = t,
            this.maxHeight = e,
            this._margins = s = Object.assign({
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            }, s),
            this.ticks = null,
            this._labelSizes = null,
            this._gridLineItems = null,
            this._labelItems = null,
            this.beforeSetDimensions(),
            this.setDimensions(),
            this.afterSetDimensions(),
            this._maxLength = this.isHorizontal() ? this.width + s.left + s.right : this.height + s.top + s.bottom,
            this._dataLimitsCached || (this.beforeDataLimits(),
            this.determineDataLimits(),
            this.afterDataLimits(),
            this._range = Bp(this, a, r),
            this._dataLimitsCached = !0),
            this.beforeBuildTicks(),
            this.ticks = this.buildTicks() || [],
            this.afterBuildTicks();
            let d = u < this.ticks.length;
            this._convertTicksToLabels(d ? lg(this.ticks, u) : this.ticks),
            this.configure(),
            this.beforeCalculateLabelRotation(),
            this.calculateLabelRotation(),
            this.afterCalculateLabelRotation(),
            l.display && (l.autoSkip || l.source === "auto") && (this.ticks = G_(this, this.ticks),
            this._labelSizes = null,
            this.afterAutoSkip()),
            d && this._convertTicksToLabels(this.ticks),
            this.beforeFit(),
            this.fit(),
            this.afterFit(),
            this.afterUpdate()
        }
        configure() {
            let t = this.options.reverse, e, s;
            this.isHorizontal() ? (e = this.left,
            s = this.right) : (e = this.top,
            s = this.bottom,
            t = !t),
            this._startPixel = e,
            this._endPixel = s,
            this._reversePixels = t,
            this._length = s - e,
            this._alignToPixels = this.options.alignToPixels
        }
        afterUpdate() {
            ie(this.options.afterUpdate, [this])
        }
        beforeSetDimensions() {
            ie(this.options.beforeSetDimensions, [this])
        }
        setDimensions() {
            this.isHorizontal() ? (this.width = this.maxWidth,
            this.left = 0,
            this.right = this.width) : (this.height = this.maxHeight,
            this.top = 0,
            this.bottom = this.height),
            this.paddingLeft = 0,
            this.paddingTop = 0,
            this.paddingRight = 0,
            this.paddingBottom = 0
        }
        afterSetDimensions() {
            ie(this.options.afterSetDimensions, [this])
        }
        _callHooks(t) {
            this.chart.notifyPlugins(t, this.getContext()),
            ie(this.options[t], [this])
        }
        beforeDataLimits() {
            this._callHooks("beforeDataLimits")
        }
        determineDataLimits() {}
        afterDataLimits() {
            this._callHooks("afterDataLimits")
        }
        beforeBuildTicks() {
            this._callHooks("beforeBuildTicks")
        }
        buildTicks() {
            return []
        }
        afterBuildTicks() {
            this._callHooks("afterBuildTicks")
        }
        beforeTickToLabelConversion() {
            ie(this.options.beforeTickToLabelConversion, [this])
        }
        generateTickLabels(t) {
            let e = this.options.ticks, s, r, a;
            for (s = 0,
            r = t.length; s < r; s++)
                a = t[s],
                a.label = ie(e.callback, [a.value, s, t], this)
        }
        afterTickToLabelConversion() {
            ie(this.options.afterTickToLabelConversion, [this])
        }
        beforeCalculateLabelRotation() {
            ie(this.options.beforeCalculateLabelRotation, [this])
        }
        calculateLabelRotation() {
            let t = this.options, e = t.ticks, s = this.ticks.length, r = e.minRotation || 0, a = e.maxRotation, l = r, u, d, p;
            if (!this._isVisible() || !e.display || r >= a || s <= 1 || !this.isHorizontal()) {
                this.labelRotation = r;
                return
            }
            let b = this._getLabelSizes()
              , E = b.widest.width
              , x = b.highest.height
              , w = be(this.chart.width - E, 0, this.maxWidth);
            u = t.offset ? this.maxWidth / s : w / (s - 1),
            E + 6 > u && (u = w / (s - (t.offset ? .5 : 1)),
            d = this.maxHeight - Eo(t.grid) - e.padding - cg(t.title, this.chart.options.font),
            p = Math.sqrt(E * E + x * x),
            l = Wa(Math.min(Math.asin(be((b.highest.height + 6) / u, -1, 1)), Math.asin(be(d / p, -1, 1)) - Math.asin(be(x / p, -1, 1)))),
            l = Math.max(r, Math.min(a, l))),
            this.labelRotation = l
        }
        afterCalculateLabelRotation() {
            ie(this.options.afterCalculateLabelRotation, [this])
        }
        afterAutoSkip() {}
        beforeFit() {
            ie(this.options.beforeFit, [this])
        }
        fit() {
            let t = {
                width: 0,
                height: 0
            }
              , {chart: e, options: {ticks: s, title: r, grid: a}} = this
              , l = this._isVisible()
              , u = this.isHorizontal();
            if (l) {
                let d = cg(r, e.options.font);
                if (u ? (t.width = this.maxWidth,
                t.height = Eo(a) + d) : (t.height = this.maxHeight,
                t.width = Eo(a) + d),
                s.display && this.ticks.length) {
                    let {first: p, last: b, widest: E, highest: x} = this._getLabelSizes()
                      , w = s.padding * 2
                      , C = _i(this.labelRotation)
                      , I = Math.cos(C)
                      , L = Math.sin(C);
                    if (u) {
                        let k = s.mirror ? 0 : L * E.width + I * x.height;
                        t.height = Math.min(this.maxHeight, t.height + k + w)
                    } else {
                        let k = s.mirror ? 0 : I * E.width + L * x.height;
                        t.width = Math.min(this.maxWidth, t.width + k + w)
                    }
                    this._calculatePadding(p, b, L, I)
                }
            }
            this._handleMargins(),
            u ? (this.width = this._length = e.width - this._margins.left - this._margins.right,
            this.height = t.height) : (this.width = t.width,
            this.height = this._length = e.height - this._margins.top - this._margins.bottom)
        }
        _calculatePadding(t, e, s, r) {
            let {ticks: {align: a, padding: l}, position: u} = this.options
              , d = this.labelRotation !== 0
              , p = u !== "top" && this.axis === "x";
            if (this.isHorizontal()) {
                let b = this.getPixelForTick(0) - this.left
                  , E = this.right - this.getPixelForTick(this.ticks.length - 1)
                  , x = 0
                  , w = 0;
                d ? p ? (x = r * t.width,
                w = s * e.height) : (x = s * t.height,
                w = r * e.width) : a === "start" ? w = e.width : a === "end" ? x = t.width : a !== "inner" && (x = t.width / 2,
                w = e.width / 2),
                this.paddingLeft = Math.max((x - b + l) * this.width / (this.width - b), 0),
                this.paddingRight = Math.max((w - E + l) * this.width / (this.width - E), 0)
            } else {
                let b = e.height / 2
                  , E = t.height / 2;
                a === "start" ? (b = 0,
                E = t.height) : a === "end" && (b = e.height,
                E = 0),
                this.paddingTop = b + l,
                this.paddingBottom = E + l
            }
        }
        _handleMargins() {
            this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left),
            this._margins.top = Math.max(this.paddingTop, this._margins.top),
            this._margins.right = Math.max(this.paddingRight, this._margins.right),
            this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom))
        }
        afterFit() {
            ie(this.options.afterFit, [this])
        }
        isHorizontal() {
            let {axis: t, position: e} = this.options;
            return e === "top" || e === "bottom" || t === "x"
        }
        isFullSize() {
            return this.options.fullSize
        }
        _convertTicksToLabels(t) {
            this.beforeTickToLabelConversion(),
            this.generateTickLabels(t);
            let e, s;
            for (e = 0,
            s = t.length; e < s; e++)
                zt(t[e].label) && (t.splice(e, 1),
                s--,
                e--);
            this.afterTickToLabelConversion()
        }
        _getLabelSizes() {
            let t = this._labelSizes;
            if (!t) {
                let e = this.options.ticks.sampleSize
                  , s = this.ticks;
                e < s.length && (s = lg(s, e)),
                this._labelSizes = t = this._computeLabelSizes(s, s.length)
            }
            return t
        }
        _computeLabelSizes(t, e) {
            let {ctx: s, _longestTextCache: r} = this, a = [], l = [], u = 0, d = 0, p, b, E, x, w, C, I, L, k, F, z;
            for (p = 0; p < e; ++p) {
                if (x = t[p].label,
                w = this._resolveTickFontOptions(p),
                s.font = C = w.string,
                I = r[C] = r[C] || {
                    data: {},
                    gc: []
                },
                L = w.lineHeight,
                k = F = 0,
                !zt(x) && !ee(x))
                    k = go(s, I.data, I.gc, k, x),
                    F = L;
                else if (ee(x))
                    for (b = 0,
                    E = x.length; b < E; ++b)
                        z = x[b],
                        !zt(z) && !ee(z) && (k = go(s, I.data, I.gc, k, z),
                        F += L);
                a.push(k),
                l.push(F),
                u = Math.max(k, u),
                d = Math.max(F, d)
            }
            sE(r, e);
            let j = a.indexOf(u)
              , H = l.indexOf(d)
              , f = o(Y => ({
                width: a[Y] || 0,
                height: l[Y] || 0
            }), "valueAt");
            return {
                first: f(0),
                last: f(e - 1),
                widest: f(j),
                highest: f(H),
                widths: a,
                heights: l
            }
        }
        getLabelForValue(t) {
            return t
        }
        getPixelForValue(t, e) {
            return NaN
        }
        getValueForPixel(t) {}
        getPixelForTick(t) {
            let e = this.ticks;
            return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value)
        }
        getPixelForDecimal(t) {
            this._reversePixels && (t = 1 - t);
            let e = this._startPixel + t * this._length;
            return xp(this._alignToPixels ? Bn(this.chart, e, 0) : e)
        }
        getDecimalForPixel(t) {
            let e = (t - this._startPixel) / this._length;
            return this._reversePixels ? 1 - e : e
        }
        getBasePixel() {
            return this.getPixelForValue(this.getBaseValue())
        }
        getBaseValue() {
            let {min: t, max: e} = this;
            return t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0
        }
        getContext(t) {
            let e = this.ticks || [];
            if (t >= 0 && t < e.length) {
                let s = e[t];
                return s.$context || (s.$context = oE(this.getContext(), t, s))
            }
            return this.$context || (this.$context = rE(this.chart.getContext(), this))
        }
        _tickSize() {
            let t = this.options.ticks
              , e = _i(this.labelRotation)
              , s = Math.abs(Math.cos(e))
              , r = Math.abs(Math.sin(e))
              , a = this._getLabelSizes()
              , l = t.autoSkipPadding || 0
              , u = a ? a.widest.width + l : 0
              , d = a ? a.highest.height + l : 0;
            return this.isHorizontal() ? d * s > u * r ? u / s : d / r : d * r < u * s ? d / s : u / r
        }
        _isVisible() {
            let t = this.options.display;
            return t !== "auto" ? !!t : this.getMatchingVisibleMetas().length > 0
        }
        _computeGridLineItems(t) {
            let e = this.axis, s = this.chart, r = this.options, {grid: a, position: l} = r, u = a.offset, d = this.isHorizontal(), b = this.ticks.length + (u ? 1 : 0), E = Eo(a), x = [], w = a.setContext(this.getContext()), C = w.drawBorder ? w.borderWidth : 0, I = C / 2, L = o(function(wt) {
                return Bn(s, wt, C)
            }, "alignBorderValue"), k, F, z, j, H, f, Y, Q, ot, mt, bt, ft;
            if (l === "top")
                k = L(this.bottom),
                f = this.bottom - E,
                Q = k - I,
                mt = L(t.top) + I,
                ft = t.bottom;
            else if (l === "bottom")
                k = L(this.top),
                mt = t.top,
                ft = L(t.bottom) - I,
                f = k + I,
                Q = this.top + E;
            else if (l === "left")
                k = L(this.right),
                H = this.right - E,
                Y = k - I,
                ot = L(t.left) + I,
                bt = t.right;
            else if (l === "right")
                k = L(this.left),
                ot = t.left,
                bt = L(t.right) - I,
                H = k + I,
                Y = this.left + E;
            else if (e === "x") {
                if (l === "center")
                    k = L((t.top + t.bottom) / 2 + .5);
                else if (Ht(l)) {
                    let wt = Object.keys(l)[0]
                      , Nt = l[wt];
                    k = L(this.chart.scales[wt].getPixelForValue(Nt))
                }
                mt = t.top,
                ft = t.bottom,
                f = k + I,
                Q = f + E
            } else if (e === "y") {
                if (l === "center")
                    k = L((t.left + t.right) / 2);
                else if (Ht(l)) {
                    let wt = Object.keys(l)[0]
                      , Nt = l[wt];
                    k = L(this.chart.scales[wt].getPixelForValue(Nt))
                }
                H = k - I,
                Y = H - E,
                ot = t.left,
                bt = t.right
            }
            let $t = It(r.ticks.maxTicksLimit, b)
              , Ut = Math.max(1, Math.ceil(b / $t));
            for (F = 0; F < b; F += Ut) {
                let wt = a.setContext(this.getContext(F))
                  , Nt = wt.lineWidth
                  , Xt = wt.color
                  , pe = wt.borderDash || []
                  , Ne = wt.borderDashOffset
                  , xe = wt.tickWidth
                  , ci = wt.tickColor
                  , re = wt.tickBorderDash || []
                  , Ke = wt.tickBorderDashOffset;
                z = nE(this, F, u),
                z !== void 0 && (j = Bn(s, z, Nt),
                d ? H = Y = ot = bt = j : f = Q = mt = ft = j,
                x.push({
                    tx1: H,
                    ty1: f,
                    tx2: Y,
                    ty2: Q,
                    x1: ot,
                    y1: mt,
                    x2: bt,
                    y2: ft,
                    width: Nt,
                    color: Xt,
                    borderDash: pe,
                    borderDashOffset: Ne,
                    tickWidth: xe,
                    tickColor: ci,
                    tickBorderDash: re,
                    tickBorderDashOffset: Ke
                }))
            }
            return this._ticksLength = b,
            this._borderValue = k,
            x
        }
        _computeLabelItems(t) {
            let e = this.axis, s = this.options, {position: r, ticks: a} = s, l = this.isHorizontal(), u = this.ticks, {align: d, crossAlign: p, padding: b, mirror: E} = a, x = Eo(s.grid), w = x + b, C = E ? -b : w, I = -_i(this.labelRotation), L = [], k, F, z, j, H, f, Y, Q, ot, mt, bt, ft, $t = "middle";
            if (r === "top")
                f = this.bottom - C,
                Y = this._getXAxisLabelAlignment();
            else if (r === "bottom")
                f = this.top + C,
                Y = this._getXAxisLabelAlignment();
            else if (r === "left") {
                let wt = this._getYAxisLabelAlignment(x);
                Y = wt.textAlign,
                H = wt.x
            } else if (r === "right") {
                let wt = this._getYAxisLabelAlignment(x);
                Y = wt.textAlign,
                H = wt.x
            } else if (e === "x") {
                if (r === "center")
                    f = (t.top + t.bottom) / 2 + w;
                else if (Ht(r)) {
                    let wt = Object.keys(r)[0]
                      , Nt = r[wt];
                    f = this.chart.scales[wt].getPixelForValue(Nt) + w
                }
                Y = this._getXAxisLabelAlignment()
            } else if (e === "y") {
                if (r === "center")
                    H = (t.left + t.right) / 2 - w;
                else if (Ht(r)) {
                    let wt = Object.keys(r)[0]
                      , Nt = r[wt];
                    H = this.chart.scales[wt].getPixelForValue(Nt)
                }
                Y = this._getYAxisLabelAlignment(x).textAlign
            }
            e === "y" && (d === "start" ? $t = "top" : d === "end" && ($t = "bottom"));
            let Ut = this._getLabelSizes();
            for (k = 0,
            F = u.length; k < F; ++k) {
                z = u[k],
                j = z.label;
                let wt = a.setContext(this.getContext(k));
                Q = this.getPixelForTick(k) + a.labelOffset,
                ot = this._resolveTickFontOptions(k),
                mt = ot.lineHeight,
                bt = ee(j) ? j.length : 1;
                let Nt = bt / 2
                  , Xt = wt.color
                  , pe = wt.textStrokeColor
                  , Ne = wt.textStrokeWidth
                  , xe = Y;
                l ? (H = Q,
                Y === "inner" && (k === F - 1 ? xe = this.options.reverse ? "left" : "right" : k === 0 ? xe = this.options.reverse ? "right" : "left" : xe = "center"),
                r === "top" ? p === "near" || I !== 0 ? ft = -bt * mt + mt / 2 : p === "center" ? ft = -Ut.highest.height / 2 - Nt * mt + mt : ft = -Ut.highest.height + mt / 2 : p === "near" || I !== 0 ? ft = mt / 2 : p === "center" ? ft = Ut.highest.height / 2 - Nt * mt : ft = Ut.highest.height - bt * mt,
                E && (ft *= -1)) : (f = Q,
                ft = (1 - bt) * mt / 2);
                let ci;
                if (wt.showLabelBackdrop) {
                    let re = Me(wt.backdropPadding)
                      , Ke = Ut.heights[k]
                      , Ye = Ut.widths[k]
                      , Li = f + ft - re.top
                      , Di = H - re.left;
                    switch ($t) {
                    case "middle":
                        Li -= Ke / 2;
                        break;
                    case "bottom":
                        Li -= Ke;
                        break
                    }
                    switch (Y) {
                    case "center":
                        Di -= Ye / 2;
                        break;
                    case "right":
                        Di -= Ye;
                        break
                    }
                    ci = {
                        left: Di,
                        top: Li,
                        width: Ye + re.width,
                        height: Ke + re.height,
                        color: wt.backdropColor
                    }
                }
                L.push({
                    rotation: I,
                    label: j,
                    font: ot,
                    color: Xt,
                    strokeColor: pe,
                    strokeWidth: Ne,
                    textOffset: ft,
                    textAlign: xe,
                    textBaseline: $t,
                    translation: [H, f],
                    backdrop: ci
                })
            }
            return L
        }
        _getXAxisLabelAlignment() {
            let {position: t, ticks: e} = this.options;
            if (-_i(this.labelRotation))
                return t === "top" ? "left" : "right";
            let r = "center";
            return e.align === "start" ? r = "left" : e.align === "end" ? r = "right" : e.align === "inner" && (r = "inner"),
            r
        }
        _getYAxisLabelAlignment(t) {
            let {position: e, ticks: {crossAlign: s, mirror: r, padding: a}} = this.options, l = this._getLabelSizes(), u = t + a, d = l.widest.width, p, b;
            return e === "left" ? r ? (b = this.right + a,
            s === "near" ? p = "left" : s === "center" ? (p = "center",
            b += d / 2) : (p = "right",
            b += d)) : (b = this.right - u,
            s === "near" ? p = "right" : s === "center" ? (p = "center",
            b -= d / 2) : (p = "left",
            b = this.left)) : e === "right" ? r ? (b = this.left + a,
            s === "near" ? p = "right" : s === "center" ? (p = "center",
            b -= d / 2) : (p = "left",
            b -= d)) : (b = this.left + u,
            s === "near" ? p = "left" : s === "center" ? (p = "center",
            b += d / 2) : (p = "right",
            b = this.right)) : p = "right",
            {
                textAlign: p,
                x: b
            }
        }
        _computeLabelArea() {
            if (this.options.ticks.mirror)
                return;
            let t = this.chart
              , e = this.options.position;
            if (e === "left" || e === "right")
                return {
                    top: 0,
                    left: this.left,
                    bottom: t.height,
                    right: this.right
                };
            if (e === "top" || e === "bottom")
                return {
                    top: this.top,
                    left: 0,
                    bottom: this.bottom,
                    right: t.width
                }
        }
        drawBackground() {
            let {ctx: t, options: {backgroundColor: e}, left: s, top: r, width: a, height: l} = this;
            e && (t.save(),
            t.fillStyle = e,
            t.fillRect(s, r, a, l),
            t.restore())
        }
        getLineWidthForValue(t) {
            let e = this.options.grid;
            if (!this._isVisible() || !e.display)
                return 0;
            let r = this.ticks.findIndex(a => a.value === t);
            return r >= 0 ? e.setContext(this.getContext(r)).lineWidth : 0
        }
        drawGrid(t) {
            let e = this.options.grid, s = this.ctx, r = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t)), a, l, u = o( (d, p, b) => {
                !b.width || !b.color || (s.save(),
                s.lineWidth = b.width,
                s.strokeStyle = b.color,
                s.setLineDash(b.borderDash || []),
                s.lineDashOffset = b.borderDashOffset,
                s.beginPath(),
                s.moveTo(d.x, d.y),
                s.lineTo(p.x, p.y),
                s.stroke(),
                s.restore())
            }
            , "drawLine");
            if (e.display)
                for (a = 0,
                l = r.length; a < l; ++a) {
                    let d = r[a];
                    e.drawOnChartArea && u({
                        x: d.x1,
                        y: d.y1
                    }, {
                        x: d.x2,
                        y: d.y2
                    }, d),
                    e.drawTicks && u({
                        x: d.tx1,
                        y: d.ty1
                    }, {
                        x: d.tx2,
                        y: d.ty2
                    }, {
                        color: d.tickColor,
                        width: d.tickWidth,
                        borderDash: d.tickBorderDash,
                        borderDashOffset: d.tickBorderDashOffset
                    })
                }
        }
        drawBorder() {
            let {chart: t, ctx: e, options: {grid: s}} = this
              , r = s.setContext(this.getContext())
              , a = s.drawBorder ? r.borderWidth : 0;
            if (!a)
                return;
            let l = s.setContext(this.getContext(0)).lineWidth, u = this._borderValue, d, p, b, E;
            this.isHorizontal() ? (d = Bn(t, this.left, a) - a / 2,
            p = Bn(t, this.right, l) + l / 2,
            b = E = u) : (b = Bn(t, this.top, a) - a / 2,
            E = Bn(t, this.bottom, l) + l / 2,
            d = p = u),
            e.save(),
            e.lineWidth = r.borderWidth,
            e.strokeStyle = r.borderColor,
            e.beginPath(),
            e.moveTo(d, b),
            e.lineTo(p, E),
            e.stroke(),
            e.restore()
        }
        drawLabels(t) {
            if (!this.options.ticks.display)
                return;
            let s = this.ctx
              , r = this._computeLabelArea();
            r && bo(s, r);
            let a = this._labelItems || (this._labelItems = this._computeLabelItems(t)), l, u;
            for (l = 0,
            u = a.length; l < u; ++l) {
                let d = a[l]
                  , p = d.font
                  , b = d.label;
                d.backdrop && (s.fillStyle = d.backdrop.color,
                s.fillRect(d.backdrop.left, d.backdrop.top, d.backdrop.width, d.backdrop.height));
                let E = d.textOffset;
                Hn(s, b, 0, E, p, d)
            }
            r && yo(s)
        }
        drawTitle() {
            let {ctx: t, options: {position: e, title: s, reverse: r}} = this;
            if (!s.display)
                return;
            let a = ge(s.font)
              , l = Me(s.padding)
              , u = s.align
              , d = a.lineHeight / 2;
            e === "bottom" || e === "center" || Ht(e) ? (d += l.bottom,
            ee(s.text) && (d += a.lineHeight * (s.text.length - 1))) : d += l.top;
            let {titleX: p, titleY: b, maxWidth: E, rotation: x} = lE(this, d, e, u);
            Hn(t, s.text, 0, 0, a, {
                color: s.color,
                maxWidth: E,
                rotation: x,
                textAlign: aE(u, e, r),
                textBaseline: "middle",
                translation: [p, b]
            })
        }
        draw(t) {
            this._isVisible() && (this.drawBackground(),
            this.drawGrid(t),
            this.drawBorder(),
            this.drawTitle(),
            this.drawLabels(t))
        }
        _layers() {
            let t = this.options
              , e = t.ticks && t.ticks.z || 0
              , s = It(t.grid && t.grid.z, -1);
            return !this._isVisible() || this.draw !== n.prototype.draw ? [{
                z: e,
                draw: o(r => {
                    this.draw(r)
                }
                , "draw")
            }] : [{
                z: s,
                draw: o(r => {
                    this.drawBackground(),
                    this.drawGrid(r),
                    this.drawTitle()
                }
                , "draw")
            }, {
                z: s + 1,
                draw: o( () => {
                    this.drawBorder()
                }
                , "draw")
            }, {
                z: e,
                draw: o(r => {
                    this.drawLabels(r)
                }
                , "draw")
            }]
        }
        getMatchingVisibleMetas(t) {
            let e = this.chart.getSortedVisibleDatasetMetas(), s = this.axis + "AxisID", r = [], a, l;
            for (a = 0,
            l = e.length; a < l; ++a) {
                let u = e[a];
                u[s] === this.id && (!t || u.type === t) && r.push(u)
            }
            return r
        }
        _resolveTickFontOptions(t) {
            let e = this.options.ticks.setContext(this.getContext(t));
            return ge(e.font)
        }
        _maxDigits() {
            let t = this._resolveTickFontOptions(0).lineHeight;
            return (this.isHorizontal() ? this.width : this.height) / t
        }
    }
      , hr = class {
        static{o(this, "TypedRegistry")
        }constructor(t, e, s) {
            this.type = t,
            this.scope = e,
            this.override = s,
            this.items = Object.create(null)
        }
        isForType(t) {
            return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype)
        }
        register(t) {
            let e = Object.getPrototypeOf(t), s;
            hE(e) && (s = this.register(e));
            let r = this.items
              , a = t.id
              , l = this.scope + "." + a;
            if (!a)
                throw new Error("class does not have id: " + t);
            return a in r || (r[a] = t,
            cE(t, l, s),
            this.override && jt.override(t.id, t.overrides)),
            l
        }
        get(t) {
            return this.items[t]
        }
        unregister(t) {
            let e = this.items
              , s = t.id
              , r = this.scope;
            s in e && delete e[s],
            r && s in jt[r] && (delete jt[r][s],
            this.override && delete Vn[s])
        }
    }
    ;
    function cE(n, t, e) {
        let s = er(Object.create(null), [e ? jt.get(e) : {}, jt.get(t), n.defaults]);
        jt.set(t, s),
        n.defaultRoutes && uE(t, n.defaultRoutes),
        n.descriptors && jt.describe(t, n.descriptors)
    }
    o(cE, "registerDefaults");
    function uE(n, t) {
        Object.keys(t).forEach(e => {
            let s = e.split(".")
              , r = s.pop()
              , a = [n].concat(s).join(".")
              , l = t[e].split(".")
              , u = l.pop()
              , d = l.join(".");
            jt.route(a, r, d, u)
        }
        )
    }
    o(uE, "routeDefaults");
    function hE(n) {
        return "id"in n && "defaults"in n
    }
    o(hE, "isIChartComponent");
    var hd = class {
        static{o(this, "Registry")
        }constructor() {
            this.controllers = new hr(ai,"datasets",!0),
            this.elements = new hr(li,"elements"),
            this.plugins = new hr(Object,"plugins"),
            this.scales = new hr(ys,"scales"),
            this._typedRegistries = [this.controllers, this.scales, this.elements]
        }
        add(...t) {
            this._each("register", t)
        }
        remove(...t) {
            this._each("unregister", t)
        }
        addControllers(...t) {
            this._each("register", t, this.controllers)
        }
        addElements(...t) {
            this._each("register", t, this.elements)
        }
        addPlugins(...t) {
            this._each("register", t, this.plugins)
        }
        addScales(...t) {
            this._each("register", t, this.scales)
        }
        getController(t) {
            return this._get(t, this.controllers, "controller")
        }
        getElement(t) {
            return this._get(t, this.elements, "element")
        }
        getPlugin(t) {
            return this._get(t, this.plugins, "plugin")
        }
        getScale(t) {
            return this._get(t, this.scales, "scale")
        }
        removeControllers(...t) {
            this._each("unregister", t, this.controllers)
        }
        removeElements(...t) {
            this._each("unregister", t, this.elements)
        }
        removePlugins(...t) {
            this._each("unregister", t, this.plugins)
        }
        removeScales(...t) {
            this._each("unregister", t, this.scales)
        }
        _each(t, e, s) {
            [...e].forEach(r => {
                let a = s || this._getRegistryForType(r);
                s || a.isForType(r) || a === this.plugins && r.id ? this._exec(t, a, r) : Jt(r, l => {
                    let u = s || this._getRegistryForType(l);
                    this._exec(t, u, l)
                }
                )
            }
            )
        }
        _exec(t, e, s) {
            let r = ja(t);
            ie(s["before" + r], [], s),
            e[t](s),
            ie(s["after" + r], [], s)
        }
        _getRegistryForType(t) {
            for (let e = 0; e < this._typedRegistries.length; e++) {
                let s = this._typedRegistries[e];
                if (s.isForType(t))
                    return s
            }
            return this.plugins
        }
        _get(t, e, s) {
            let r = e.get(t);
            if (r === void 0)
                throw new Error('"' + t + '" is not a registered ' + s + ".");
            return r
        }
    }
      , Xi = new hd
      , vr = class extends ai {
        static{o(this, "ScatterController")
        }update(t) {
            let e = this._cachedMeta
              , {data: s=[]} = e
              , r = this.chart._animationsDisabled
              , {start: a, count: l} = Rh(e, s, r);
            if (this._drawStart = a,
            this._drawCount = l,
            Ih(e) && (a = 0,
            l = s.length),
            this.options.showLine) {
                let {dataset: u, _dataset: d} = e;
                u._chart = this.chart,
                u._datasetIndex = this.index,
                u._decimated = !!d._decimated,
                u.points = s;
                let p = this.resolveDatasetElementOptions(t);
                p.segment = this.options.segment,
                this.updateElement(u, void 0, {
                    animated: !r,
                    options: p
                }, t)
            }
            this.updateElements(s, a, l, t)
        }
        addElements() {
            let {showLine: t} = this.options;
            !this.datasetElementType && t && (this.datasetElementType = Xi.getElement("line")),
            super.addElements()
        }
        updateElements(t, e, s, r) {
            let a = r === "reset"
              , {iScale: l, vScale: u, _stacked: d, _dataset: p} = this._cachedMeta
              , b = this.resolveDataElementOptions(e, r)
              , E = this.getSharedOptions(b)
              , x = this.includeOptions(r, E)
              , w = l.axis
              , C = u.axis
              , {spanGaps: I, segment: L} = this.options
              , k = ms(I) ? I : Number.POSITIVE_INFINITY
              , F = this.chart._animationsDisabled || a || r === "none"
              , z = e > 0 && this.getParsed(e - 1);
            for (let j = e; j < e + s; ++j) {
                let H = t[j]
                  , f = this.getParsed(j)
                  , Y = F ? H : {}
                  , Q = zt(f[C])
                  , ot = Y[w] = l.getPixelForValue(f[w], j)
                  , mt = Y[C] = a || Q ? u.getBasePixel() : u.getPixelForValue(d ? this.applyStack(u, f, d) : f[C], j);
                Y.skip = isNaN(ot) || isNaN(mt) || Q,
                Y.stop = j > 0 && Math.abs(f[w] - z[w]) > k,
                L && (Y.parsed = f,
                Y.raw = p.data[j]),
                x && (Y.options = E || this.resolveDataElementOptions(j, H.active ? "active" : r)),
                F || this.updateElement(H, j, Y, r),
                z = f
            }
            this.updateSharedOptions(E, r, b)
        }
        getMaxOverflow() {
            let t = this._cachedMeta
              , e = t.data || [];
            if (!this.options.showLine) {
                let u = 0;
                for (let d = e.length - 1; d >= 0; --d)
                    u = Math.max(u, e[d].size(this.resolveDataElementOptions(d)) / 2);
                return u > 0 && u
            }
            let s = t.dataset
              , r = s.options && s.options.borderWidth || 0;
            if (!e.length)
                return r;
            let a = e[0].size(this.resolveDataElementOptions(0))
              , l = e[e.length - 1].size(this.resolveDataElementOptions(e.length - 1));
            return Math.max(r, a, l) / 2
        }
    }
    ;
    vr.id = "scatter";
    vr.defaults = {
        datasetElementType: !1,
        dataElementType: "point",
        showLine: !1,
        fill: !1
    };
    vr.overrides = {
        interaction: {
            mode: "point"
        },
        plugins: {
            tooltip: {
                callbacks: {
                    title() {
                        return ""
                    },
                    label(n) {
                        return "(" + n.label + ", " + n.formattedValue + ")"
                    }
                }
            }
        },
        scales: {
            x: {
                type: "linear"
            },
            y: {
                type: "linear"
            }
        }
    };
    var dE = Object.freeze({
        __proto__: null,
        BarController: dr,
        BubbleController: fr,
        DoughnutController: zn,
        LineController: pr,
        PolarAreaController: gr,
        PieController: Ao,
        RadarController: mr,
        ScatterController: vr
    });
    function bs() {
        throw new Error("This method is not implemented: Check that a complete date adapter is provided.")
    }
    o(bs, "abstract");
    var ko = class {
        static{o(this, "DateAdapter")
        }constructor(t) {
            this.options = t || {}
        }
        init(t) {}
        formats() {
            return bs()
        }
        parse(t, e) {
            return bs()
        }
        format(t, e) {
            return bs()
        }
        add(t, e, s) {
            return bs()
        }
        diff(t, e, s) {
            return bs()
        }
        startOf(t, e, s) {
            return bs()
        }
        endOf(t, e) {
            return bs()
        }
    }
    ;
    ko.override = function(n) {
        Object.assign(ko.prototype, n)
    }
    ;
    var fE = {
        _date: ko
    };
    function pE(n, t, e, s) {
        let {controller: r, data: a, _sorted: l} = n
          , u = r._cachedMeta.iScale;
        if (u && t === u.axis && t !== "r" && l && a.length) {
            let d = u._reversePixels ? wp : zi;
            if (s) {
                if (r._sharedOptions) {
                    let p = a[0]
                      , b = typeof p.getRange == "function" && p.getRange(t);
                    if (b) {
                        let E = d(a, t, e - b)
                          , x = d(a, t, e + b);
                        return {
                            lo: E.lo,
                            hi: x.hi
                        }
                    }
                }
            } else
                return d(a, t, e)
        }
        return {
            lo: 0,
            hi: a.length - 1
        }
    }
    o(pE, "binarySearch");
    function Io(n, t, e, s, r) {
        let a = n.getSortedVisibleDatasetMetas()
          , l = e[t];
        for (let u = 0, d = a.length; u < d; ++u) {
            let {index: p, data: b} = a[u]
              , {lo: E, hi: x} = pE(a[u], t, l, r);
            for (let w = E; w <= x; ++w) {
                let C = b[w];
                C.skip || s(C, p, w)
            }
        }
    }
    o(Io, "evaluateInteractionItems");
    function gE(n) {
        let t = n.indexOf("x") !== -1
          , e = n.indexOf("y") !== -1;
        return function(s, r) {
            let a = t ? Math.abs(s.x - r.x) : 0
              , l = e ? Math.abs(s.y - r.y) : 0;
            return Math.sqrt(Math.pow(a, 2) + Math.pow(l, 2))
        }
    }
    o(gE, "getDistanceMetricForAxis");
    function nd(n, t, e, s, r) {
        let a = [];
        return !r && !n.isPointInArea(t) || Io(n, e, t, o(function(u, d, p) {
            !r && !ir(u, n.chartArea, 0) || u.inRange(t.x, t.y, s) && a.push({
                element: u,
                datasetIndex: d,
                index: p
            })
        }, "evaluationFunc"), !0),
        a
    }
    o(nd, "getIntersectItems");
    function mE(n, t, e, s) {
        let r = [];
        function a(l, u, d) {
            let {startAngle: p, endAngle: b} = l.getProps(["startAngle", "endAngle"], s)
              , {angle: E} = Mh(l, {
                x: t.x,
                y: t.y
            });
            or(E, p, b) && r.push({
                element: l,
                datasetIndex: u,
                index: d
            })
        }
        return o(a, "evaluationFunc"),
        Io(n, e, t, a),
        r
    }
    o(mE, "getNearestRadialItems");
    function vE(n, t, e, s, r, a) {
        let l = []
          , u = gE(e)
          , d = Number.POSITIVE_INFINITY;
        function p(b, E, x) {
            let w = b.inRange(t.x, t.y, r);
            if (s && !w)
                return;
            let C = b.getCenterPoint(r);
            if (!(!!a || n.isPointInArea(C)) && !w)
                return;
            let L = u(t, C);
            L < d ? (l = [{
                element: b,
                datasetIndex: E,
                index: x
            }],
            d = L) : L === d && l.push({
                element: b,
                datasetIndex: E,
                index: x
            })
        }
        return o(p, "evaluationFunc"),
        Io(n, e, t, p),
        l
    }
    o(vE, "getNearestCartesianItems");
    function sd(n, t, e, s, r, a) {
        return !a && !n.isPointInArea(t) ? [] : e === "r" && !s ? mE(n, t, e, r) : vE(n, t, e, s, r, a)
    }
    o(sd, "getNearestItems");
    function ug(n, t, e, s, r) {
        let a = []
          , l = e === "x" ? "inXRange" : "inYRange"
          , u = !1;
        return Io(n, e, t, (d, p, b) => {
            d[l](t[e], r) && (a.push({
                element: d,
                datasetIndex: p,
                index: b
            }),
            u = u || d.inRange(t.x, t.y, r))
        }
        ),
        s && !u ? [] : a
    }
    o(ug, "getAxisItems");
    var bE = {
        evaluateInteractionItems: Io,
        modes: {
            index(n, t, e, s) {
                let r = Wn(t, n)
                  , a = e.axis || "x"
                  , l = e.includeInvisible || !1
                  , u = e.intersect ? nd(n, r, a, s, l) : sd(n, r, a, !1, s, l)
                  , d = [];
                return u.length ? (n.getSortedVisibleDatasetMetas().forEach(p => {
                    let b = u[0].index
                      , E = p.data[b];
                    E && !E.skip && d.push({
                        element: E,
                        datasetIndex: p.index,
                        index: b
                    })
                }
                ),
                d) : []
            },
            dataset(n, t, e, s) {
                let r = Wn(t, n)
                  , a = e.axis || "xy"
                  , l = e.includeInvisible || !1
                  , u = e.intersect ? nd(n, r, a, s, l) : sd(n, r, a, !1, s, l);
                if (u.length > 0) {
                    let d = u[0].datasetIndex
                      , p = n.getDatasetMeta(d).data;
                    u = [];
                    for (let b = 0; b < p.length; ++b)
                        u.push({
                            element: p[b],
                            datasetIndex: d,
                            index: b
                        })
                }
                return u
            },
            point(n, t, e, s) {
                let r = Wn(t, n)
                  , a = e.axis || "xy"
                  , l = e.includeInvisible || !1;
                return nd(n, r, a, s, l)
            },
            nearest(n, t, e, s) {
                let r = Wn(t, n)
                  , a = e.axis || "xy"
                  , l = e.includeInvisible || !1;
                return sd(n, r, a, e.intersect, s, l)
            },
            x(n, t, e, s) {
                let r = Wn(t, n);
                return ug(n, r, "x", e.intersect, s)
            },
            y(n, t, e, s) {
                let r = Wn(t, n);
                return ug(n, r, "y", e.intersect, s)
            }
        }
    }
      , zg = ["left", "top", "right", "bottom"];
    function So(n, t) {
        return n.filter(e => e.pos === t)
    }
    o(So, "filterByPosition");
    function hg(n, t) {
        return n.filter(e => zg.indexOf(e.pos) === -1 && e.box.axis === t)
    }
    o(hg, "filterDynamicPositionByAxis");
    function To(n, t) {
        return n.sort( (e, s) => {
            let r = t ? s : e
              , a = t ? e : s;
            return r.weight === a.weight ? r.index - a.index : r.weight - a.weight
        }
        )
    }
    o(To, "sortByWeight");
    function yE(n) {
        let t = [], e, s, r, a, l, u;
        for (e = 0,
        s = (n || []).length; e < s; ++e)
            r = n[e],
            {position: a, options: {stack: l, stackWeight: u=1}} = r,
            t.push({
                index: e,
                box: r,
                pos: a,
                horizontal: r.isHorizontal(),
                weight: r.weight,
                stack: l && a + l,
                stackWeight: u
            });
        return t
    }
    o(yE, "wrapBoxes");
    function _E(n) {
        let t = {};
        for (let e of n) {
            let {stack: s, pos: r, stackWeight: a} = e;
            if (!s || !zg.includes(r))
                continue;
            let l = t[s] || (t[s] = {
                count: 0,
                placed: 0,
                weight: 0,
                size: 0
            });
            l.count++,
            l.weight += a
        }
        return t
    }
    o(_E, "buildStacks");
    function EE(n, t) {
        let e = _E(n), {vBoxMaxWidth: s, hBoxMaxHeight: r} = t, a, l, u;
        for (a = 0,
        l = n.length; a < l; ++a) {
            u = n[a];
            let {fullSize: d} = u.box
              , p = e[u.stack]
              , b = p && u.stackWeight / p.weight;
            u.horizontal ? (u.width = b ? b * s : d && t.availableWidth,
            u.height = r) : (u.width = s,
            u.height = b ? b * r : d && t.availableHeight)
        }
        return e
    }
    o(EE, "setLayoutDims");
    function SE(n) {
        let t = yE(n)
          , e = To(t.filter(p => p.box.fullSize), !0)
          , s = To(So(t, "left"), !0)
          , r = To(So(t, "right"))
          , a = To(So(t, "top"), !0)
          , l = To(So(t, "bottom"))
          , u = hg(t, "x")
          , d = hg(t, "y");
        return {
            fullSize: e,
            leftAndTop: s.concat(a),
            rightAndBottom: r.concat(d).concat(l).concat(u),
            chartArea: So(t, "chartArea"),
            vertical: s.concat(r).concat(d),
            horizontal: a.concat(l).concat(u)
        }
    }
    o(SE, "buildLayoutBoxes");
    function dg(n, t, e, s) {
        return Math.max(n[e], t[e]) + Math.max(n[s], t[s])
    }
    o(dg, "getCombinedMax");
    function Ug(n, t) {
        n.top = Math.max(n.top, t.top),
        n.left = Math.max(n.left, t.left),
        n.bottom = Math.max(n.bottom, t.bottom),
        n.right = Math.max(n.right, t.right)
    }
    o(Ug, "updateMaxPadding");
    function TE(n, t, e, s) {
        let {pos: r, box: a} = e
          , l = n.maxPadding;
        if (!Ht(r)) {
            e.size && (n[r] -= e.size);
            let E = s[e.stack] || {
                size: 0,
                count: 1
            };
            E.size = Math.max(E.size, e.horizontal ? a.height : a.width),
            e.size = E.size / E.count,
            n[r] += e.size
        }
        a.getPadding && Ug(l, a.getPadding());
        let u = Math.max(0, t.outerWidth - dg(l, n, "left", "right"))
          , d = Math.max(0, t.outerHeight - dg(l, n, "top", "bottom"))
          , p = u !== n.w
          , b = d !== n.h;
        return n.w = u,
        n.h = d,
        e.horizontal ? {
            same: p,
            other: b
        } : {
            same: b,
            other: p
        }
    }
    o(TE, "updateDims");
    function xE(n) {
        let t = n.maxPadding;
        function e(s) {
            let r = Math.max(t[s] - n[s], 0);
            return n[s] += r,
            r
        }
        o(e, "updatePos"),
        n.y += e("top"),
        n.x += e("left"),
        e("right"),
        e("bottom")
    }
    o(xE, "handleMaxPadding");
    function wE(n, t) {
        let e = t.maxPadding;
        function s(r) {
            let a = {
                left: 0,
                top: 0,
                right: 0,
                bottom: 0
            };
            return r.forEach(l => {
                a[l] = Math.max(t[l], e[l])
            }
            ),
            a
        }
        return o(s, "marginForPositions"),
        s(n ? ["left", "right"] : ["top", "bottom"])
    }
    o(wE, "getMargins");
    function wo(n, t, e, s) {
        let r = [], a, l, u, d, p, b;
        for (a = 0,
        l = n.length,
        p = 0; a < l; ++a) {
            u = n[a],
            d = u.box,
            d.update(u.width || t.w, u.height || t.h, wE(u.horizontal, t));
            let {same: E, other: x} = TE(t, e, u, s);
            p |= E && r.length,
            b = b || x,
            d.fullSize || r.push(u)
        }
        return p && wo(r, t, e, s) || b
    }
    o(wo, "fitBoxes");
    function Ja(n, t, e, s, r) {
        n.top = e,
        n.left = t,
        n.right = t + s,
        n.bottom = e + r,
        n.width = s,
        n.height = r
    }
    o(Ja, "setBoxDims");
    function fg(n, t, e, s) {
        let r = e.padding
          , {x: a, y: l} = t;
        for (let u of n) {
            let d = u.box
              , p = s[u.stack] || {
                count: 1,
                placed: 0,
                weight: 1
            }
              , b = u.stackWeight / p.weight || 1;
            if (u.horizontal) {
                let E = t.w * b
                  , x = p.size || d.height;
                si(p.start) && (l = p.start),
                d.fullSize ? Ja(d, r.left, l, e.outerWidth - r.right - r.left, x) : Ja(d, t.left + p.placed, l, E, x),
                p.start = l,
                p.placed += E,
                l = d.bottom
            } else {
                let E = t.h * b
                  , x = p.size || d.width;
                si(p.start) && (a = p.start),
                d.fullSize ? Ja(d, a, r.top, x, e.outerHeight - r.bottom - r.top) : Ja(d, a, t.top + p.placed, x, E),
                p.start = a,
                p.placed += E,
                a = d.right
            }
        }
        t.x = a,
        t.y = l
    }
    o(fg, "placeBoxes");
    jt.set("layout", {
        autoPadding: !0,
        padding: {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }
    });
    var Pe = {
        addBox(n, t) {
            n.boxes || (n.boxes = []),
            t.fullSize = t.fullSize || !1,
            t.position = t.position || "top",
            t.weight = t.weight || 0,
            t._layers = t._layers || function() {
                return [{
                    z: 0,
                    draw(e) {
                        t.draw(e)
                    }
                }]
            }
            ,
            n.boxes.push(t)
        },
        removeBox(n, t) {
            let e = n.boxes ? n.boxes.indexOf(t) : -1;
            e !== -1 && n.boxes.splice(e, 1)
        },
        configure(n, t, e) {
            t.fullSize = e.fullSize,
            t.position = e.position,
            t.weight = e.weight
        },
        update(n, t, e, s) {
            if (!n)
                return;
            let r = Me(n.options.layout.padding)
              , a = Math.max(t - r.width, 0)
              , l = Math.max(e - r.height, 0)
              , u = SE(n.boxes)
              , d = u.vertical
              , p = u.horizontal;
            Jt(n.boxes, I => {
                typeof I.beforeLayout == "function" && I.beforeLayout()
            }
            );
            let b = d.reduce( (I, L) => L.box.options && L.box.options.display === !1 ? I : I + 1, 0) || 1
              , E = Object.freeze({
                outerWidth: t,
                outerHeight: e,
                padding: r,
                availableWidth: a,
                availableHeight: l,
                vBoxMaxWidth: a / 2 / b,
                hBoxMaxHeight: l / 2
            })
              , x = Object.assign({}, r);
            Ug(x, Me(s));
            let w = Object.assign({
                maxPadding: x,
                w: a,
                h: l,
                x: r.left,
                y: r.top
            }, r)
              , C = EE(d.concat(p), E);
            wo(u.fullSize, w, E, C),
            wo(d, w, E, C),
            wo(p, w, E, C) && wo(d, w, E, C),
            xE(w),
            fg(u.leftAndTop, w, E, C),
            w.x += w.w,
            w.y += w.h,
            fg(u.rightAndBottom, w, E, C),
            n.chartArea = {
                left: w.left,
                top: w.top,
                right: w.left + w.w,
                bottom: w.top + w.h,
                height: w.h,
                width: w.w
            },
            Jt(u.chartArea, I => {
                let L = I.box;
                Object.assign(L, n.chartArea),
                L.update(w.w, w.h, {
                    left: 0,
                    top: 0,
                    right: 0,
                    bottom: 0
                })
            }
            )
        }
    }
      , rl = class {
        static{o(this, "BasePlatform")
        }acquireContext(t, e) {}
        releaseContext(t) {
            return !1
        }
        addEventListener(t, e, s) {}
        removeEventListener(t, e, s) {}
        getDevicePixelRatio() {
            return 1
        }
        getMaximumSize(t, e, s, r) {
            return e = Math.max(0, e || t.width),
            s = s || t.height,
            {
                width: e,
                height: Math.max(0, r ? Math.floor(e / r) : s)
            }
        }
        isAttached(t) {
            return !0
        }
        updateConfig(t) {}
    }
      , dd = class extends rl {
        static{o(this, "BasicPlatform")
        }acquireContext(t) {
            return t && t.getContext && t.getContext("2d") || null
        }
        updateConfig(t) {
            t.options.animation = !1
        }
    }
      , nl = "$chartjs"
      , CE = {
        touchstart: "mousedown",
        touchmove: "mousemove",
        touchend: "mouseup",
        pointerenter: "mouseenter",
        pointerdown: "mousedown",
        pointermove: "mousemove",
        pointerup: "mouseup",
        pointerleave: "mouseout",
        pointerout: "mouseout"
    }
      , pg = o(n => n === null || n === "", "isNullOrEmpty");
    function AE(n, t) {
        let e = n.style
          , s = n.getAttribute("height")
          , r = n.getAttribute("width");
        if (n[nl] = {
            initial: {
                height: s,
                width: r,
                style: {
                    display: e.display,
                    height: e.height,
                    width: e.width
                }
            }
        },
        e.display = e.display || "block",
        e.boxSizing = e.boxSizing || "border-box",
        pg(r)) {
            let a = Xh(n, "width");
            a !== void 0 && (n.width = a)
        }
        if (pg(s))
            if (n.style.height === "")
                n.height = n.width / (t || 2);
            else {
                let a = Xh(n, "height");
                a !== void 0 && (n.height = a)
            }
        return n
    }
    o(AE, "initCanvas");
    var Kg = Up ? {
        passive: !0
    } : !1;
    function kE(n, t, e) {
        n.addEventListener(t, e, Kg)
    }
    o(kE, "addListener");
    function ME(n, t, e) {
        n.canvas.removeEventListener(t, e, Kg)
    }
    o(ME, "removeListener");
    function OE(n, t) {
        let e = CE[n.type] || n.type
          , {x: s, y: r} = Wn(n, t);
        return {
            type: e,
            chart: t,
            native: n,
            x: s !== void 0 ? s : null,
            y: r !== void 0 ? r : null
        }
    }
    o(OE, "fromNativeEvent");
    function ol(n, t) {
        for (let e of n)
            if (e === t || e.contains(t))
                return !0
    }
    o(ol, "nodeListContains");
    function LE(n, t, e) {
        let s = n.canvas
          , r = new MutationObserver(a => {
            let l = !1;
            for (let u of a)
                l = l || ol(u.addedNodes, s),
                l = l && !ol(u.removedNodes, s);
            l && e()
        }
        );
        return r.observe(document, {
            childList: !0,
            subtree: !0
        }),
        r
    }
    o(LE, "createAttachObserver");
    function DE(n, t, e) {
        let s = n.canvas
          , r = new MutationObserver(a => {
            let l = !1;
            for (let u of a)
                l = l || ol(u.removedNodes, s),
                l = l && !ol(u.addedNodes, s);
            l && e()
        }
        );
        return r.observe(document, {
            childList: !0,
            subtree: !0
        }),
        r
    }
    o(DE, "createDetachObserver");
    var Mo = new Map
      , gg = 0;
    function Yg() {
        let n = window.devicePixelRatio;
        n !== gg && (gg = n,
        Mo.forEach( (t, e) => {
            e.currentDevicePixelRatio !== n && t()
        }
        ))
    }
    o(Yg, "onWindowResize");
    function PE(n, t) {
        Mo.size || window.addEventListener("resize", Yg),
        Mo.set(n, t)
    }
    o(PE, "listenDevicePixelRatioChanges");
    function RE(n) {
        Mo.delete(n),
        Mo.size || window.removeEventListener("resize", Yg)
    }
    o(RE, "unlistenDevicePixelRatioChanges");
    function IE(n, t, e) {
        let s = n.canvas
          , r = s && Xa(s);
        if (!r)
            return;
        let a = Ph( (u, d) => {
            let p = r.clientWidth;
            e(u, d),
            p < r.clientWidth && e()
        }
        , window)
          , l = new ResizeObserver(u => {
            let d = u[0]
              , p = d.contentRect.width
              , b = d.contentRect.height;
            p === 0 && b === 0 || a(p, b)
        }
        );
        return l.observe(r),
        PE(n, a),
        l
    }
    o(IE, "createResizeObserver");
    function rd(n, t, e) {
        e && e.disconnect(),
        t === "resize" && RE(n)
    }
    o(rd, "releaseObserver");
    function NE(n, t, e) {
        let s = n.canvas
          , r = Ph(a => {
            n.ctx !== null && e(OE(a, n))
        }
        , n, a => {
            let l = a[0];
            return [l, l.offsetX, l.offsetY]
        }
        );
        return kE(s, t, r),
        r
    }
    o(NE, "createProxyAndListen");
    var fd = class extends rl {
        static{o(this, "DomPlatform")
        }acquireContext(t, e) {
            let s = t && t.getContext && t.getContext("2d");
            return s && s.canvas === t ? (AE(t, e),
            s) : null
        }
        releaseContext(t) {
            let e = t.canvas;
            if (!e[nl])
                return !1;
            let s = e[nl].initial;
            ["height", "width"].forEach(a => {
                let l = s[a];
                zt(l) ? e.removeAttribute(a) : e.setAttribute(a, l)
            }
            );
            let r = s.style || {};
            return Object.keys(r).forEach(a => {
                e.style[a] = r[a]
            }
            ),
            e.width = e.width,
            delete e[nl],
            !0
        }
        addEventListener(t, e, s) {
            this.removeEventListener(t, e);
            let r = t.$proxies || (t.$proxies = {})
              , l = {
                attach: LE,
                detach: DE,
                resize: IE
            }[e] || NE;
            r[e] = l(t, e, s)
        }
        removeEventListener(t, e) {
            let s = t.$proxies || (t.$proxies = {})
              , r = s[e];
            if (!r)
                return;
            ({
                attach: rd,
                detach: rd,
                resize: rd
            }[e] || ME)(t, e, r),
            s[e] = void 0
        }
        getDevicePixelRatio() {
            return window.devicePixelRatio
        }
        getMaximumSize(t, e, s, r) {
            return zp(t, e, s, r)
        }
        isAttached(t) {
            let e = Xa(t);
            return !!(e && e.isConnected)
        }
    }
    ;
    function FE(n) {
        return !Kh() || typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas ? dd : fd
    }
    o(FE, "_detectPlatform");
    var pd = class {
        static{o(this, "PluginService")
        }constructor() {
            this._init = []
        }
        notify(t, e, s, r) {
            e === "beforeInit" && (this._init = this._createDescriptors(t, !0),
            this._notify(this._init, t, "install"));
            let a = r ? this._descriptors(t).filter(r) : this._descriptors(t)
              , l = this._notify(a, t, e, s);
            return e === "afterDestroy" && (this._notify(a, t, "stop"),
            this._notify(this._init, t, "uninstall")),
            l
        }
        _notify(t, e, s, r) {
            r = r || {};
            for (let a of t) {
                let l = a.plugin
                  , u = l[s]
                  , d = [e, r, a.options];
                if (ie(u, d, l) === !1 && r.cancelable)
                    return !1
            }
            return !0
        }
        invalidate() {
            zt(this._cache) || (this._oldCache = this._cache,
            this._cache = void 0)
        }
        _descriptors(t) {
            if (this._cache)
                return this._cache;
            let e = this._cache = this._createDescriptors(t);
            return this._notifyStateChanges(t),
            e
        }
        _createDescriptors(t, e) {
            let s = t && t.config
              , r = It(s.options && s.options.plugins, {})
              , a = VE(s);
            return r === !1 && !e ? [] : HE(t, a, r, e)
        }
        _notifyStateChanges(t) {
            let e = this._oldCache || []
              , s = this._cache
              , r = o( (a, l) => a.filter(u => !l.some(d => u.plugin.id === d.plugin.id)), "diff");
            this._notify(r(e, s), t, "stop"),
            this._notify(r(s, e), t, "start")
        }
    }
    ;
    function VE(n) {
        let t = {}
          , e = []
          , s = Object.keys(Xi.plugins.items);
        for (let a = 0; a < s.length; a++)
            e.push(Xi.getPlugin(s[a]));
        let r = n.plugins || [];
        for (let a = 0; a < r.length; a++) {
            let l = r[a];
            e.indexOf(l) === -1 && (e.push(l),
            t[l.id] = !0)
        }
        return {
            plugins: e,
            localIds: t
        }
    }
    o(VE, "allPlugins");
    function BE(n, t) {
        return !t && n === !1 ? null : n === !0 ? {} : n
    }
    o(BE, "getOpts");
    function HE(n, {plugins: t, localIds: e}, s, r) {
        let a = []
          , l = n.getContext();
        for (let u of t) {
            let d = u.id
              , p = BE(s[d], r);
            p !== null && a.push({
                plugin: u,
                options: jE(n.config, {
                    plugin: u,
                    local: e[d]
                }, p, l)
            })
        }
        return a
    }
    o(HE, "createDescriptors");
    function jE(n, {plugin: t, local: e}, s, r) {
        let a = n.pluginScopeKeys(t)
          , l = n.getOptionScopes(s, a);
        return e && t.defaults && l.push(t.defaults),
        n.createResolver(l, r, [""], {
            scriptable: !1,
            indexable: !1,
            allKeys: !0
        })
    }
    o(jE, "pluginOpts");
    function gd(n, t) {
        let e = jt.datasets[n] || {};
        return ((t.datasets || {})[n] || {}).indexAxis || t.indexAxis || e.indexAxis || "x"
    }
    o(gd, "getIndexAxis");
    function WE(n, t) {
        let e = n;
        return n === "_index_" ? e = t : n === "_value_" && (e = t === "x" ? "y" : "x"),
        e
    }
    o(WE, "getAxisFromDefaultScaleID");
    function $E(n, t) {
        return n === t ? "_index_" : "_value_"
    }
    o($E, "getDefaultScaleIDFromAxis");
    function qE(n) {
        if (n === "top" || n === "bottom")
            return "x";
        if (n === "left" || n === "right")
            return "y"
    }
    o(qE, "axisFromPosition");
    function md(n, t) {
        return n === "x" || n === "y" ? n : t.axis || qE(t.position) || n.charAt(0).toLowerCase()
    }
    o(md, "determineAxis");
    function zE(n, t) {
        let e = Vn[n.type] || {
            scales: {}
        }
          , s = t.scales || {}
          , r = gd(n.type, t)
          , a = Object.create(null)
          , l = Object.create(null);
        return Object.keys(s).forEach(u => {
            let d = s[u];
            if (!Ht(d))
                return console.error(`Invalid scale configuration for scale: ${u}`);
            if (d._proxy)
                return console.warn(`Ignoring resolver passed as options for scale: ${u}`);
            let p = md(u, d)
              , b = $E(p, r)
              , E = e.scales || {};
            a[p] = a[p] || u,
            l[u] = sr(Object.create(null), [{
                axis: p
            }, d, E[p], E[b]])
        }
        ),
        n.data.datasets.forEach(u => {
            let d = u.type || n.type
              , p = u.indexAxis || gd(d, t)
              , E = (Vn[d] || {}).scales || {};
            Object.keys(E).forEach(x => {
                let w = WE(x, p)
                  , C = u[w + "AxisID"] || a[w] || w;
                l[C] = l[C] || Object.create(null),
                sr(l[C], [{
                    axis: w
                }, s[C], E[x]])
            }
            )
        }
        ),
        Object.keys(l).forEach(u => {
            let d = l[u];
            sr(d, [jt.scales[d.type], jt.scale])
        }
        ),
        l
    }
    o(zE, "mergeScaleConfig");
    function Xg(n) {
        let t = n.options || (n.options = {});
        t.plugins = It(t.plugins, {}),
        t.scales = zE(n, t)
    }
    o(Xg, "initOptions");
    function Gg(n) {
        return n = n || {},
        n.datasets = n.datasets || [],
        n.labels = n.labels || [],
        n
    }
    o(Gg, "initData");
    function UE(n) {
        return n = n || {},
        n.data = Gg(n.data),
        Xg(n),
        n
    }
    o(UE, "initConfig");
    var mg = new Map
      , Qg = new Set;
    function Za(n, t) {
        let e = mg.get(n);
        return e || (e = t(),
        mg.set(n, e),
        Qg.add(e)),
        e
    }
    o(Za, "cachedKeys");
    var xo = o( (n, t, e) => {
        let s = gn(t, e);
        s !== void 0 && n.add(s)
    }
    , "addIfFound")
      , vd = class {
        static{o(this, "Config")
        }constructor(t) {
            this._config = UE(t),
            this._scopeCache = new Map,
            this._resolverCache = new Map
        }
        get platform() {
            return this._config.platform
        }
        get type() {
            return this._config.type
        }
        set type(t) {
            this._config.type = t
        }
        get data() {
            return this._config.data
        }
        set data(t) {
            this._config.data = Gg(t)
        }
        get options() {
            return this._config.options
        }
        set options(t) {
            this._config.options = t
        }
        get plugins() {
            return this._config.plugins
        }
        update() {
            let t = this._config;
            this.clearCache(),
            Xg(t)
        }
        clearCache() {
            this._scopeCache.clear(),
            this._resolverCache.clear()
        }
        datasetScopeKeys(t) {
            return Za(t, () => [[`datasets.${t}`, ""]])
        }
        datasetAnimationScopeKeys(t, e) {
            return Za(`${t}.transition.${e}`, () => [[`datasets.${t}.transitions.${e}`, `transitions.${e}`], [`datasets.${t}`, ""]])
        }
        datasetElementScopeKeys(t, e) {
            return Za(`${t}-${e}`, () => [[`datasets.${t}.elements.${e}`, `datasets.${t}`, `elements.${e}`, ""]])
        }
        pluginScopeKeys(t) {
            let e = t.id
              , s = this.type;
            return Za(`${s}-plugin-${e}`, () => [[`plugins.${e}`, ...t.additionalOptionScopes || []]])
        }
        _cachedScopes(t, e) {
            let s = this._scopeCache
              , r = s.get(t);
            return (!r || e) && (r = new Map,
            s.set(t, r)),
            r
        }
        getOptionScopes(t, e, s) {
            let {options: r, type: a} = this
              , l = this._cachedScopes(t, s)
              , u = l.get(e);
            if (u)
                return u;
            let d = new Set;
            e.forEach(b => {
                t && (d.add(t),
                b.forEach(E => xo(d, t, E))),
                b.forEach(E => xo(d, r, E)),
                b.forEach(E => xo(d, Vn[a] || {}, E)),
                b.forEach(E => xo(d, jt, E)),
                b.forEach(E => xo(d, za, E))
            }
            );
            let p = Array.from(d);
            return p.length === 0 && p.push(Object.create(null)),
            Qg.has(e) && l.set(e, p),
            p
        }
        chartOptionScopes() {
            let {options: t, type: e} = this;
            return [t, Vn[e] || {}, jt.datasets[e] || {}, {
                type: e
            }, jt, za]
        }
        resolveNamedOptions(t, e, s, r=[""]) {
            let a = {
                $shared: !0
            }
              , {resolver: l, subPrefixes: u} = vg(this._resolverCache, t, r)
              , d = l;
            if (YE(l, e)) {
                a.$shared = !1,
                s = pn(s) ? s() : s;
                let p = this.createResolver(t, s, u);
                d = gs(l, s, p)
            }
            for (let p of e)
                a[p] = d[p];
            return a
        }
        createResolver(t, e, s=[""], r) {
            let {resolver: a} = vg(this._resolverCache, t, s);
            return Ht(e) ? gs(a, e, void 0, r) : a
        }
    }
    ;
    function vg(n, t, e) {
        let s = n.get(t);
        s || (s = new Map,
        n.set(t, s));
        let r = e.join()
          , a = s.get(r);
        return a || (a = {
            resolver: Ya(t, e),
            subPrefixes: e.filter(u => !u.toLowerCase().includes("hover"))
        },
        s.set(r, a)),
        a
    }
    o(vg, "getResolver");
    var KE = o(n => Ht(n) && Object.getOwnPropertyNames(n).reduce( (t, e) => t || pn(n[e]), !1), "hasFunction");
    function YE(n, t) {
        let {isScriptable: e, isIndexable: s} = $h(n);
        for (let r of t) {
            let a = e(r)
              , l = s(r)
              , u = (l || a) && n[r];
            if (a && (pn(u) || KE(u)) || l && ee(u))
                return !0
        }
        return !1
    }
    o(YE, "needContext");
    var XE = "3.9.1"
      , GE = ["top", "bottom", "left", "right", "chartArea"];
    function bg(n, t) {
        return n === "top" || n === "bottom" || GE.indexOf(n) === -1 && t === "x"
    }
    o(bg, "positionIsHorizontal");
    function yg(n, t) {
        return function(e, s) {
            return e[n] === s[n] ? e[t] - s[t] : e[n] - s[n]
        }
    }
    o(yg, "compare2Level");
    function _g(n) {
        let t = n.chart
          , e = t.options.animation;
        t.notifyPlugins("afterRender"),
        ie(e && e.onComplete, [n], t)
    }
    o(_g, "onAnimationsComplete");
    function QE(n) {
        let t = n.chart
          , e = t.options.animation;
        ie(e && e.onProgress, [n], t)
    }
    o(QE, "onAnimationProgress");
    function Jg(n) {
        return Kh() && typeof n == "string" ? n = document.getElementById(n) : n && n.length && (n = n[0]),
        n && n.canvas && (n = n.canvas),
        n
    }
    o(Jg, "getCanvas");
    var al = {}
      , Zg = o(n => {
        let t = Jg(n);
        return Object.values(al).filter(e => e.canvas === t).pop()
    }
    , "getChart");
    function JE(n, t, e) {
        let s = Object.keys(n);
        for (let r of s) {
            let a = +r;
            if (a >= t) {
                let l = n[r];
                delete n[r],
                (e > 0 || a > t) && (n[a + e] = l)
            }
        }
    }
    o(JE, "moveNumericKeys");
    function ZE(n, t, e, s) {
        return !e || n.type === "mouseout" ? null : s ? t : n
    }
    o(ZE, "determineLastEvent");
    var _s = class {
        static{o(this, "Chart")
        }constructor(t, e) {
            let s = this.config = new vd(e)
              , r = Jg(t)
              , a = Zg(r);
            if (a)
                throw new Error("Canvas is already in use. Chart with ID '" + a.id + "' must be destroyed before the canvas with ID '" + a.canvas.id + "' can be reused.");
            let l = s.createResolver(s.chartOptionScopes(), this.getContext());
            this.platform = new (s.platform || FE(r)),
            this.platform.updateConfig(s);
            let u = this.platform.acquireContext(r, l.aspectRatio)
              , d = u && u.canvas
              , p = d && d.height
              , b = d && d.width;
            if (this.id = bp(),
            this.ctx = u,
            this.canvas = d,
            this.width = b,
            this.height = p,
            this._options = l,
            this._aspectRatio = this.aspectRatio,
            this._layers = [],
            this._metasets = [],
            this._stacks = void 0,
            this.boxes = [],
            this.currentDevicePixelRatio = void 0,
            this.chartArea = void 0,
            this._active = [],
            this._lastEvent = void 0,
            this._listeners = {},
            this._responsiveListeners = void 0,
            this._sortedMetasets = [],
            this.scales = {},
            this._plugins = new pd,
            this.$proxies = {},
            this._hiddenIndices = {},
            this.attached = !1,
            this._animationsDisabled = void 0,
            this.$context = void 0,
            this._doResize = Mp(E => this.update(E), l.resizeDelay || 0),
            this._dataChanges = [],
            al[this.id] = this,
            !u || !d) {
                console.error("Failed to create chart: can't acquire context from the given item");
                return
            }
            vn.listen(this, "complete", _g),
            vn.listen(this, "progress", QE),
            this._initialize(),
            this.attached && this.update()
        }
        get aspectRatio() {
            let {options: {aspectRatio: t, maintainAspectRatio: e}, width: s, height: r, _aspectRatio: a} = this;
            return zt(t) ? e && a ? a : r ? s / r : null : t
        }
        get data() {
            return this.config.data
        }
        set data(t) {
            this.config.data = t
        }
        get options() {
            return this._options
        }
        set options(t) {
            this.config.options = t
        }
        _initialize() {
            return this.notifyPlugins("beforeInit"),
            this.options.responsive ? this.resize() : Yh(this, this.options.devicePixelRatio),
            this.bindEvents(),
            this.notifyPlugins("afterInit"),
            this
        }
        clear() {
            return Hh(this.canvas, this.ctx),
            this
        }
        stop() {
            return vn.stop(this),
            this
        }
        resize(t, e) {
            vn.running(this) ? this._resizeBeforeDraw = {
                width: t,
                height: e
            } : this._resize(t, e)
        }
        _resize(t, e) {
            let s = this.options
              , r = this.canvas
              , a = s.maintainAspectRatio && this.aspectRatio
              , l = this.platform.getMaximumSize(r, t, e, a)
              , u = s.devicePixelRatio || this.platform.getDevicePixelRatio()
              , d = this.width ? "resize" : "attach";
            this.width = l.width,
            this.height = l.height,
            this._aspectRatio = this.aspectRatio,
            Yh(this, u, !0) && (this.notifyPlugins("resize", {
                size: l
            }),
            ie(s.onResize, [this, l], this),
            this.attached && this._doResize(d) && this.render())
        }
        ensureScalesHaveIDs() {
            let e = this.options.scales || {};
            Jt(e, (s, r) => {
                s.id = r
            }
            )
        }
        buildOrUpdateScales() {
            let t = this.options
              , e = t.scales
              , s = this.scales
              , r = Object.keys(s).reduce( (l, u) => (l[u] = !1,
            l), {})
              , a = [];
            e && (a = a.concat(Object.keys(e).map(l => {
                let u = e[l]
                  , d = md(l, u)
                  , p = d === "r"
                  , b = d === "x";
                return {
                    options: u,
                    dposition: p ? "chartArea" : b ? "bottom" : "left",
                    dtype: p ? "radialLinear" : b ? "category" : "linear"
                }
            }
            ))),
            Jt(a, l => {
                let u = l.options
                  , d = u.id
                  , p = md(d, u)
                  , b = It(u.type, l.dtype);
                (u.position === void 0 || bg(u.position, p) !== bg(l.dposition)) && (u.position = l.dposition),
                r[d] = !0;
                let E = null;
                if (d in s && s[d].type === b)
                    E = s[d];
                else {
                    let x = Xi.getScale(b);
                    E = new x({
                        id: d,
                        type: b,
                        ctx: this.ctx,
                        chart: this
                    }),
                    s[E.id] = E
                }
                E.init(u, t)
            }
            ),
            Jt(r, (l, u) => {
                l || delete s[u]
            }
            ),
            Jt(s, l => {
                Pe.configure(this, l, l.options),
                Pe.addBox(this, l)
            }
            )
        }
        _updateMetasets() {
            let t = this._metasets
              , e = this.data.datasets.length
              , s = t.length;
            if (t.sort( (r, a) => r.index - a.index),
            s > e) {
                for (let r = e; r < s; ++r)
                    this._destroyDatasetMeta(r);
                t.splice(e, s - e)
            }
            this._sortedMetasets = t.slice(0).sort(yg("order", "index"))
        }
        _removeUnreferencedMetasets() {
            let {_metasets: t, data: {datasets: e}} = this;
            t.length > e.length && delete this._stacks,
            t.forEach( (s, r) => {
                e.filter(a => a === s._dataset).length === 0 && this._destroyDatasetMeta(r)
            }
            )
        }
        buildOrUpdateControllers() {
            let t = [], e = this.data.datasets, s, r;
            for (this._removeUnreferencedMetasets(),
            s = 0,
            r = e.length; s < r; s++) {
                let a = e[s]
                  , l = this.getDatasetMeta(s)
                  , u = a.type || this.config.type;
                if (l.type && l.type !== u && (this._destroyDatasetMeta(s),
                l = this.getDatasetMeta(s)),
                l.type = u,
                l.indexAxis = a.indexAxis || gd(u, this.options),
                l.order = a.order || 0,
                l.index = s,
                l.label = "" + a.label,
                l.visible = this.isDatasetVisible(s),
                l.controller)
                    l.controller.updateIndex(s),
                    l.controller.linkScales();
                else {
                    let d = Xi.getController(u)
                      , {datasetElementType: p, dataElementType: b} = jt.datasets[u];
                    Object.assign(d.prototype, {
                        dataElementType: Xi.getElement(b),
                        datasetElementType: p && Xi.getElement(p)
                    }),
                    l.controller = new d(this,s),
                    t.push(l.controller)
                }
            }
            return this._updateMetasets(),
            t
        }
        _resetElements() {
            Jt(this.data.datasets, (t, e) => {
                this.getDatasetMeta(e).controller.reset()
            }
            , this)
        }
        reset() {
            this._resetElements(),
            this.notifyPlugins("reset")
        }
        update(t) {
            let e = this.config;
            e.update();
            let s = this._options = e.createResolver(e.chartOptionScopes(), this.getContext())
              , r = this._animationsDisabled = !s.animation;
            if (this._updateScales(),
            this._checkEventBindings(),
            this._updateHiddenIndices(),
            this._plugins.invalidate(),
            this.notifyPlugins("beforeUpdate", {
                mode: t,
                cancelable: !0
            }) === !1)
                return;
            let a = this.buildOrUpdateControllers();
            this.notifyPlugins("beforeElementsUpdate");
            let l = 0;
            for (let p = 0, b = this.data.datasets.length; p < b; p++) {
                let {controller: E} = this.getDatasetMeta(p)
                  , x = !r && a.indexOf(E) === -1;
                E.buildOrUpdateElements(x),
                l = Math.max(+E.getMaxOverflow(), l)
            }
            l = this._minPadding = s.layout.autoPadding ? l : 0,
            this._updateLayout(l),
            r || Jt(a, p => {
                p.reset()
            }
            ),
            this._updateDatasets(t),
            this.notifyPlugins("afterUpdate", {
                mode: t
            }),
            this._layers.sort(yg("z", "_idx"));
            let {_active: u, _lastEvent: d} = this;
            d ? this._eventHandler(d, !0) : u.length && this._updateHoverStyles(u, u, !0),
            this.render()
        }
        _updateScales() {
            Jt(this.scales, t => {
                Pe.removeBox(this, t)
            }
            ),
            this.ensureScalesHaveIDs(),
            this.buildOrUpdateScales()
        }
        _checkEventBindings() {
            let t = this.options
              , e = new Set(Object.keys(this._listeners))
              , s = new Set(t.events);
            (!wh(e, s) || !!this._responsiveListeners !== t.responsive) && (this.unbindEvents(),
            this.bindEvents())
        }
        _updateHiddenIndices() {
            let {_hiddenIndices: t} = this
              , e = this._getUniformDataChanges() || [];
            for (let {method: s, start: r, count: a} of e) {
                let l = s === "_removeElements" ? -a : a;
                JE(t, r, l)
            }
        }
        _getUniformDataChanges() {
            let t = this._dataChanges;
            if (!t || !t.length)
                return;
            this._dataChanges = [];
            let e = this.data.datasets.length
              , s = o(a => new Set(t.filter(l => l[0] === a).map( (l, u) => u + "," + l.splice(1).join(","))), "makeSet")
              , r = s(0);
            for (let a = 1; a < e; a++)
                if (!wh(r, s(a)))
                    return;
            return Array.from(r).map(a => a.split(",")).map(a => ({
                method: a[1],
                start: +a[2],
                count: +a[3]
            }))
        }
        _updateLayout(t) {
            if (this.notifyPlugins("beforeLayout", {
                cancelable: !0
            }) === !1)
                return;
            Pe.update(this, this.width, this.height, t);
            let e = this.chartArea
              , s = e.width <= 0 || e.height <= 0;
            this._layers = [],
            Jt(this.boxes, r => {
                s && r.position === "chartArea" || (r.configure && r.configure(),
                this._layers.push(...r._layers()))
            }
            , this),
            this._layers.forEach( (r, a) => {
                r._idx = a
            }
            ),
            this.notifyPlugins("afterLayout")
        }
        _updateDatasets(t) {
            if (this.notifyPlugins("beforeDatasetsUpdate", {
                mode: t,
                cancelable: !0
            }) !== !1) {
                for (let e = 0, s = this.data.datasets.length; e < s; ++e)
                    this.getDatasetMeta(e).controller.configure();
                for (let e = 0, s = this.data.datasets.length; e < s; ++e)
                    this._updateDataset(e, pn(t) ? t({
                        datasetIndex: e
                    }) : t);
                this.notifyPlugins("afterDatasetsUpdate", {
                    mode: t
                })
            }
        }
        _updateDataset(t, e) {
            let s = this.getDatasetMeta(t)
              , r = {
                meta: s,
                index: t,
                mode: e,
                cancelable: !0
            };
            this.notifyPlugins("beforeDatasetUpdate", r) !== !1 && (s.controller._update(e),
            r.cancelable = !1,
            this.notifyPlugins("afterDatasetUpdate", r))
        }
        render() {
            this.notifyPlugins("beforeRender", {
                cancelable: !0
            }) !== !1 && (vn.has(this) ? this.attached && !vn.running(this) && vn.start(this) : (this.draw(),
            _g({
                chart: this
            })))
        }
        draw() {
            let t;
            if (this._resizeBeforeDraw) {
                let {width: s, height: r} = this._resizeBeforeDraw;
                this._resize(s, r),
                this._resizeBeforeDraw = null
            }
            if (this.clear(),
            this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", {
                cancelable: !0
            }) === !1)
                return;
            let e = this._layers;
            for (t = 0; t < e.length && e[t].z <= 0; ++t)
                e[t].draw(this.chartArea);
            for (this._drawDatasets(); t < e.length; ++t)
                e[t].draw(this.chartArea);
            this.notifyPlugins("afterDraw")
        }
        _getSortedDatasetMetas(t) {
            let e = this._sortedMetasets, s = [], r, a;
            for (r = 0,
            a = e.length; r < a; ++r) {
                let l = e[r];
                (!t || l.visible) && s.push(l)
            }
            return s
        }
        getSortedVisibleDatasetMetas() {
            return this._getSortedDatasetMetas(!0)
        }
        _drawDatasets() {
            if (this.notifyPlugins("beforeDatasetsDraw", {
                cancelable: !0
            }) === !1)
                return;
            let t = this.getSortedVisibleDatasetMetas();
            for (let e = t.length - 1; e >= 0; --e)
                this._drawDataset(t[e]);
            this.notifyPlugins("afterDatasetsDraw")
        }
        _drawDataset(t) {
            let e = this.ctx
              , s = t._clip
              , r = !s.disabled
              , a = this.chartArea
              , l = {
                meta: t,
                index: t.index,
                cancelable: !0
            };
            this.notifyPlugins("beforeDatasetDraw", l) !== !1 && (r && bo(e, {
                left: s.left === !1 ? 0 : a.left - s.left,
                right: s.right === !1 ? this.width : a.right + s.right,
                top: s.top === !1 ? 0 : a.top - s.top,
                bottom: s.bottom === !1 ? this.height : a.bottom + s.bottom
            }),
            t.controller.draw(),
            r && yo(e),
            l.cancelable = !1,
            this.notifyPlugins("afterDatasetDraw", l))
        }
        isPointInArea(t) {
            return ir(t, this.chartArea, this._minPadding)
        }
        getElementsAtEventForMode(t, e, s, r) {
            let a = bE.modes[e];
            return typeof a == "function" ? a(this, t, s, r) : []
        }
        getDatasetMeta(t) {
            let e = this.data.datasets[t]
              , s = this._metasets
              , r = s.filter(a => a && a._dataset === e).pop();
            return r || (r = {
                type: null,
                data: [],
                dataset: null,
                controller: null,
                hidden: null,
                xAxisID: null,
                yAxisID: null,
                order: e && e.order || 0,
                index: t,
                _dataset: e,
                _parsed: [],
                _sorted: !1
            },
            s.push(r)),
            r
        }
        getContext() {
            return this.$context || (this.$context = mn(null, {
                chart: this,
                type: "chart"
            }))
        }
        getVisibleDatasetCount() {
            return this.getSortedVisibleDatasetMetas().length
        }
        isDatasetVisible(t) {
            let e = this.data.datasets[t];
            if (!e)
                return !1;
            let s = this.getDatasetMeta(t);
            return typeof s.hidden == "boolean" ? !s.hidden : !e.hidden
        }
        setDatasetVisibility(t, e) {
            let s = this.getDatasetMeta(t);
            s.hidden = !e
        }
        toggleDataVisibility(t) {
            this._hiddenIndices[t] = !this._hiddenIndices[t]
        }
        getDataVisibility(t) {
            return !this._hiddenIndices[t]
        }
        _updateVisibility(t, e, s) {
            let r = s ? "show" : "hide"
              , a = this.getDatasetMeta(t)
              , l = a.controller._resolveAnimations(void 0, r);
            si(e) ? (a.data[e].hidden = !s,
            this.update()) : (this.setDatasetVisibility(t, s),
            l.update(a, {
                visible: s
            }),
            this.update(u => u.datasetIndex === t ? r : void 0))
        }
        hide(t, e) {
            this._updateVisibility(t, e, !1)
        }
        show(t, e) {
            this._updateVisibility(t, e, !0)
        }
        _destroyDatasetMeta(t) {
            let e = this._metasets[t];
            e && e.controller && e.controller._destroy(),
            delete this._metasets[t]
        }
        _stop() {
            let t, e;
            for (this.stop(),
            vn.remove(this),
            t = 0,
            e = this.data.datasets.length; t < e; ++t)
                this._destroyDatasetMeta(t)
        }
        destroy() {
            this.notifyPlugins("beforeDestroy");
            let {canvas: t, ctx: e} = this;
            this._stop(),
            this.config.clearCache(),
            t && (this.unbindEvents(),
            Hh(t, e),
            this.platform.releaseContext(e),
            this.canvas = null,
            this.ctx = null),
            this.notifyPlugins("destroy"),
            delete al[this.id],
            this.notifyPlugins("afterDestroy")
        }
        toBase64Image(...t) {
            return this.canvas.toDataURL(...t)
        }
        bindEvents() {
            this.bindUserEvents(),
            this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0
        }
        bindUserEvents() {
            let t = this._listeners
              , e = this.platform
              , s = o( (a, l) => {
                e.addEventListener(this, a, l),
                t[a] = l
            }
            , "_add")
              , r = o( (a, l, u) => {
                a.offsetX = l,
                a.offsetY = u,
                this._eventHandler(a)
            }
            , "listener");
            Jt(this.options.events, a => s(a, r))
        }
        bindResponsiveEvents() {
            this._responsiveListeners || (this._responsiveListeners = {});
            let t = this._responsiveListeners, e = this.platform, s = o( (d, p) => {
                e.addEventListener(this, d, p),
                t[d] = p
            }
            , "_add"), r = o( (d, p) => {
                t[d] && (e.removeEventListener(this, d, p),
                delete t[d])
            }
            , "_remove"), a = o( (d, p) => {
                this.canvas && this.resize(d, p)
            }
            , "listener"), l, u = o( () => {
                r("attach", u),
                this.attached = !0,
                this.resize(),
                s("resize", a),
                s("detach", l)
            }
            , "attached");
            l = o( () => {
                this.attached = !1,
                r("resize", a),
                this._stop(),
                this._resize(0, 0),
                s("attach", u)
            }
            , "detached"),
            e.isAttached(this.canvas) ? u() : l()
        }
        unbindEvents() {
            Jt(this._listeners, (t, e) => {
                this.platform.removeEventListener(this, e, t)
            }
            ),
            this._listeners = {},
            Jt(this._responsiveListeners, (t, e) => {
                this.platform.removeEventListener(this, e, t)
            }
            ),
            this._responsiveListeners = void 0
        }
        updateHoverStyle(t, e, s) {
            let r = s ? "set" : "remove", a, l, u, d;
            for (e === "dataset" && (a = this.getDatasetMeta(t[0].datasetIndex),
            a.controller["_" + r + "DatasetHoverStyle"]()),
            u = 0,
            d = t.length; u < d; ++u) {
                l = t[u];
                let p = l && this.getDatasetMeta(l.datasetIndex).controller;
                p && p[r + "HoverStyle"](l.element, l.datasetIndex, l.index)
            }
        }
        getActiveElements() {
            return this._active || []
        }
        setActiveElements(t) {
            let e = this._active || []
              , s = t.map( ({datasetIndex: a, index: l}) => {
                let u = this.getDatasetMeta(a);
                if (!u)
                    throw new Error("No dataset found at index " + a);
                return {
                    datasetIndex: a,
                    element: u.data[l],
                    index: l
                }
            }
            );
            !mo(s, e) && (this._active = s,
            this._lastEvent = null,
            this._updateHoverStyles(s, e))
        }
        notifyPlugins(t, e, s) {
            return this._plugins.notify(this, t, e, s)
        }
        _updateHoverStyles(t, e, s) {
            let r = this.options.hover
              , a = o( (d, p) => d.filter(b => !p.some(E => b.datasetIndex === E.datasetIndex && b.index === E.index)), "diff")
              , l = a(e, t)
              , u = s ? t : a(t, e);
            l.length && this.updateHoverStyle(l, r.mode, !1),
            u.length && r.mode && this.updateHoverStyle(u, r.mode, !0)
        }
        _eventHandler(t, e) {
            let s = {
                event: t,
                replay: e,
                cancelable: !0,
                inChartArea: this.isPointInArea(t)
            }
              , r = o(l => (l.options.events || this.options.events).includes(t.native.type), "eventFilter");
            if (this.notifyPlugins("beforeEvent", s, r) === !1)
                return;
            let a = this._handleEvent(t, e, s.inChartArea);
            return s.cancelable = !1,
            this.notifyPlugins("afterEvent", s, r),
            (a || s.changed) && this.render(),
            this
        }
        _handleEvent(t, e, s) {
            let {_active: r=[], options: a} = this
              , l = e
              , u = this._getActiveElements(t, r, s, l)
              , d = Ep(t)
              , p = ZE(t, this._lastEvent, s, d);
            s && (this._lastEvent = null,
            ie(a.onHover, [t, u, this], this),
            d && ie(a.onClick, [t, u, this], this));
            let b = !mo(u, r);
            return (b || e) && (this._active = u,
            this._updateHoverStyles(u, r, e)),
            this._lastEvent = p,
            b
        }
        _getActiveElements(t, e, s, r) {
            if (t.type === "mouseout")
                return [];
            if (!s)
                return e;
            let a = this.options.hover;
            return this.getElementsAtEventForMode(t, a.mode, a, r)
        }
    }
      , Eg = o( () => Jt(_s.instances, n => n._plugins.invalidate()), "invalidatePlugins")
      , $n = !0;
    Object.defineProperties(_s, {
        defaults: {
            enumerable: $n,
            value: jt
        },
        instances: {
            enumerable: $n,
            value: al
        },
        overrides: {
            enumerable: $n,
            value: Vn
        },
        registry: {
            enumerable: $n,
            value: Xi
        },
        version: {
            enumerable: $n,
            value: XE
        },
        getChart: {
            enumerable: $n,
            value: Zg
        },
        register: {
            enumerable: $n,
            value: o( (...n) => {
                Xi.add(...n),
                Eg()
            }
            , "value")
        },
        unregister: {
            enumerable: $n,
            value: o( (...n) => {
                Xi.remove(...n),
                Eg()
            }
            , "value")
        }
    });
    function tm(n, t, e) {
        let {startAngle: s, pixelMargin: r, x: a, y: l, outerRadius: u, innerRadius: d} = t
          , p = r / u;
        n.beginPath(),
        n.arc(a, l, u, s - p, e + p),
        d > r ? (p = r / d,
        n.arc(a, l, d, e + p, s - p, !0)) : n.arc(a, l, r, e + he, s - he),
        n.closePath(),
        n.clip()
    }
    o(tm, "clipArc");
    function tS(n) {
        return Ka(n, ["outerStart", "outerEnd", "innerStart", "innerEnd"])
    }
    o(tS, "toRadiusCorners");
    function eS(n, t, e, s) {
        let r = tS(n.options.borderRadius)
          , a = (e - t) / 2
          , l = Math.min(a, s * t / 2)
          , u = o(d => {
            let p = (e - Math.min(a, d)) * s / 2;
            return be(d, 0, Math.min(a, p))
        }
        , "computeOuterLimit");
        return {
            outerStart: u(r.outerStart),
            outerEnd: u(r.outerEnd),
            innerStart: be(r.innerStart, 0, l),
            innerEnd: be(r.innerEnd, 0, l)
        }
    }
    o(eS, "parseBorderRadius$1");
    function ur(n, t, e, s) {
        return {
            x: e + n * Math.cos(t),
            y: s + n * Math.sin(t)
        }
    }
    o(ur, "rThetaToXY");
    function bd(n, t, e, s, r, a) {
        let {x: l, y: u, startAngle: d, pixelMargin: p, innerRadius: b} = t
          , E = Math.max(t.outerRadius + s + e - p, 0)
          , x = b > 0 ? b + s + e + p : 0
          , w = 0
          , C = r - d;
        if (s) {
            let wt = b > 0 ? b - s : 0
              , Nt = E > 0 ? E - s : 0
              , Xt = (wt + Nt) / 2
              , pe = Xt !== 0 ? C * Xt / (Xt + s) : C;
            w = (C - pe) / 2
        }
        let I = Math.max(.001, C * E - e / ae) / E
          , L = (C - I) / 2
          , k = d + L + w
          , F = r - L - w
          , {outerStart: z, outerEnd: j, innerStart: H, innerEnd: f} = eS(t, x, E, F - k)
          , Y = E - z
          , Q = E - j
          , ot = k + z / Y
          , mt = F - j / Q
          , bt = x + H
          , ft = x + f
          , $t = k + H / bt
          , Ut = F - f / ft;
        if (n.beginPath(),
        a) {
            if (n.arc(l, u, E, ot, mt),
            j > 0) {
                let Xt = ur(Q, mt, l, u);
                n.arc(Xt.x, Xt.y, j, mt, F + he)
            }
            let wt = ur(ft, F, l, u);
            if (n.lineTo(wt.x, wt.y),
            f > 0) {
                let Xt = ur(ft, Ut, l, u);
                n.arc(Xt.x, Xt.y, f, F + he, Ut + Math.PI)
            }
            if (n.arc(l, u, x, F - f / x, k + H / x, !0),
            H > 0) {
                let Xt = ur(bt, $t, l, u);
                n.arc(Xt.x, Xt.y, H, $t + Math.PI, k - he)
            }
            let Nt = ur(Y, k, l, u);
            if (n.lineTo(Nt.x, Nt.y),
            z > 0) {
                let Xt = ur(Y, ot, l, u);
                n.arc(Xt.x, Xt.y, z, k - he, ot)
            }
        } else {
            n.moveTo(l, u);
            let wt = Math.cos(ot) * E + l
              , Nt = Math.sin(ot) * E + u;
            n.lineTo(wt, Nt);
            let Xt = Math.cos(mt) * E + l
              , pe = Math.sin(mt) * E + u;
            n.lineTo(Xt, pe)
        }
        n.closePath()
    }
    o(bd, "pathArc");
    function iS(n, t, e, s, r) {
        let {fullCircles: a, startAngle: l, circumference: u} = t
          , d = t.endAngle;
        if (a) {
            bd(n, t, e, s, l + te, r);
            for (let p = 0; p < a; ++p)
                n.fill();
            isNaN(u) || (d = l + u % te,
            u % te === 0 && (d += te))
        }
        return bd(n, t, e, s, d, r),
        n.fill(),
        d
    }
    o(iS, "drawArc");
    function nS(n, t, e) {
        let {x: s, y: r, startAngle: a, pixelMargin: l, fullCircles: u} = t, d = Math.max(t.outerRadius - l, 0), p = t.innerRadius + l, b;
        for (e && tm(n, t, a + te),
        n.beginPath(),
        n.arc(s, r, p, a + te, a, !0),
        b = 0; b < u; ++b)
            n.stroke();
        for (n.beginPath(),
        n.arc(s, r, d, a, a + te),
        b = 0; b < u; ++b)
            n.stroke()
    }
    o(nS, "drawFullCircleBorders");
    function sS(n, t, e, s, r, a) {
        let {options: l} = t
          , {borderWidth: u, borderJoinStyle: d} = l
          , p = l.borderAlign === "inner";
        u && (p ? (n.lineWidth = u * 2,
        n.lineJoin = d || "round") : (n.lineWidth = u,
        n.lineJoin = d || "bevel"),
        t.fullCircles && nS(n, t, p),
        p && tm(n, t, r),
        bd(n, t, e, s, r, a),
        n.stroke())
    }
    o(sS, "drawBorder");
    var br = class extends li {
        static{o(this, "ArcElement")
        }constructor(t) {
            super(),
            this.options = void 0,
            this.circumference = void 0,
            this.startAngle = void 0,
            this.endAngle = void 0,
            this.innerRadius = void 0,
            this.outerRadius = void 0,
            this.pixelMargin = 0,
            this.fullCircles = 0,
            t && Object.assign(this, t)
        }
        inRange(t, e, s) {
            let r = this.getProps(["x", "y"], s)
              , {angle: a, distance: l} = Mh(r, {
                x: t,
                y: e
            })
              , {startAngle: u, endAngle: d, innerRadius: p, outerRadius: b, circumference: E} = this.getProps(["startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], s)
              , x = this.options.spacing / 2
              , C = It(E, d - u) >= te || or(a, u, d)
              , I = Ki(l, p + x, b + x);
            return C && I
        }
        getCenterPoint(t) {
            let {x: e, y: s, startAngle: r, endAngle: a, innerRadius: l, outerRadius: u} = this.getProps(["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], t)
              , {offset: d, spacing: p} = this.options
              , b = (r + a) / 2
              , E = (l + u + p + d) / 2;
            return {
                x: e + Math.cos(b) * E,
                y: s + Math.sin(b) * E
            }
        }
        tooltipPosition(t) {
            return this.getCenterPoint(t)
        }
        draw(t) {
            let {options: e, circumference: s} = this
              , r = (e.offset || 0) / 2
              , a = (e.spacing || 0) / 2
              , l = e.circular;
            if (this.pixelMargin = e.borderAlign === "inner" ? .33 : 0,
            this.fullCircles = s > te ? Math.floor(s / te) : 0,
            s === 0 || this.innerRadius < 0 || this.outerRadius < 0)
                return;
            t.save();
            let u = 0;
            if (r) {
                u = r / 2;
                let p = (this.startAngle + this.endAngle) / 2;
                t.translate(Math.cos(p) * u, Math.sin(p) * u),
                this.circumference >= ae && (u = r)
            }
            t.fillStyle = e.backgroundColor,
            t.strokeStyle = e.borderColor;
            let d = iS(t, this, u, a, l);
            sS(t, this, u, a, d, l),
            t.restore()
        }
    }
    ;
    br.id = "arc";
    br.defaults = {
        borderAlign: "center",
        borderColor: "#fff",
        borderJoinStyle: void 0,
        borderRadius: 0,
        borderWidth: 2,
        offset: 0,
        spacing: 0,
        angle: void 0,
        circular: !0
    };
    br.defaultRoutes = {
        backgroundColor: "backgroundColor"
    };
    function em(n, t, e=t) {
        n.lineCap = It(e.borderCapStyle, t.borderCapStyle),
        n.setLineDash(It(e.borderDash, t.borderDash)),
        n.lineDashOffset = It(e.borderDashOffset, t.borderDashOffset),
        n.lineJoin = It(e.borderJoinStyle, t.borderJoinStyle),
        n.lineWidth = It(e.borderWidth, t.borderWidth),
        n.strokeStyle = It(e.borderColor, t.borderColor)
    }
    o(em, "setStyle");
    function rS(n, t, e) {
        n.lineTo(e.x, e.y)
    }
    o(rS, "lineTo");
    function oS(n) {
        return n.stepped ? Fp : n.tension || n.cubicInterpolationMode === "monotone" ? Vp : rS
    }
    o(oS, "getLineMethod");
    function im(n, t, e={}) {
        let s = n.length
          , {start: r=0, end: a=s - 1} = e
          , {start: l, end: u} = t
          , d = Math.max(r, l)
          , p = Math.min(a, u)
          , b = r < l && a < l || r > u && a > u;
        return {
            count: s,
            start: d,
            loop: t.loop,
            ilen: p < d && !b ? s + p - d : p - d
        }
    }
    o(im, "pathVars");
    function aS(n, t, e, s) {
        let {points: r, options: a} = t, {count: l, start: u, loop: d, ilen: p} = im(r, e, s), b = oS(a), {move: E=!0, reverse: x} = s || {}, w, C, I;
        for (w = 0; w <= p; ++w)
            C = r[(u + (x ? p - w : w)) % l],
            !C.skip && (E ? (n.moveTo(C.x, C.y),
            E = !1) : b(n, I, C, x, a.stepped),
            I = C);
        return d && (C = r[(u + (x ? p : 0)) % l],
        b(n, I, C, x, a.stepped)),
        !!d
    }
    o(aS, "pathSegment");
    function lS(n, t, e, s) {
        let r = t.points, {count: a, start: l, ilen: u} = im(r, e, s), {move: d=!0, reverse: p} = s || {}, b = 0, E = 0, x, w, C, I, L, k, F = o(j => (l + (p ? u - j : j)) % a, "pointIndex"), z = o( () => {
            I !== L && (n.lineTo(b, L),
            n.lineTo(b, I),
            n.lineTo(b, k))
        }
        , "drawX");
        for (d && (w = r[F(0)],
        n.moveTo(w.x, w.y)),
        x = 0; x <= u; ++x) {
            if (w = r[F(x)],
            w.skip)
                continue;
            let j = w.x
              , H = w.y
              , f = j | 0;
            f === C ? (H < I ? I = H : H > L && (L = H),
            b = (E * b + j) / ++E) : (z(),
            n.lineTo(j, H),
            C = f,
            E = 0,
            I = L = H),
            k = H
        }
        z()
    }
    o(lS, "fastPathSegment");
    function yd(n) {
        let t = n.options
          , e = t.borderDash && t.borderDash.length;
        return !n._decimated && !n._loop && !t.tension && t.cubicInterpolationMode !== "monotone" && !t.stepped && !e ? lS : aS
    }
    o(yd, "_getSegmentMethod");
    function cS(n) {
        return n.stepped ? Kp : n.tension || n.cubicInterpolationMode === "monotone" ? Yp : In
    }
    o(cS, "_getInterpolationMethod");
    function uS(n, t, e, s) {
        let r = t._path;
        r || (r = t._path = new Path2D,
        t.path(r, e, s) && r.closePath()),
        em(n, t.options),
        n.stroke(r)
    }
    o(uS, "strokePathWithCache");
    function hS(n, t, e, s) {
        let {segments: r, options: a} = t
          , l = yd(t);
        for (let u of r)
            em(n, a, u.style),
            n.beginPath(),
            l(n, t, u, {
                start: e,
                end: e + s - 1
            }) && n.closePath(),
            n.stroke()
    }
    o(hS, "strokePathDirect");
    var dS = typeof Path2D == "function";
    function fS(n, t, e, s) {
        dS && !t.options.segment ? uS(n, t, e, s) : hS(n, t, e, s)
    }
    o(fS, "draw");
    var Gi = class extends li {
        static{o(this, "LineElement")
        }constructor(t) {
            super(),
            this.animated = !0,
            this.options = void 0,
            this._chart = void 0,
            this._loop = void 0,
            this._fullLoop = void 0,
            this._path = void 0,
            this._points = void 0,
            this._segments = void 0,
            this._decimated = !1,
            this._pointsUpdated = !1,
            this._datasetIndex = void 0,
            t && Object.assign(this, t)
        }
        updateControlPoints(t, e) {
            let s = this.options;
            if ((s.tension || s.cubicInterpolationMode === "monotone") && !s.stepped && !this._pointsUpdated) {
                let r = s.spanGaps ? this._loop : this._fullLoop;
                qp(this._points, s, t, r, e),
                this._pointsUpdated = !0
            }
        }
        set points(t) {
            this._points = t,
            delete this._segments,
            delete this._path,
            this._pointsUpdated = !1
        }
        get points() {
            return this._points
        }
        get segments() {
            return this._segments || (this._segments = Gp(this, this.options.segment))
        }
        first() {
            let t = this.segments
              , e = this.points;
            return t.length && e[t[0].start]
        }
        last() {
            let t = this.segments
              , e = this.points
              , s = t.length;
            return s && e[t[s - 1].end]
        }
        interpolate(t, e) {
            let s = this.options
              , r = t[e]
              , a = this.points
              , l = Zh(this, {
                property: e,
                start: r,
                end: r
            });
            if (!l.length)
                return;
            let u = [], d = cS(s), p, b;
            for (p = 0,
            b = l.length; p < b; ++p) {
                let {start: E, end: x} = l[p]
                  , w = a[E]
                  , C = a[x];
                if (w === C) {
                    u.push(w);
                    continue
                }
                let I = Math.abs((r - w[e]) / (C[e] - w[e]))
                  , L = d(w, C, I, s.stepped);
                L[e] = t[e],
                u.push(L)
            }
            return u.length === 1 ? u[0] : u
        }
        pathSegment(t, e, s) {
            return yd(this)(t, this, e, s)
        }
        path(t, e, s) {
            let r = this.segments
              , a = yd(this)
              , l = this._loop;
            e = e || 0,
            s = s || this.points.length - e;
            for (let u of r)
                l &= a(t, this, u, {
                    start: e,
                    end: e + s - 1
                });
            return !!l
        }
        draw(t, e, s, r) {
            let a = this.options || {};
            (this.points || []).length && a.borderWidth && (t.save(),
            fS(t, this, s, r),
            t.restore()),
            this.animated && (this._pointsUpdated = !1,
            this._path = void 0)
        }
    }
    ;
    Gi.id = "line";
    Gi.defaults = {
        borderCapStyle: "butt",
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: "miter",
        borderWidth: 3,
        capBezierPoints: !0,
        cubicInterpolationMode: "default",
        fill: !1,
        spanGaps: !1,
        stepped: !1,
        tension: 0
    };
    Gi.defaultRoutes = {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
    };
    Gi.descriptors = {
        _scriptable: !0,
        _indexable: o(n => n !== "borderDash" && n !== "fill", "_indexable")
    };
    function Sg(n, t, e, s) {
        let r = n.options
          , {[e]: a} = n.getProps([e], s);
        return Math.abs(t - a) < r.radius + r.hitRadius
    }
    o(Sg, "inRange$1");
    var yr = class extends li {
        static{o(this, "PointElement")
        }constructor(t) {
            super(),
            this.options = void 0,
            this.parsed = void 0,
            this.skip = void 0,
            this.stop = void 0,
            t && Object.assign(this, t)
        }
        inRange(t, e, s) {
            let r = this.options
              , {x: a, y: l} = this.getProps(["x", "y"], s);
            return Math.pow(t - a, 2) + Math.pow(e - l, 2) < Math.pow(r.hitRadius + r.radius, 2)
        }
        inXRange(t, e) {
            return Sg(this, t, "x", e)
        }
        inYRange(t, e) {
            return Sg(this, t, "y", e)
        }
        getCenterPoint(t) {
            let {x: e, y: s} = this.getProps(["x", "y"], t);
            return {
                x: e,
                y: s
            }
        }
        size(t) {
            t = t || this.options || {};
            let e = t.radius || 0;
            e = Math.max(e, e && t.hoverRadius || 0);
            let s = e && t.borderWidth || 0;
            return (e + s) * 2
        }
        draw(t, e) {
            let s = this.options;
            this.skip || s.radius < .1 || !ir(this, e, this.size(s) / 2) || (t.strokeStyle = s.borderColor,
            t.lineWidth = s.borderWidth,
            t.fillStyle = s.backgroundColor,
            Ua(t, s, this.x, this.y))
        }
        getRange() {
            let t = this.options || {};
            return t.radius + t.hitRadius
        }
    }
    ;
    yr.id = "point";
    yr.defaults = {
        borderWidth: 1,
        hitRadius: 1,
        hoverBorderWidth: 1,
        hoverRadius: 4,
        pointStyle: "circle",
        radius: 3,
        rotation: 0
    };
    yr.defaultRoutes = {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
    };
    function nm(n, t) {
        let {x: e, y: s, base: r, width: a, height: l} = n.getProps(["x", "y", "base", "width", "height"], t), u, d, p, b, E;
        return n.horizontal ? (E = l / 2,
        u = Math.min(e, r),
        d = Math.max(e, r),
        p = s - E,
        b = s + E) : (E = a / 2,
        u = e - E,
        d = e + E,
        p = Math.min(s, r),
        b = Math.max(s, r)),
        {
            left: u,
            top: p,
            right: d,
            bottom: b
        }
    }
    o(nm, "getBarBounds");
    function qn(n, t, e, s) {
        return n ? 0 : be(t, e, s)
    }
    o(qn, "skipOrLimit");
    function pS(n, t, e) {
        let s = n.options.borderWidth
          , r = n.borderSkipped
          , a = Wh(s);
        return {
            t: qn(r.top, a.top, 0, e),
            r: qn(r.right, a.right, 0, t),
            b: qn(r.bottom, a.bottom, 0, e),
            l: qn(r.left, a.left, 0, t)
        }
    }
    o(pS, "parseBorderWidth");
    function gS(n, t, e) {
        let {enableBorderRadius: s} = n.getProps(["enableBorderRadius"])
          , r = n.options.borderRadius
          , a = jn(r)
          , l = Math.min(t, e)
          , u = n.borderSkipped
          , d = s || Ht(r);
        return {
            topLeft: qn(!d || u.top || u.left, a.topLeft, 0, l),
            topRight: qn(!d || u.top || u.right, a.topRight, 0, l),
            bottomLeft: qn(!d || u.bottom || u.left, a.bottomLeft, 0, l),
            bottomRight: qn(!d || u.bottom || u.right, a.bottomRight, 0, l)
        }
    }
    o(gS, "parseBorderRadius");
    function mS(n) {
        let t = nm(n)
          , e = t.right - t.left
          , s = t.bottom - t.top
          , r = pS(n, e / 2, s / 2)
          , a = gS(n, e / 2, s / 2);
        return {
            outer: {
                x: t.left,
                y: t.top,
                w: e,
                h: s,
                radius: a
            },
            inner: {
                x: t.left + r.l,
                y: t.top + r.t,
                w: e - r.l - r.r,
                h: s - r.t - r.b,
                radius: {
                    topLeft: Math.max(0, a.topLeft - Math.max(r.t, r.l)),
                    topRight: Math.max(0, a.topRight - Math.max(r.t, r.r)),
                    bottomLeft: Math.max(0, a.bottomLeft - Math.max(r.b, r.l)),
                    bottomRight: Math.max(0, a.bottomRight - Math.max(r.b, r.r))
                }
            }
        }
    }
    o(mS, "boundingRects");
    function od(n, t, e, s) {
        let r = t === null
          , a = e === null
          , u = n && !(r && a) && nm(n, s);
        return u && (r || Ki(t, u.left, u.right)) && (a || Ki(e, u.top, u.bottom))
    }
    o(od, "inRange");
    function vS(n) {
        return n.topLeft || n.topRight || n.bottomLeft || n.bottomRight
    }
    o(vS, "hasRadius");
    function bS(n, t) {
        n.rect(t.x, t.y, t.w, t.h)
    }
    o(bS, "addNormalRectPath");
    function ad(n, t, e={}) {
        let s = n.x !== e.x ? -t : 0
          , r = n.y !== e.y ? -t : 0
          , a = (n.x + n.w !== e.x + e.w ? t : 0) - s
          , l = (n.y + n.h !== e.y + e.h ? t : 0) - r;
        return {
            x: n.x + s,
            y: n.y + r,
            w: n.w + a,
            h: n.h + l,
            radius: n.radius
        }
    }
    o(ad, "inflateRect");
    var _r = class extends li {
        static{o(this, "BarElement")
        }constructor(t) {
            super(),
            this.options = void 0,
            this.horizontal = void 0,
            this.base = void 0,
            this.width = void 0,
            this.height = void 0,
            this.inflateAmount = void 0,
            t && Object.assign(this, t)
        }
        draw(t) {
            let {inflateAmount: e, options: {borderColor: s, backgroundColor: r}} = this
              , {inner: a, outer: l} = mS(this)
              , u = vS(l.radius) ? ar : bS;
            t.save(),
            (l.w !== a.w || l.h !== a.h) && (t.beginPath(),
            u(t, ad(l, e, a)),
            t.clip(),
            u(t, ad(a, -e, l)),
            t.fillStyle = s,
            t.fill("evenodd")),
            t.beginPath(),
            u(t, ad(a, e)),
            t.fillStyle = r,
            t.fill(),
            t.restore()
        }
        inRange(t, e, s) {
            return od(this, t, e, s)
        }
        inXRange(t, e) {
            return od(this, t, null, e)
        }
        inYRange(t, e) {
            return od(this, null, t, e)
        }
        getCenterPoint(t) {
            let {x: e, y: s, base: r, horizontal: a} = this.getProps(["x", "y", "base", "horizontal"], t);
            return {
                x: a ? (e + r) / 2 : e,
                y: a ? s : (s + r) / 2
            }
        }
        getRange(t) {
            return t === "x" ? this.width / 2 : this.height / 2
        }
    }
    ;
    _r.id = "bar";
    _r.defaults = {
        borderSkipped: "start",
        borderWidth: 0,
        borderRadius: 0,
        inflateAmount: "auto",
        pointStyle: void 0
    };
    _r.defaultRoutes = {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
    };
    var yS = Object.freeze({
        __proto__: null,
        ArcElement: br,
        LineElement: Gi,
        PointElement: yr,
        BarElement: _r
    });
    function _S(n, t, e, s, r) {
        let a = r.samples || s;
        if (a >= e)
            return n.slice(t, t + e);
        let l = [], u = (e - 2) / (a - 2), d = 0, p = t + e - 1, b = t, E, x, w, C, I;
        for (l[d++] = n[b],
        E = 0; E < a - 2; E++) {
            let L = 0, k = 0, F, z = Math.floor((E + 1) * u) + 1 + t, j = Math.min(Math.floor((E + 2) * u) + 1, e) + t, H = j - z;
            for (F = z; F < j; F++)
                L += n[F].x,
                k += n[F].y;
            L /= H,
            k /= H;
            let f = Math.floor(E * u) + 1 + t
              , Y = Math.min(Math.floor((E + 1) * u) + 1, e) + t
              , {x: Q, y: ot} = n[b];
            for (w = C = -1,
            F = f; F < Y; F++)
                C = .5 * Math.abs((Q - L) * (n[F].y - ot) - (Q - n[F].x) * (k - ot)),
                C > w && (w = C,
                x = n[F],
                I = F);
            l[d++] = x,
            b = I
        }
        return l[d++] = n[p],
        l
    }
    o(_S, "lttbDecimation");
    function ES(n, t, e, s) {
        let r = 0, a = 0, l, u, d, p, b, E, x, w, C, I, L = [], k = t + e - 1, F = n[t].x, j = n[k].x - F;
        for (l = t; l < t + e; ++l) {
            u = n[l],
            d = (u.x - F) / j * s,
            p = u.y;
            let H = d | 0;
            if (H === b)
                p < C ? (C = p,
                E = l) : p > I && (I = p,
                x = l),
                r = (a * r + u.x) / ++a;
            else {
                let f = l - 1;
                if (!zt(E) && !zt(x)) {
                    let Y = Math.min(E, x)
                      , Q = Math.max(E, x);
                    Y !== w && Y !== f && L.push({
                        ...n[Y],
                        x: r
                    }),
                    Q !== w && Q !== f && L.push({
                        ...n[Q],
                        x: r
                    })
                }
                l > 0 && f !== w && L.push(n[f]),
                L.push(u),
                b = H,
                a = 0,
                C = I = p,
                E = x = w = l
            }
        }
        return L
    }
    o(ES, "minMaxDecimation");
    function sm(n) {
        if (n._decimated) {
            let t = n._data;
            delete n._decimated,
            delete n._data,
            Object.defineProperty(n, "data", {
                value: t
            })
        }
    }
    o(sm, "cleanDecimatedDataset");
    function Tg(n) {
        n.data.datasets.forEach(t => {
            sm(t)
        }
        )
    }
    o(Tg, "cleanDecimatedData");
    function SS(n, t) {
        let e = t.length, s = 0, r, {iScale: a} = n, {min: l, max: u, minDefined: d, maxDefined: p} = a.getUserBounds();
        return d && (s = be(zi(t, a.axis, l).lo, 0, e - 1)),
        p ? r = be(zi(t, a.axis, u).hi + 1, s, e) - s : r = e - s,
        {
            start: s,
            count: r
        }
    }
    o(SS, "getStartAndCountOfVisiblePointsSimplified");
    var TS = {
        id: "decimation",
        defaults: {
            algorithm: "min-max",
            enabled: !1
        },
        beforeElementsUpdate: o( (n, t, e) => {
            if (!e.enabled) {
                Tg(n);
                return
            }
            let s = n.width;
            n.data.datasets.forEach( (r, a) => {
                let {_data: l, indexAxis: u} = r
                  , d = n.getDatasetMeta(a)
                  , p = l || r.data;
                if (lr([u, n.options.indexAxis]) === "y" || !d.controller.supportsDecimation)
                    return;
                let b = n.scales[d.xAxisID];
                if (b.type !== "linear" && b.type !== "time" || n.options.parsing)
                    return;
                let {start: E, count: x} = SS(d, p)
                  , w = e.threshold || 4 * s;
                if (x <= w) {
                    sm(r);
                    return
                }
                zt(l) && (r._data = p,
                delete r.data,
                Object.defineProperty(r, "data", {
                    configurable: !0,
                    enumerable: !0,
                    get: o(function() {
                        return this._decimated
                    }, "get"),
                    set: o(function(I) {
                        this._data = I
                    }, "set")
                }));
                let C;
                switch (e.algorithm) {
                case "lttb":
                    C = _S(p, E, x, s, e);
                    break;
                case "min-max":
                    C = ES(p, E, x, s);
                    break;
                default:
                    throw new Error(`Unsupported decimation algorithm '${e.algorithm}'`)
                }
                r._decimated = C
            }
            )
        }
        , "beforeElementsUpdate"),
        destroy(n) {
            Tg(n)
        }
    };
    function xS(n, t, e) {
        let s = n.segments
          , r = n.points
          , a = t.points
          , l = [];
        for (let u of s) {
            let {start: d, end: p} = u;
            p = Sd(d, p, r);
            let b = _d(e, r[d], r[p], u.loop);
            if (!t.segments) {
                l.push({
                    source: u,
                    target: b,
                    start: r[d],
                    end: r[p]
                });
                continue
            }
            let E = Zh(t, b);
            for (let x of E) {
                let w = _d(e, a[x.start], a[x.end], x.loop)
                  , C = Jh(u, r, w);
                for (let I of C)
                    l.push({
                        source: I,
                        target: x,
                        start: {
                            [e]: xg(b, w, "start", Math.max)
                        },
                        end: {
                            [e]: xg(b, w, "end", Math.min)
                        }
                    })
            }
        }
        return l
    }
    o(xS, "_segments");
    function _d(n, t, e, s) {
        if (s)
            return;
        let r = t[n]
          , a = e[n];
        return n === "angle" && (r = ze(r),
        a = ze(a)),
        {
            property: n,
            start: r,
            end: a
        }
    }
    o(_d, "_getBounds");
    function wS(n, t) {
        let {x: e=null, y: s=null} = n || {}
          , r = t.points
          , a = [];
        return t.segments.forEach( ({start: l, end: u}) => {
            u = Sd(l, u, r);
            let d = r[l]
              , p = r[u];
            s !== null ? (a.push({
                x: d.x,
                y: s
            }),
            a.push({
                x: p.x,
                y: s
            })) : e !== null && (a.push({
                x: e,
                y: d.y
            }),
            a.push({
                x: e,
                y: p.y
            }))
        }
        ),
        a
    }
    o(wS, "_pointsFromSegments");
    function Sd(n, t, e) {
        for (; t > n; t--) {
            let s = e[t];
            if (!isNaN(s.x) && !isNaN(s.y))
                break
        }
        return t
    }
    o(Sd, "_findSegmentEnd");
    function xg(n, t, e, s) {
        return n && t ? s(n[e], t[e]) : n ? n[e] : t ? t[e] : 0
    }
    o(xg, "_getEdge");
    function rm(n, t) {
        let e = []
          , s = !1;
        return ee(n) ? (s = !0,
        e = n) : e = wS(n, t),
        e.length ? new Gi({
            points: e,
            options: {
                tension: 0
            },
            _loop: s,
            _fullLoop: s
        }) : null
    }
    o(rm, "_createBoundaryLine");
    function wg(n) {
        return n && n.fill !== !1
    }
    o(wg, "_shouldApplyFill");
    function CS(n, t, e) {
        let r = n[t].fill, a = [t], l;
        if (!e)
            return r;
        for (; r !== !1 && a.indexOf(r) === -1; ) {
            if (!fe(r))
                return r;
            if (l = n[r],
            !l)
                return !1;
            if (l.visible)
                return r;
            a.push(r),
            r = l.fill
        }
        return !1
    }
    o(CS, "_resolveTarget");
    function AS(n, t, e) {
        let s = LS(n);
        if (Ht(s))
            return isNaN(s.value) ? !1 : s;
        let r = parseFloat(s);
        return fe(r) && Math.floor(r) === r ? kS(s[0], t, r, e) : ["origin", "start", "end", "stack", "shape"].indexOf(s) >= 0 && s
    }
    o(AS, "_decodeFill");
    function kS(n, t, e, s) {
        return (n === "-" || n === "+") && (e = t + e),
        e === t || e < 0 || e >= s ? !1 : e
    }
    o(kS, "decodeTargetIndex");
    function MS(n, t) {
        let e = null;
        return n === "start" ? e = t.bottom : n === "end" ? e = t.top : Ht(n) ? e = t.getPixelForValue(n.value) : t.getBasePixel && (e = t.getBasePixel()),
        e
    }
    o(MS, "_getTargetPixel");
    function OS(n, t, e) {
        let s;
        return n === "start" ? s = e : n === "end" ? s = t.options.reverse ? t.min : t.max : Ht(n) ? s = n.value : s = t.getBaseValue(),
        s
    }
    o(OS, "_getTargetValue");
    function LS(n) {
        let t = n.options
          , e = t.fill
          , s = It(e && e.target, e);
        return s === void 0 && (s = !!t.backgroundColor),
        s === !1 || s === null ? !1 : s === !0 ? "origin" : s
    }
    o(LS, "parseFillOption");
    function DS(n) {
        let {scale: t, index: e, line: s} = n
          , r = []
          , a = s.segments
          , l = s.points
          , u = PS(t, e);
        u.push(rm({
            x: null,
            y: t.bottom
        }, s));
        for (let d = 0; d < a.length; d++) {
            let p = a[d];
            for (let b = p.start; b <= p.end; b++)
                RS(r, l[b], u)
        }
        return new Gi({
            points: r,
            options: {}
        })
    }
    o(DS, "_buildStackLine");
    function PS(n, t) {
        let e = []
          , s = n.getMatchingVisibleMetas("line");
        for (let r = 0; r < s.length; r++) {
            let a = s[r];
            if (a.index === t)
                break;
            a.hidden || e.unshift(a.dataset)
        }
        return e
    }
    o(PS, "getLinesBelow");
    function RS(n, t, e) {
        let s = [];
        for (let r = 0; r < e.length; r++) {
            let a = e[r]
              , {first: l, last: u, point: d} = IS(a, t, "x");
            if (!(!d || l && u)) {
                if (l)
                    s.unshift(d);
                else if (n.push(d),
                !u)
                    break
            }
        }
        n.push(...s)
    }
    o(RS, "addPointsBelow");
    function IS(n, t, e) {
        let s = n.interpolate(t, e);
        if (!s)
            return {};
        let r = s[e]
          , a = n.segments
          , l = n.points
          , u = !1
          , d = !1;
        for (let p = 0; p < a.length; p++) {
            let b = a[p]
              , E = l[b.start][e]
              , x = l[b.end][e];
            if (Ki(r, E, x)) {
                u = r === E,
                d = r === x;
                break
            }
        }
        return {
            first: u,
            last: d,
            point: s
        }
    }
    o(IS, "findPoint");
    var ll = class {
        static{o(this, "simpleArc")
        }constructor(t) {
            this.x = t.x,
            this.y = t.y,
            this.radius = t.radius
        }
        pathSegment(t, e, s) {
            let {x: r, y: a, radius: l} = this;
            return e = e || {
                start: 0,
                end: te
            },
            t.arc(r, a, l, e.end, e.start, !0),
            !s.bounds
        }
        interpolate(t) {
            let {x: e, y: s, radius: r} = this
              , a = t.angle;
            return {
                x: e + Math.cos(a) * r,
                y: s + Math.sin(a) * r,
                angle: a
            }
        }
    }
    ;
    function NS(n) {
        let {chart: t, fill: e, line: s} = n;
        if (fe(e))
            return FS(t, e);
        if (e === "stack")
            return DS(n);
        if (e === "shape")
            return !0;
        let r = VS(n);
        return r instanceof ll ? r : rm(r, s)
    }
    o(NS, "_getTarget");
    function FS(n, t) {
        let e = n.getDatasetMeta(t);
        return e && n.isDatasetVisible(t) ? e.dataset : null
    }
    o(FS, "getLineByIndex");
    function VS(n) {
        return (n.scale || {}).getPointPositionForValue ? HS(n) : BS(n)
    }
    o(VS, "computeBoundary");
    function BS(n) {
        let {scale: t={}, fill: e} = n
          , s = MS(e, t);
        if (fe(s)) {
            let r = t.isHorizontal();
            return {
                x: r ? s : null,
                y: r ? null : s
            }
        }
        return null
    }
    o(BS, "computeLinearBoundary");
    function HS(n) {
        let {scale: t, fill: e} = n
          , s = t.options
          , r = t.getLabels().length
          , a = s.reverse ? t.max : t.min
          , l = OS(e, t, a)
          , u = [];
        if (s.grid.circular) {
            let d = t.getPointPositionForValue(0, a);
            return new ll({
                x: d.x,
                y: d.y,
                radius: t.getDistanceFromCenterForValue(l)
            })
        }
        for (let d = 0; d < r; ++d)
            u.push(t.getPointPositionForValue(d, l));
        return u
    }
    o(HS, "computeCircularBoundary");
    function ld(n, t, e) {
        let s = NS(t)
          , {line: r, scale: a, axis: l} = t
          , u = r.options
          , d = u.fill
          , p = u.backgroundColor
          , {above: b=p, below: E=p} = d || {};
        s && r.points.length && (bo(n, e),
        jS(n, {
            line: r,
            target: s,
            above: b,
            below: E,
            area: e,
            scale: a,
            axis: l
        }),
        yo(n))
    }
    o(ld, "_drawfill");
    function jS(n, t) {
        let {line: e, target: s, above: r, below: a, area: l, scale: u} = t
          , d = e._loop ? "angle" : t.axis;
        n.save(),
        d === "x" && a !== r && (Cg(n, s, l.top),
        Ag(n, {
            line: e,
            target: s,
            color: r,
            scale: u,
            property: d
        }),
        n.restore(),
        n.save(),
        Cg(n, s, l.bottom)),
        Ag(n, {
            line: e,
            target: s,
            color: a,
            scale: u,
            property: d
        }),
        n.restore()
    }
    o(jS, "doFill");
    function Cg(n, t, e) {
        let {segments: s, points: r} = t
          , a = !0
          , l = !1;
        n.beginPath();
        for (let u of s) {
            let {start: d, end: p} = u
              , b = r[d]
              , E = r[Sd(d, p, r)];
            a ? (n.moveTo(b.x, b.y),
            a = !1) : (n.lineTo(b.x, e),
            n.lineTo(b.x, b.y)),
            l = !!t.pathSegment(n, u, {
                move: l
            }),
            l ? n.closePath() : n.lineTo(E.x, e)
        }
        n.lineTo(t.first().x, e),
        n.closePath(),
        n.clip()
    }
    o(Cg, "clipVertical");
    function Ag(n, t) {
        let {line: e, target: s, property: r, color: a, scale: l} = t
          , u = xS(e, s, r);
        for (let {source: d, target: p, start: b, end: E} of u) {
            let {style: {backgroundColor: x=a}={}} = d
              , w = s !== !0;
            n.save(),
            n.fillStyle = x,
            WS(n, l, w && _d(r, b, E)),
            n.beginPath();
            let C = !!e.pathSegment(n, d), I;
            if (w) {
                C ? n.closePath() : kg(n, s, E, r);
                let L = !!s.pathSegment(n, p, {
                    move: C,
                    reverse: !0
                });
                I = C && L,
                I || kg(n, s, b, r)
            }
            n.closePath(),
            n.fill(I ? "evenodd" : "nonzero"),
            n.restore()
        }
    }
    o(Ag, "fill");
    function WS(n, t, e) {
        let {top: s, bottom: r} = t.chart.chartArea
          , {property: a, start: l, end: u} = e || {};
        a === "x" && (n.beginPath(),
        n.rect(l, s, u - l, r - s),
        n.clip())
    }
    o(WS, "clipBounds");
    function kg(n, t, e, s) {
        let r = t.interpolate(e, s);
        r && n.lineTo(r.x, r.y)
    }
    o(kg, "interpolatedLineTo");
    var $S = {
        id: "filler",
        afterDatasetsUpdate(n, t, e) {
            let s = (n.data.datasets || []).length, r = [], a, l, u, d;
            for (l = 0; l < s; ++l)
                a = n.getDatasetMeta(l),
                u = a.dataset,
                d = null,
                u && u.options && u instanceof Gi && (d = {
                    visible: n.isDatasetVisible(l),
                    index: l,
                    fill: AS(u, l, s),
                    chart: n,
                    axis: a.controller.options.indexAxis,
                    scale: a.vScale,
                    line: u
                }),
                a.$filler = d,
                r.push(d);
            for (l = 0; l < s; ++l)
                d = r[l],
                !(!d || d.fill === !1) && (d.fill = CS(r, l, e.propagate))
        },
        beforeDraw(n, t, e) {
            let s = e.drawTime === "beforeDraw"
              , r = n.getSortedVisibleDatasetMetas()
              , a = n.chartArea;
            for (let l = r.length - 1; l >= 0; --l) {
                let u = r[l].$filler;
                u && (u.line.updateControlPoints(a, u.axis),
                s && u.fill && ld(n.ctx, u, a))
            }
        },
        beforeDatasetsDraw(n, t, e) {
            if (e.drawTime !== "beforeDatasetsDraw")
                return;
            let s = n.getSortedVisibleDatasetMetas();
            for (let r = s.length - 1; r >= 0; --r) {
                let a = s[r].$filler;
                wg(a) && ld(n.ctx, a, n.chartArea)
            }
        },
        beforeDatasetDraw(n, t, e) {
            let s = t.meta.$filler;
            !wg(s) || e.drawTime !== "beforeDatasetDraw" || ld(n.ctx, s, n.chartArea)
        },
        defaults: {
            propagate: !0,
            drawTime: "beforeDatasetDraw"
        }
    }
      , Mg = o( (n, t) => {
        let {boxHeight: e=t, boxWidth: s=t} = n;
        return n.usePointStyle && (e = Math.min(e, t),
        s = n.pointStyleWidth || Math.min(s, t)),
        {
            boxWidth: s,
            boxHeight: e,
            itemHeight: Math.max(t, e)
        }
    }
    , "getBoxSize")
      , qS = o( (n, t) => n !== null && t !== null && n.datasetIndex === t.datasetIndex && n.index === t.index, "itemsEqual")
      , cl = class extends li {
        static{o(this, "Legend")
        }constructor(t) {
            super(),
            this._added = !1,
            this.legendHitBoxes = [],
            this._hoveredItem = null,
            this.doughnutMode = !1,
            this.chart = t.chart,
            this.options = t.options,
            this.ctx = t.ctx,
            this.legendItems = void 0,
            this.columnSizes = void 0,
            this.lineWidths = void 0,
            this.maxHeight = void 0,
            this.maxWidth = void 0,
            this.top = void 0,
            this.bottom = void 0,
            this.left = void 0,
            this.right = void 0,
            this.height = void 0,
            this.width = void 0,
            this._margins = void 0,
            this.position = void 0,
            this.weight = void 0,
            this.fullSize = void 0
        }
        update(t, e, s) {
            this.maxWidth = t,
            this.maxHeight = e,
            this._margins = s,
            this.setDimensions(),
            this.buildLabels(),
            this.fit()
        }
        setDimensions() {
            this.isHorizontal() ? (this.width = this.maxWidth,
            this.left = this._margins.left,
            this.right = this.width) : (this.height = this.maxHeight,
            this.top = this._margins.top,
            this.bottom = this.height)
        }
        buildLabels() {
            let t = this.options.labels || {}
              , e = ie(t.generateLabels, [this.chart], this) || [];
            t.filter && (e = e.filter(s => t.filter(s, this.chart.data))),
            t.sort && (e = e.sort( (s, r) => t.sort(s, r, this.chart.data))),
            this.options.reverse && e.reverse(),
            this.legendItems = e
        }
        fit() {
            let {options: t, ctx: e} = this;
            if (!t.display) {
                this.width = this.height = 0;
                return
            }
            let s = t.labels, r = ge(s.font), a = r.size, l = this._computeTitleHeight(), {boxWidth: u, itemHeight: d} = Mg(s, a), p, b;
            e.font = r.string,
            this.isHorizontal() ? (p = this.maxWidth,
            b = this._fitRows(l, a, u, d) + 10) : (b = this.maxHeight,
            p = this._fitCols(l, a, u, d) + 10),
            this.width = Math.min(p, t.maxWidth || this.maxWidth),
            this.height = Math.min(b, t.maxHeight || this.maxHeight)
        }
        _fitRows(t, e, s, r) {
            let {ctx: a, maxWidth: l, options: {labels: {padding: u}}} = this
              , d = this.legendHitBoxes = []
              , p = this.lineWidths = [0]
              , b = r + u
              , E = t;
            a.textAlign = "left",
            a.textBaseline = "middle";
            let x = -1
              , w = -b;
            return this.legendItems.forEach( (C, I) => {
                let L = s + e / 2 + a.measureText(C.text).width;
                (I === 0 || p[p.length - 1] + L + 2 * u > l) && (E += b,
                p[p.length - (I > 0 ? 0 : 1)] = 0,
                w += b,
                x++),
                d[I] = {
                    left: 0,
                    top: w,
                    row: x,
                    width: L,
                    height: r
                },
                p[p.length - 1] += L + u
            }
            ),
            E
        }
        _fitCols(t, e, s, r) {
            let {ctx: a, maxHeight: l, options: {labels: {padding: u}}} = this
              , d = this.legendHitBoxes = []
              , p = this.columnSizes = []
              , b = l - t
              , E = u
              , x = 0
              , w = 0
              , C = 0
              , I = 0;
            return this.legendItems.forEach( (L, k) => {
                let F = s + e / 2 + a.measureText(L.text).width;
                k > 0 && w + r + 2 * u > b && (E += x + u,
                p.push({
                    width: x,
                    height: w
                }),
                C += x + u,
                I++,
                x = w = 0),
                d[k] = {
                    left: C,
                    top: w,
                    col: I,
                    width: F,
                    height: r
                },
                x = Math.max(x, F),
                w += r + u
            }
            ),
            E += x,
            p.push({
                width: x,
                height: w
            }),
            E
        }
        adjustHitBoxes() {
            if (!this.options.display)
                return;
            let t = this._computeTitleHeight()
              , {legendHitBoxes: e, options: {align: s, labels: {padding: r}, rtl: a}} = this
              , l = vs(a, this.left, this.width);
            if (this.isHorizontal()) {
                let u = 0
                  , d = ke(s, this.left + r, this.right - this.lineWidths[u]);
                for (let p of e)
                    u !== p.row && (u = p.row,
                    d = ke(s, this.left + r, this.right - this.lineWidths[u])),
                    p.top += this.top + t + r,
                    p.left = l.leftForLtr(l.x(d), p.width),
                    d += p.width + r
            } else {
                let u = 0
                  , d = ke(s, this.top + t + r, this.bottom - this.columnSizes[u].height);
                for (let p of e)
                    p.col !== u && (u = p.col,
                    d = ke(s, this.top + t + r, this.bottom - this.columnSizes[u].height)),
                    p.top = d,
                    p.left += this.left + r,
                    p.left = l.leftForLtr(l.x(p.left), p.width),
                    d += p.height + r
            }
        }
        isHorizontal() {
            return this.options.position === "top" || this.options.position === "bottom"
        }
        draw() {
            if (this.options.display) {
                let t = this.ctx;
                bo(t, this),
                this._draw(),
                yo(t)
            }
        }
        _draw() {
            let {options: t, columnSizes: e, lineWidths: s, ctx: r} = this, {align: a, labels: l} = t, u = jt.color, d = vs(t.rtl, this.left, this.width), p = ge(l.font), {color: b, padding: E} = l, x = p.size, w = x / 2, C;
            this.drawTitle(),
            r.textAlign = d.textAlign("left"),
            r.textBaseline = "middle",
            r.lineWidth = .5,
            r.font = p.string;
            let {boxWidth: I, boxHeight: L, itemHeight: k} = Mg(l, x)
              , F = o(function(Y, Q, ot) {
                if (isNaN(I) || I <= 0 || isNaN(L) || L < 0)
                    return;
                r.save();
                let mt = It(ot.lineWidth, 1);
                if (r.fillStyle = It(ot.fillStyle, u),
                r.lineCap = It(ot.lineCap, "butt"),
                r.lineDashOffset = It(ot.lineDashOffset, 0),
                r.lineJoin = It(ot.lineJoin, "miter"),
                r.lineWidth = mt,
                r.strokeStyle = It(ot.strokeStyle, u),
                r.setLineDash(It(ot.lineDash, [])),
                l.usePointStyle) {
                    let bt = {
                        radius: L * Math.SQRT2 / 2,
                        pointStyle: ot.pointStyle,
                        rotation: ot.rotation,
                        borderWidth: mt
                    }
                      , ft = d.xPlus(Y, I / 2)
                      , $t = Q + w;
                    jh(r, bt, ft, $t, l.pointStyleWidth && I)
                } else {
                    let bt = Q + Math.max((x - L) / 2, 0)
                      , ft = d.leftForLtr(Y, I)
                      , $t = jn(ot.borderRadius);
                    r.beginPath(),
                    Object.values($t).some(Ut => Ut !== 0) ? ar(r, {
                        x: ft,
                        y: bt,
                        w: I,
                        h: L,
                        radius: $t
                    }) : r.rect(ft, bt, I, L),
                    r.fill(),
                    mt !== 0 && r.stroke()
                }
                r.restore()
            }, "drawLegendBox")
              , z = o(function(Y, Q, ot) {
                Hn(r, ot.text, Y, Q + k / 2, p, {
                    strikethrough: ot.hidden,
                    textAlign: d.textAlign(ot.textAlign)
                })
            }, "fillText")
              , j = this.isHorizontal()
              , H = this._computeTitleHeight();
            j ? C = {
                x: ke(a, this.left + E, this.right - s[0]),
                y: this.top + E + H,
                line: 0
            } : C = {
                x: this.left + E,
                y: ke(a, this.top + H + E, this.bottom - e[0].height),
                line: 0
            },
            Gh(this.ctx, t.textDirection);
            let f = k + E;
            this.legendItems.forEach( (Y, Q) => {
                r.strokeStyle = Y.fontColor || b,
                r.fillStyle = Y.fontColor || b;
                let ot = r.measureText(Y.text).width
                  , mt = d.textAlign(Y.textAlign || (Y.textAlign = l.textAlign))
                  , bt = I + w + ot
                  , ft = C.x
                  , $t = C.y;
                d.setWidth(this.width),
                j ? Q > 0 && ft + bt + E > this.right && ($t = C.y += f,
                C.line++,
                ft = C.x = ke(a, this.left + E, this.right - s[C.line])) : Q > 0 && $t + f > this.bottom && (ft = C.x = ft + e[C.line].width + E,
                C.line++,
                $t = C.y = ke(a, this.top + H + E, this.bottom - e[C.line].height));
                let Ut = d.x(ft);
                F(Ut, $t, Y),
                ft = Op(mt, ft + I + w, j ? ft + bt : this.right, t.rtl),
                z(d.x(ft), $t, Y),
                j ? C.x += bt + E : C.y += f
            }
            ),
            Qh(this.ctx, t.textDirection)
        }
        drawTitle() {
            let t = this.options
              , e = t.title
              , s = ge(e.font)
              , r = Me(e.padding);
            if (!e.display)
                return;
            let a = vs(t.rtl, this.left, this.width), l = this.ctx, u = e.position, d = s.size / 2, p = r.top + d, b, E = this.left, x = this.width;
            if (this.isHorizontal())
                x = Math.max(...this.lineWidths),
                b = this.top + p,
                E = ke(t.align, E, this.right - x);
            else {
                let C = this.columnSizes.reduce( (I, L) => Math.max(I, L.height), 0);
                b = p + ke(t.align, this.top, this.bottom - C - t.labels.padding - this._computeTitleHeight())
            }
            let w = ke(u, E, E + x);
            l.textAlign = a.textAlign(qa(u)),
            l.textBaseline = "middle",
            l.strokeStyle = e.color,
            l.fillStyle = e.color,
            l.font = s.string,
            Hn(l, e.text, w, b, s)
        }
        _computeTitleHeight() {
            let t = this.options.title
              , e = ge(t.font)
              , s = Me(t.padding);
            return t.display ? e.lineHeight + s.height : 0
        }
        _getLegendItemAt(t, e) {
            let s, r, a;
            if (Ki(t, this.left, this.right) && Ki(e, this.top, this.bottom)) {
                for (a = this.legendHitBoxes,
                s = 0; s < a.length; ++s)
                    if (r = a[s],
                    Ki(t, r.left, r.left + r.width) && Ki(e, r.top, r.top + r.height))
                        return this.legendItems[s]
            }
            return null
        }
        handleEvent(t) {
            let e = this.options;
            if (!zS(t.type, e))
                return;
            let s = this._getLegendItemAt(t.x, t.y);
            if (t.type === "mousemove" || t.type === "mouseout") {
                let r = this._hoveredItem
                  , a = qS(r, s);
                r && !a && ie(e.onLeave, [t, r, this], this),
                this._hoveredItem = s,
                s && !a && ie(e.onHover, [t, s, this], this)
            } else
                s && ie(e.onClick, [t, s, this], this)
        }
    }
    ;
    function zS(n, t) {
        return !!((n === "mousemove" || n === "mouseout") && (t.onHover || t.onLeave) || t.onClick && (n === "click" || n === "mouseup"))
    }
    o(zS, "isListened");
    var US = {
        id: "legend",
        _element: cl,
        start(n, t, e) {
            let s = n.legend = new cl({
                ctx: n.ctx,
                options: e,
                chart: n
            });
            Pe.configure(n, s, e),
            Pe.addBox(n, s)
        },
        stop(n) {
            Pe.removeBox(n, n.legend),
            delete n.legend
        },
        beforeUpdate(n, t, e) {
            let s = n.legend;
            Pe.configure(n, s, e),
            s.options = e
        },
        afterUpdate(n) {
            let t = n.legend;
            t.buildLabels(),
            t.adjustHitBoxes()
        },
        afterEvent(n, t) {
            t.replay || n.legend.handleEvent(t.event)
        },
        defaults: {
            display: !0,
            position: "top",
            align: "center",
            fullSize: !0,
            reverse: !1,
            weight: 1e3,
            onClick(n, t, e) {
                let s = t.datasetIndex
                  , r = e.chart;
                r.isDatasetVisible(s) ? (r.hide(s),
                t.hidden = !0) : (r.show(s),
                t.hidden = !1)
            },
            onHover: null,
            onLeave: null,
            labels: {
                color: o(n => n.chart.options.color, "color"),
                boxWidth: 40,
                padding: 10,
                generateLabels(n) {
                    let t = n.data.datasets
                      , {labels: {usePointStyle: e, pointStyle: s, textAlign: r, color: a}} = n.legend.options;
                    return n._getSortedDatasetMetas().map(l => {
                        let u = l.controller.getStyle(e ? 0 : void 0)
                          , d = Me(u.borderWidth);
                        return {
                            text: t[l.index].label,
                            fillStyle: u.backgroundColor,
                            fontColor: a,
                            hidden: !l.visible,
                            lineCap: u.borderCapStyle,
                            lineDash: u.borderDash,
                            lineDashOffset: u.borderDashOffset,
                            lineJoin: u.borderJoinStyle,
                            lineWidth: (d.width + d.height) / 4,
                            strokeStyle: u.borderColor,
                            pointStyle: s || u.pointStyle,
                            rotation: u.rotation,
                            textAlign: r || u.textAlign,
                            borderRadius: 0,
                            datasetIndex: l.index
                        }
                    }
                    , this)
                }
            },
            title: {
                color: o(n => n.chart.options.color, "color"),
                display: !1,
                position: "center",
                text: ""
            }
        },
        descriptors: {
            _scriptable: o(n => !n.startsWith("on"), "_scriptable"),
            labels: {
                _scriptable: o(n => !["generateLabels", "filter", "sort"].includes(n), "_scriptable")
            }
        }
    }
      , Oo = class extends li {
        static{o(this, "Title")
        }constructor(t) {
            super(),
            this.chart = t.chart,
            this.options = t.options,
            this.ctx = t.ctx,
            this._padding = void 0,
            this.top = void 0,
            this.bottom = void 0,
            this.left = void 0,
            this.right = void 0,
            this.width = void 0,
            this.height = void 0,
            this.position = void 0,
            this.weight = void 0,
            this.fullSize = void 0
        }
        update(t, e) {
            let s = this.options;
            if (this.left = 0,
            this.top = 0,
            !s.display) {
                this.width = this.height = this.right = this.bottom = 0;
                return
            }
            this.width = this.right = t,
            this.height = this.bottom = e;
            let r = ee(s.text) ? s.text.length : 1;
            this._padding = Me(s.padding);
            let a = r * ge(s.font).lineHeight + this._padding.height;
            this.isHorizontal() ? this.height = a : this.width = a
        }
        isHorizontal() {
            let t = this.options.position;
            return t === "top" || t === "bottom"
        }
        _drawArgs(t) {
            let {top: e, left: s, bottom: r, right: a, options: l} = this, u = l.align, d = 0, p, b, E;
            return this.isHorizontal() ? (b = ke(u, s, a),
            E = e + t,
            p = a - s) : (l.position === "left" ? (b = s + t,
            E = ke(u, r, e),
            d = ae * -.5) : (b = a - t,
            E = ke(u, e, r),
            d = ae * .5),
            p = r - e),
            {
                titleX: b,
                titleY: E,
                maxWidth: p,
                rotation: d
            }
        }
        draw() {
            let t = this.ctx
              , e = this.options;
            if (!e.display)
                return;
            let s = ge(e.font)
              , a = s.lineHeight / 2 + this._padding.top
              , {titleX: l, titleY: u, maxWidth: d, rotation: p} = this._drawArgs(a);
            Hn(t, e.text, 0, 0, s, {
                color: e.color,
                maxWidth: d,
                rotation: p,
                textAlign: qa(e.align),
                textBaseline: "middle",
                translation: [l, u]
            })
        }
    }
    ;
    function KS(n, t) {
        let e = new Oo({
            ctx: n.ctx,
            options: t,
            chart: n
        });
        Pe.configure(n, e, t),
        Pe.addBox(n, e),
        n.titleBlock = e
    }
    o(KS, "createTitle");
    var YS = {
        id: "title",
        _element: Oo,
        start(n, t, e) {
            KS(n, e)
        },
        stop(n) {
            let t = n.titleBlock;
            Pe.removeBox(n, t),
            delete n.titleBlock
        },
        beforeUpdate(n, t, e) {
            let s = n.titleBlock;
            Pe.configure(n, s, e),
            s.options = e
        },
        defaults: {
            align: "center",
            display: !1,
            font: {
                weight: "bold"
            },
            fullSize: !0,
            padding: 10,
            position: "top",
            text: "",
            weight: 2e3
        },
        defaultRoutes: {
            color: "color"
        },
        descriptors: {
            _scriptable: !0,
            _indexable: !1
        }
    }
      , tl = new WeakMap
      , XS = {
        id: "subtitle",
        start(n, t, e) {
            let s = new Oo({
                ctx: n.ctx,
                options: e,
                chart: n
            });
            Pe.configure(n, s, e),
            Pe.addBox(n, s),
            tl.set(n, s)
        },
        stop(n) {
            Pe.removeBox(n, tl.get(n)),
            tl.delete(n)
        },
        beforeUpdate(n, t, e) {
            let s = tl.get(n);
            Pe.configure(n, s, e),
            s.options = e
        },
        defaults: {
            align: "center",
            display: !1,
            font: {
                weight: "normal"
            },
            fullSize: !0,
            padding: 0,
            position: "top",
            text: "",
            weight: 1500
        },
        defaultRoutes: {
            color: "color"
        },
        descriptors: {
            _scriptable: !0,
            _indexable: !1
        }
    }
      , Co = {
        average(n) {
            if (!n.length)
                return !1;
            let t, e, s = 0, r = 0, a = 0;
            for (t = 0,
            e = n.length; t < e; ++t) {
                let l = n[t].element;
                if (l && l.hasValue()) {
                    let u = l.tooltipPosition();
                    s += u.x,
                    r += u.y,
                    ++a
                }
            }
            return {
                x: s / a,
                y: r / a
            }
        },
        nearest(n, t) {
            if (!n.length)
                return !1;
            let e = t.x, s = t.y, r = Number.POSITIVE_INFINITY, a, l, u;
            for (a = 0,
            l = n.length; a < l; ++a) {
                let d = n[a].element;
                if (d && d.hasValue()) {
                    let p = d.getCenterPoint()
                      , b = Ba(t, p);
                    b < r && (r = b,
                    u = d)
                }
            }
            if (u) {
                let d = u.tooltipPosition();
                e = d.x,
                s = d.y
            }
            return {
                x: e,
                y: s
            }
        }
    };
    function Yi(n, t) {
        return t && (ee(t) ? Array.prototype.push.apply(n, t) : n.push(t)),
        n
    }
    o(Yi, "pushOrConcat");
    function bn(n) {
        return (typeof n == "string" || n instanceof String) && n.indexOf(`
`) > -1 ? n.split(`
`) : n
    }
    o(bn, "splitNewlines");
    function GS(n, t) {
        let {element: e, datasetIndex: s, index: r} = t
          , a = n.getDatasetMeta(s).controller
          , {label: l, value: u} = a.getLabelAndValue(r);
        return {
            chart: n,
            label: l,
            parsed: a.getParsed(r),
            raw: n.data.datasets[s].data[r],
            formattedValue: u,
            dataset: a.getDataset(),
            dataIndex: r,
            datasetIndex: s,
            element: e
        }
    }
    o(GS, "createTooltipItem");
    function Og(n, t) {
        let e = n.chart.ctx
          , {body: s, footer: r, title: a} = n
          , {boxWidth: l, boxHeight: u} = t
          , d = ge(t.bodyFont)
          , p = ge(t.titleFont)
          , b = ge(t.footerFont)
          , E = a.length
          , x = r.length
          , w = s.length
          , C = Me(t.padding)
          , I = C.height
          , L = 0
          , k = s.reduce( (j, H) => j + H.before.length + H.lines.length + H.after.length, 0);
        if (k += n.beforeBody.length + n.afterBody.length,
        E && (I += E * p.lineHeight + (E - 1) * t.titleSpacing + t.titleMarginBottom),
        k) {
            let j = t.displayColors ? Math.max(u, d.lineHeight) : d.lineHeight;
            I += w * j + (k - w) * d.lineHeight + (k - 1) * t.bodySpacing
        }
        x && (I += t.footerMarginTop + x * b.lineHeight + (x - 1) * t.footerSpacing);
        let F = 0
          , z = o(function(j) {
            L = Math.max(L, e.measureText(j).width + F)
        }, "maxLineWidth");
        return e.save(),
        e.font = p.string,
        Jt(n.title, z),
        e.font = d.string,
        Jt(n.beforeBody.concat(n.afterBody), z),
        F = t.displayColors ? l + 2 + t.boxPadding : 0,
        Jt(s, j => {
            Jt(j.before, z),
            Jt(j.lines, z),
            Jt(j.after, z)
        }
        ),
        F = 0,
        e.font = b.string,
        Jt(n.footer, z),
        e.restore(),
        L += C.width,
        {
            width: L,
            height: I
        }
    }
    o(Og, "getTooltipSize");
    function QS(n, t) {
        let {y: e, height: s} = t;
        return e < s / 2 ? "top" : e > n.height - s / 2 ? "bottom" : "center"
    }
    o(QS, "determineYAlign");
    function JS(n, t, e, s) {
        let {x: r, width: a} = s
          , l = e.caretSize + e.caretPadding;
        if (n === "left" && r + a + l > t.width || n === "right" && r - a - l < 0)
            return !0
    }
    o(JS, "doesNotFitWithAlign");
    function ZS(n, t, e, s) {
        let {x: r, width: a} = e
          , {width: l, chartArea: {left: u, right: d}} = n
          , p = "center";
        return s === "center" ? p = r <= (u + d) / 2 ? "left" : "right" : r <= a / 2 ? p = "left" : r >= l - a / 2 && (p = "right"),
        JS(p, n, t, e) && (p = "center"),
        p
    }
    o(ZS, "determineXAlign");
    function Lg(n, t, e) {
        let s = e.yAlign || t.yAlign || QS(n, e);
        return {
            xAlign: e.xAlign || t.xAlign || ZS(n, t, e, s),
            yAlign: s
        }
    }
    o(Lg, "determineAlignment");
    function tT(n, t) {
        let {x: e, width: s} = n;
        return t === "right" ? e -= s : t === "center" && (e -= s / 2),
        e
    }
    o(tT, "alignX");
    function eT(n, t, e) {
        let {y: s, height: r} = n;
        return t === "top" ? s += e : t === "bottom" ? s -= r + e : s -= r / 2,
        s
    }
    o(eT, "alignY");
    function Dg(n, t, e, s) {
        let {caretSize: r, caretPadding: a, cornerRadius: l} = n
          , {xAlign: u, yAlign: d} = e
          , p = r + a
          , {topLeft: b, topRight: E, bottomLeft: x, bottomRight: w} = jn(l)
          , C = tT(t, u)
          , I = eT(t, d, p);
        return d === "center" ? u === "left" ? C += p : u === "right" && (C -= p) : u === "left" ? C -= Math.max(b, x) + r : u === "right" && (C += Math.max(E, w) + r),
        {
            x: be(C, 0, s.width - t.width),
            y: be(I, 0, s.height - t.height)
        }
    }
    o(Dg, "getBackgroundPoint");
    function el(n, t, e) {
        let s = Me(e.padding);
        return t === "center" ? n.x + n.width / 2 : t === "right" ? n.x + n.width - s.right : n.x + s.left
    }
    o(el, "getAlignedX");
    function Pg(n) {
        return Yi([], bn(n))
    }
    o(Pg, "getBeforeAfterBodyLines");
    function iT(n, t, e) {
        return mn(n, {
            tooltip: t,
            tooltipItems: e,
            type: "tooltip"
        })
    }
    o(iT, "createTooltipContext");
    function Rg(n, t) {
        let e = t && t.dataset && t.dataset.tooltip && t.dataset.tooltip.callbacks;
        return e ? n.override(e) : n
    }
    o(Rg, "overrideCallbacks");
    var Lo = class extends li {
        static{o(this, "Tooltip")
        }constructor(t) {
            super(),
            this.opacity = 0,
            this._active = [],
            this._eventPosition = void 0,
            this._size = void 0,
            this._cachedAnimations = void 0,
            this._tooltipItems = [],
            this.$animations = void 0,
            this.$context = void 0,
            this.chart = t.chart || t._chart,
            this._chart = this.chart,
            this.options = t.options,
            this.dataPoints = void 0,
            this.title = void 0,
            this.beforeBody = void 0,
            this.body = void 0,
            this.afterBody = void 0,
            this.footer = void 0,
            this.xAlign = void 0,
            this.yAlign = void 0,
            this.x = void 0,
            this.y = void 0,
            this.height = void 0,
            this.width = void 0,
            this.caretX = void 0,
            this.caretY = void 0,
            this.labelColors = void 0,
            this.labelPointStyles = void 0,
            this.labelTextColors = void 0
        }
        initialize(t) {
            this.options = t,
            this._cachedAnimations = void 0,
            this.$context = void 0
        }
        _resolveAnimations() {
            let t = this._cachedAnimations;
            if (t)
                return t;
            let e = this.chart
              , s = this.options.setContext(this.getContext())
              , r = s.enabled && e.options.animation && s.animations
              , a = new sl(this.chart,r);
            return r._cacheable && (this._cachedAnimations = Object.freeze(a)),
            a
        }
        getContext() {
            return this.$context || (this.$context = iT(this.chart.getContext(), this, this._tooltipItems))
        }
        getTitle(t, e) {
            let {callbacks: s} = e
              , r = s.beforeTitle.apply(this, [t])
              , a = s.title.apply(this, [t])
              , l = s.afterTitle.apply(this, [t])
              , u = [];
            return u = Yi(u, bn(r)),
            u = Yi(u, bn(a)),
            u = Yi(u, bn(l)),
            u
        }
        getBeforeBody(t, e) {
            return Pg(e.callbacks.beforeBody.apply(this, [t]))
        }
        getBody(t, e) {
            let {callbacks: s} = e
              , r = [];
            return Jt(t, a => {
                let l = {
                    before: [],
                    lines: [],
                    after: []
                }
                  , u = Rg(s, a);
                Yi(l.before, bn(u.beforeLabel.call(this, a))),
                Yi(l.lines, u.label.call(this, a)),
                Yi(l.after, bn(u.afterLabel.call(this, a))),
                r.push(l)
            }
            ),
            r
        }
        getAfterBody(t, e) {
            return Pg(e.callbacks.afterBody.apply(this, [t]))
        }
        getFooter(t, e) {
            let {callbacks: s} = e
              , r = s.beforeFooter.apply(this, [t])
              , a = s.footer.apply(this, [t])
              , l = s.afterFooter.apply(this, [t])
              , u = [];
            return u = Yi(u, bn(r)),
            u = Yi(u, bn(a)),
            u = Yi(u, bn(l)),
            u
        }
        _createItems(t) {
            let e = this._active, s = this.chart.data, r = [], a = [], l = [], u = [], d, p;
            for (d = 0,
            p = e.length; d < p; ++d)
                u.push(GS(this.chart, e[d]));
            return t.filter && (u = u.filter( (b, E, x) => t.filter(b, E, x, s))),
            t.itemSort && (u = u.sort( (b, E) => t.itemSort(b, E, s))),
            Jt(u, b => {
                let E = Rg(t.callbacks, b);
                r.push(E.labelColor.call(this, b)),
                a.push(E.labelPointStyle.call(this, b)),
                l.push(E.labelTextColor.call(this, b))
            }
            ),
            this.labelColors = r,
            this.labelPointStyles = a,
            this.labelTextColors = l,
            this.dataPoints = u,
            u
        }
        update(t, e) {
            let s = this.options.setContext(this.getContext()), r = this._active, a, l = [];
            if (!r.length)
                this.opacity !== 0 && (a = {
                    opacity: 0
                });
            else {
                let u = Co[s.position].call(this, r, this._eventPosition);
                l = this._createItems(s),
                this.title = this.getTitle(l, s),
                this.beforeBody = this.getBeforeBody(l, s),
                this.body = this.getBody(l, s),
                this.afterBody = this.getAfterBody(l, s),
                this.footer = this.getFooter(l, s);
                let d = this._size = Og(this, s)
                  , p = Object.assign({}, u, d)
                  , b = Lg(this.chart, s, p)
                  , E = Dg(s, p, b, this.chart);
                this.xAlign = b.xAlign,
                this.yAlign = b.yAlign,
                a = {
                    opacity: 1,
                    x: E.x,
                    y: E.y,
                    width: d.width,
                    height: d.height,
                    caretX: u.x,
                    caretY: u.y
                }
            }
            this._tooltipItems = l,
            this.$context = void 0,
            a && this._resolveAnimations().update(this, a),
            t && s.external && s.external.call(this, {
                chart: this.chart,
                tooltip: this,
                replay: e
            })
        }
        drawCaret(t, e, s, r) {
            let a = this.getCaretPosition(t, s, r);
            e.lineTo(a.x1, a.y1),
            e.lineTo(a.x2, a.y2),
            e.lineTo(a.x3, a.y3)
        }
        getCaretPosition(t, e, s) {
            let {xAlign: r, yAlign: a} = this, {caretSize: l, cornerRadius: u} = s, {topLeft: d, topRight: p, bottomLeft: b, bottomRight: E} = jn(u), {x, y: w} = t, {width: C, height: I} = e, L, k, F, z, j, H;
            return a === "center" ? (j = w + I / 2,
            r === "left" ? (L = x,
            k = L - l,
            z = j + l,
            H = j - l) : (L = x + C,
            k = L + l,
            z = j - l,
            H = j + l),
            F = L) : (r === "left" ? k = x + Math.max(d, b) + l : r === "right" ? k = x + C - Math.max(p, E) - l : k = this.caretX,
            a === "top" ? (z = w,
            j = z - l,
            L = k - l,
            F = k + l) : (z = w + I,
            j = z + l,
            L = k + l,
            F = k - l),
            H = z),
            {
                x1: L,
                x2: k,
                x3: F,
                y1: z,
                y2: j,
                y3: H
            }
        }
        drawTitle(t, e, s) {
            let r = this.title, a = r.length, l, u, d;
            if (a) {
                let p = vs(s.rtl, this.x, this.width);
                for (t.x = el(this, s.titleAlign, s),
                e.textAlign = p.textAlign(s.titleAlign),
                e.textBaseline = "middle",
                l = ge(s.titleFont),
                u = s.titleSpacing,
                e.fillStyle = s.titleColor,
                e.font = l.string,
                d = 0; d < a; ++d)
                    e.fillText(r[d], p.x(t.x), t.y + l.lineHeight / 2),
                    t.y += l.lineHeight + u,
                    d + 1 === a && (t.y += s.titleMarginBottom - u)
            }
        }
        _drawColorBox(t, e, s, r, a) {
            let l = this.labelColors[s]
              , u = this.labelPointStyles[s]
              , {boxHeight: d, boxWidth: p, boxPadding: b} = a
              , E = ge(a.bodyFont)
              , x = el(this, "left", a)
              , w = r.x(x)
              , C = d < E.lineHeight ? (E.lineHeight - d) / 2 : 0
              , I = e.y + C;
            if (a.usePointStyle) {
                let L = {
                    radius: Math.min(p, d) / 2,
                    pointStyle: u.pointStyle,
                    rotation: u.rotation,
                    borderWidth: 1
                }
                  , k = r.leftForLtr(w, p) + p / 2
                  , F = I + d / 2;
                t.strokeStyle = a.multiKeyBackground,
                t.fillStyle = a.multiKeyBackground,
                Ua(t, L, k, F),
                t.strokeStyle = l.borderColor,
                t.fillStyle = l.backgroundColor,
                Ua(t, L, k, F)
            } else {
                t.lineWidth = Ht(l.borderWidth) ? Math.max(...Object.values(l.borderWidth)) : l.borderWidth || 1,
                t.strokeStyle = l.borderColor,
                t.setLineDash(l.borderDash || []),
                t.lineDashOffset = l.borderDashOffset || 0;
                let L = r.leftForLtr(w, p - b)
                  , k = r.leftForLtr(r.xPlus(w, 1), p - b - 2)
                  , F = jn(l.borderRadius);
                Object.values(F).some(z => z !== 0) ? (t.beginPath(),
                t.fillStyle = a.multiKeyBackground,
                ar(t, {
                    x: L,
                    y: I,
                    w: p,
                    h: d,
                    radius: F
                }),
                t.fill(),
                t.stroke(),
                t.fillStyle = l.backgroundColor,
                t.beginPath(),
                ar(t, {
                    x: k,
                    y: I + 1,
                    w: p - 2,
                    h: d - 2,
                    radius: F
                }),
                t.fill()) : (t.fillStyle = a.multiKeyBackground,
                t.fillRect(L, I, p, d),
                t.strokeRect(L, I, p, d),
                t.fillStyle = l.backgroundColor,
                t.fillRect(k, I + 1, p - 2, d - 2))
            }
            t.fillStyle = this.labelTextColors[s]
        }
        drawBody(t, e, s) {
            let {body: r} = this, {bodySpacing: a, bodyAlign: l, displayColors: u, boxHeight: d, boxWidth: p, boxPadding: b} = s, E = ge(s.bodyFont), x = E.lineHeight, w = 0, C = vs(s.rtl, this.x, this.width), I = o(function(Q) {
                e.fillText(Q, C.x(t.x + w), t.y + x / 2),
                t.y += x + a
            }, "fillLineOfText"), L = C.textAlign(l), k, F, z, j, H, f, Y;
            for (e.textAlign = l,
            e.textBaseline = "middle",
            e.font = E.string,
            t.x = el(this, L, s),
            e.fillStyle = s.bodyColor,
            Jt(this.beforeBody, I),
            w = u && L !== "right" ? l === "center" ? p / 2 + b : p + 2 + b : 0,
            j = 0,
            f = r.length; j < f; ++j) {
                for (k = r[j],
                F = this.labelTextColors[j],
                e.fillStyle = F,
                Jt(k.before, I),
                z = k.lines,
                u && z.length && (this._drawColorBox(e, t, j, C, s),
                x = Math.max(E.lineHeight, d)),
                H = 0,
                Y = z.length; H < Y; ++H)
                    I(z[H]),
                    x = E.lineHeight;
                Jt(k.after, I)
            }
            w = 0,
            x = E.lineHeight,
            Jt(this.afterBody, I),
            t.y -= a
        }
        drawFooter(t, e, s) {
            let r = this.footer, a = r.length, l, u;
            if (a) {
                let d = vs(s.rtl, this.x, this.width);
                for (t.x = el(this, s.footerAlign, s),
                t.y += s.footerMarginTop,
                e.textAlign = d.textAlign(s.footerAlign),
                e.textBaseline = "middle",
                l = ge(s.footerFont),
                e.fillStyle = s.footerColor,
                e.font = l.string,
                u = 0; u < a; ++u)
                    e.fillText(r[u], d.x(t.x), t.y + l.lineHeight / 2),
                    t.y += l.lineHeight + s.footerSpacing
            }
        }
        drawBackground(t, e, s, r) {
            let {xAlign: a, yAlign: l} = this
              , {x: u, y: d} = t
              , {width: p, height: b} = s
              , {topLeft: E, topRight: x, bottomLeft: w, bottomRight: C} = jn(r.cornerRadius);
            e.fillStyle = r.backgroundColor,
            e.strokeStyle = r.borderColor,
            e.lineWidth = r.borderWidth,
            e.beginPath(),
            e.moveTo(u + E, d),
            l === "top" && this.drawCaret(t, e, s, r),
            e.lineTo(u + p - x, d),
            e.quadraticCurveTo(u + p, d, u + p, d + x),
            l === "center" && a === "right" && this.drawCaret(t, e, s, r),
            e.lineTo(u + p, d + b - C),
            e.quadraticCurveTo(u + p, d + b, u + p - C, d + b),
            l === "bottom" && this.drawCaret(t, e, s, r),
            e.lineTo(u + w, d + b),
            e.quadraticCurveTo(u, d + b, u, d + b - w),
            l === "center" && a === "left" && this.drawCaret(t, e, s, r),
            e.lineTo(u, d + E),
            e.quadraticCurveTo(u, d, u + E, d),
            e.closePath(),
            e.fill(),
            r.borderWidth > 0 && e.stroke()
        }
        _updateAnimationTarget(t) {
            let e = this.chart
              , s = this.$animations
              , r = s && s.x
              , a = s && s.y;
            if (r || a) {
                let l = Co[t.position].call(this, this._active, this._eventPosition);
                if (!l)
                    return;
                let u = this._size = Og(this, t)
                  , d = Object.assign({}, l, this._size)
                  , p = Lg(e, t, d)
                  , b = Dg(t, d, p, e);
                (r._to !== b.x || a._to !== b.y) && (this.xAlign = p.xAlign,
                this.yAlign = p.yAlign,
                this.width = u.width,
                this.height = u.height,
                this.caretX = l.x,
                this.caretY = l.y,
                this._resolveAnimations().update(this, b))
            }
        }
        _willRender() {
            return !!this.opacity
        }
        draw(t) {
            let e = this.options.setContext(this.getContext())
              , s = this.opacity;
            if (!s)
                return;
            this._updateAnimationTarget(e);
            let r = {
                width: this.width,
                height: this.height
            }
              , a = {
                x: this.x,
                y: this.y
            };
            s = Math.abs(s) < .001 ? 0 : s;
            let l = Me(e.padding)
              , u = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
            e.enabled && u && (t.save(),
            t.globalAlpha = s,
            this.drawBackground(a, t, r, e),
            Gh(t, e.textDirection),
            a.y += l.top,
            this.drawTitle(a, t, e),
            this.drawBody(a, t, e),
            this.drawFooter(a, t, e),
            Qh(t, e.textDirection),
            t.restore())
        }
        getActiveElements() {
            return this._active || []
        }
        setActiveElements(t, e) {
            let s = this._active
              , r = t.map( ({datasetIndex: u, index: d}) => {
                let p = this.chart.getDatasetMeta(u);
                if (!p)
                    throw new Error("Cannot find a dataset at index " + u);
                return {
                    datasetIndex: u,
                    element: p.data[d],
                    index: d
                }
            }
            )
              , a = !mo(s, r)
              , l = this._positionChanged(r, e);
            (a || l) && (this._active = r,
            this._eventPosition = e,
            this._ignoreReplayEvents = !0,
            this.update(!0))
        }
        handleEvent(t, e, s=!0) {
            if (e && this._ignoreReplayEvents)
                return !1;
            this._ignoreReplayEvents = !1;
            let r = this.options
              , a = this._active || []
              , l = this._getActiveElements(t, a, e, s)
              , u = this._positionChanged(l, t)
              , d = e || !mo(l, a) || u;
            return d && (this._active = l,
            (r.enabled || r.external) && (this._eventPosition = {
                x: t.x,
                y: t.y
            },
            this.update(!0, e))),
            d
        }
        _getActiveElements(t, e, s, r) {
            let a = this.options;
            if (t.type === "mouseout")
                return [];
            if (!r)
                return e;
            let l = this.chart.getElementsAtEventForMode(t, a.mode, a, s);
            return a.reverse && l.reverse(),
            l
        }
        _positionChanged(t, e) {
            let {caretX: s, caretY: r, options: a} = this
              , l = Co[a.position].call(this, t, e);
            return l !== !1 && (s !== l.x || r !== l.y)
        }
    }
    ;
    Lo.positioners = Co;
    var nT = {
        id: "tooltip",
        _element: Lo,
        positioners: Co,
        afterInit(n, t, e) {
            e && (n.tooltip = new Lo({
                chart: n,
                options: e
            }))
        },
        beforeUpdate(n, t, e) {
            n.tooltip && n.tooltip.initialize(e)
        },
        reset(n, t, e) {
            n.tooltip && n.tooltip.initialize(e)
        },
        afterDraw(n) {
            let t = n.tooltip;
            if (t && t._willRender()) {
                let e = {
                    tooltip: t
                };
                if (n.notifyPlugins("beforeTooltipDraw", e) === !1)
                    return;
                t.draw(n.ctx),
                n.notifyPlugins("afterTooltipDraw", e)
            }
        },
        afterEvent(n, t) {
            if (n.tooltip) {
                let e = t.replay;
                n.tooltip.handleEvent(t.event, e, t.inChartArea) && (t.changed = !0)
            }
        },
        defaults: {
            enabled: !0,
            external: null,
            position: "average",
            backgroundColor: "rgba(0,0,0,0.8)",
            titleColor: "#fff",
            titleFont: {
                weight: "bold"
            },
            titleSpacing: 2,
            titleMarginBottom: 6,
            titleAlign: "left",
            bodyColor: "#fff",
            bodySpacing: 2,
            bodyFont: {},
            bodyAlign: "left",
            footerColor: "#fff",
            footerSpacing: 2,
            footerMarginTop: 6,
            footerFont: {
                weight: "bold"
            },
            footerAlign: "left",
            padding: 6,
            caretPadding: 2,
            caretSize: 5,
            cornerRadius: 6,
            boxHeight: o( (n, t) => t.bodyFont.size, "boxHeight"),
            boxWidth: o( (n, t) => t.bodyFont.size, "boxWidth"),
            multiKeyBackground: "#fff",
            displayColors: !0,
            boxPadding: 0,
            borderColor: "rgba(0,0,0,0)",
            borderWidth: 0,
            animation: {
                duration: 400,
                easing: "easeOutQuart"
            },
            animations: {
                numbers: {
                    type: "number",
                    properties: ["x", "y", "width", "height", "caretX", "caretY"]
                },
                opacity: {
                    easing: "linear",
                    duration: 200
                }
            },
            callbacks: {
                beforeTitle: Ui,
                title(n) {
                    if (n.length > 0) {
                        let t = n[0]
                          , e = t.chart.data.labels
                          , s = e ? e.length : 0;
                        if (this && this.options && this.options.mode === "dataset")
                            return t.dataset.label || "";
                        if (t.label)
                            return t.label;
                        if (s > 0 && t.dataIndex < s)
                            return e[t.dataIndex]
                    }
                    return ""
                },
                afterTitle: Ui,
                beforeBody: Ui,
                beforeLabel: Ui,
                label(n) {
                    if (this && this.options && this.options.mode === "dataset")
                        return n.label + ": " + n.formattedValue || n.formattedValue;
                    let t = n.dataset.label || "";
                    t && (t += ": ");
                    let e = n.formattedValue;
                    return zt(e) || (t += e),
                    t
                },
                labelColor(n) {
                    let e = n.chart.getDatasetMeta(n.datasetIndex).controller.getStyle(n.dataIndex);
                    return {
                        borderColor: e.borderColor,
                        backgroundColor: e.backgroundColor,
                        borderWidth: e.borderWidth,
                        borderDash: e.borderDash,
                        borderDashOffset: e.borderDashOffset,
                        borderRadius: 0
                    }
                },
                labelTextColor() {
                    return this.options.bodyColor
                },
                labelPointStyle(n) {
                    let e = n.chart.getDatasetMeta(n.datasetIndex).controller.getStyle(n.dataIndex);
                    return {
                        pointStyle: e.pointStyle,
                        rotation: e.rotation
                    }
                },
                afterLabel: Ui,
                afterBody: Ui,
                beforeFooter: Ui,
                footer: Ui,
                afterFooter: Ui
            }
        },
        defaultRoutes: {
            bodyFont: "font",
            footerFont: "font",
            titleFont: "font"
        },
        descriptors: {
            _scriptable: o(n => n !== "filter" && n !== "itemSort" && n !== "external", "_scriptable"),
            _indexable: !1,
            callbacks: {
                _scriptable: !1,
                _indexable: !1
            },
            animation: {
                _fallback: !1
            },
            animations: {
                _fallback: "animation"
            }
        },
        additionalOptionScopes: ["interaction"]
    }
      , sT = Object.freeze({
        __proto__: null,
        Decimation: TS,
        Filler: $S,
        Legend: US,
        SubTitle: XS,
        Title: YS,
        Tooltip: nT
    })
      , rT = o( (n, t, e, s) => (typeof t == "string" ? (e = n.push(t) - 1,
    s.unshift({
        index: e,
        label: t
    })) : isNaN(t) && (e = null),
    e), "addIfString");
    function oT(n, t, e, s) {
        let r = n.indexOf(t);
        if (r === -1)
            return rT(n, t, e, s);
        let a = n.lastIndexOf(t);
        return r !== a ? e : r
    }
    o(oT, "findOrAddLabel");
    var aT = o( (n, t) => n === null ? null : be(Math.round(n), 0, t), "validIndex")
      , Er = class extends ys {
        static{o(this, "CategoryScale")
        }constructor(t) {
            super(t),
            this._startValue = void 0,
            this._valueRange = 0,
            this._addedLabels = []
        }
        init(t) {
            let e = this._addedLabels;
            if (e.length) {
                let s = this.getLabels();
                for (let {index: r, label: a} of e)
                    s[r] === a && s.splice(r, 1);
                this._addedLabels = []
            }
            super.init(t)
        }
        parse(t, e) {
            if (zt(t))
                return null;
            let s = this.getLabels();
            return e = isFinite(e) && s[e] === t ? e : oT(s, t, It(e, t), this._addedLabels),
            aT(e, s.length - 1)
        }
        determineDataLimits() {
            let {minDefined: t, maxDefined: e} = this.getUserBounds()
              , {min: s, max: r} = this.getMinMax(!0);
            this.options.bounds === "ticks" && (t || (s = 0),
            e || (r = this.getLabels().length - 1)),
            this.min = s,
            this.max = r
        }
        buildTicks() {
            let t = this.min
              , e = this.max
              , s = this.options.offset
              , r = []
              , a = this.getLabels();
            a = t === 0 && e === a.length - 1 ? a : a.slice(t, e + 1),
            this._valueRange = Math.max(a.length - (s ? 0 : 1), 1),
            this._startValue = this.min - (s ? .5 : 0);
            for (let l = t; l <= e; l++)
                r.push({
                    value: l
                });
            return r
        }
        getLabelForValue(t) {
            let e = this.getLabels();
            return t >= 0 && t < e.length ? e[t] : t
        }
        configure() {
            super.configure(),
            this.isHorizontal() || (this._reversePixels = !this._reversePixels)
        }
        getPixelForValue(t) {
            return typeof t != "number" && (t = this.parse(t)),
            t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange)
        }
        getPixelForTick(t) {
            let e = this.ticks;
            return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value)
        }
        getValueForPixel(t) {
            return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange)
        }
        getBasePixel() {
            return this.bottom
        }
    }
    ;
    Er.id = "category";
    Er.defaults = {
        ticks: {
            callback: Er.prototype.getLabelForValue
        }
    };
    function lT(n, t) {
        let e = [], {bounds: r, step: a, min: l, max: u, precision: d, count: p, maxTicks: b, maxDigits: E, includeBounds: x} = n, w = a || 1, C = b - 1, {min: I, max: L} = t, k = !zt(l), F = !zt(u), z = !zt(p), j = (L - I) / (E + 1), H = Ch((L - I) / C / w) * w, f, Y, Q, ot;
        if (H < 1e-14 && !k && !F)
            return [{
                value: I
            }, {
                value: L
            }];
        ot = Math.ceil(L / H) - Math.floor(I / H),
        ot > C && (H = Ch(ot * H / C / w) * w),
        zt(d) || (f = Math.pow(10, d),
        H = Math.ceil(H * f) / f),
        r === "ticks" ? (Y = Math.floor(I / H) * H,
        Q = Math.ceil(L / H) * H) : (Y = I,
        Q = L),
        k && F && a && Tp((u - l) / a, H / 1e3) ? (ot = Math.round(Math.min((u - l) / H, b)),
        H = (u - l) / ot,
        Y = l,
        Q = u) : z ? (Y = k ? l : Y,
        Q = F ? u : Q,
        ot = p - 1,
        H = (Q - Y) / ot) : (ot = (Q - Y) / H,
        rr(ot, Math.round(ot), H / 1e3) ? ot = Math.round(ot) : ot = Math.ceil(ot));
        let mt = Math.max(kh(H), kh(Y));
        f = Math.pow(10, zt(d) ? mt : d),
        Y = Math.round(Y * f) / f,
        Q = Math.round(Q * f) / f;
        let bt = 0;
        for (k && (x && Y !== l ? (e.push({
            value: l
        }),
        Y < l && bt++,
        rr(Math.round((Y + bt * H) * f) / f, l, Ig(l, j, n)) && bt++) : Y < l && bt++); bt < ot; ++bt)
            e.push({
                value: Math.round((Y + bt * H) * f) / f
            });
        return F && x && Q !== u ? e.length && rr(e[e.length - 1].value, u, Ig(u, j, n)) ? e[e.length - 1].value = u : e.push({
            value: u
        }) : (!F || Q === u) && e.push({
            value: Q
        }),
        e
    }
    o(lT, "generateTicks$1");
    function Ig(n, t, {horizontal: e, minRotation: s}) {
        let r = _i(s)
          , a = (e ? Math.sin(r) : Math.cos(r)) || .001
          , l = .75 * t * ("" + n).length;
        return Math.min(t / a, l)
    }
    o(Ig, "relativeLabelSize");
    var Sr = class extends ys {
        static{o(this, "LinearScaleBase")
        }constructor(t) {
            super(t),
            this.start = void 0,
            this.end = void 0,
            this._startValue = void 0,
            this._endValue = void 0,
            this._valueRange = 0
        }
        parse(t, e) {
            return zt(t) || (typeof t == "number" || t instanceof Number) && !isFinite(+t) ? null : +t
        }
        handleTickRangeOptions() {
            let {beginAtZero: t} = this.options
              , {minDefined: e, maxDefined: s} = this.getUserBounds()
              , {min: r, max: a} = this
              , l = o(d => r = e ? r : d, "setMin")
              , u = o(d => a = s ? a : d, "setMax");
            if (t) {
                let d = Oi(r)
                  , p = Oi(a);
                d < 0 && p < 0 ? u(0) : d > 0 && p > 0 && l(0)
            }
            if (r === a) {
                let d = 1;
                (a >= Number.MAX_SAFE_INTEGER || r <= Number.MIN_SAFE_INTEGER) && (d = Math.abs(a * .05)),
                u(a + d),
                t || l(r - d)
            }
            this.min = r,
            this.max = a
        }
        getTickLimit() {
            let t = this.options.ticks, {maxTicksLimit: e, stepSize: s} = t, r;
            return s ? (r = Math.ceil(this.max / s) - Math.floor(this.min / s) + 1,
            r > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${s} would result generating up to ${r} ticks. Limiting to 1000.`),
            r = 1e3)) : (r = this.computeTickLimit(),
            e = e || 11),
            e && (r = Math.min(e, r)),
            r
        }
        computeTickLimit() {
            return Number.POSITIVE_INFINITY
        }
        buildTicks() {
            let t = this.options
              , e = t.ticks
              , s = this.getTickLimit();
            s = Math.max(2, s);
            let r = {
                maxTicks: s,
                bounds: t.bounds,
                min: t.min,
                max: t.max,
                precision: e.precision,
                step: e.stepSize,
                count: e.count,
                maxDigits: this._maxDigits(),
                horizontal: this.isHorizontal(),
                minRotation: e.minRotation || 0,
                includeBounds: e.includeBounds !== !1
            }
              , a = this._range || this
              , l = lT(r, a);
            return t.bounds === "ticks" && Ah(l, this, "value"),
            t.reverse ? (l.reverse(),
            this.start = this.max,
            this.end = this.min) : (this.start = this.min,
            this.end = this.max),
            l
        }
        configure() {
            let t = this.ticks
              , e = this.min
              , s = this.max;
            if (super.configure(),
            this.options.offset && t.length) {
                let r = (s - e) / Math.max(t.length - 1, 1) / 2;
                e -= r,
                s += r
            }
            this._startValue = e,
            this._endValue = s,
            this._valueRange = s - e
        }
        getLabelForValue(t) {
            return cr(t, this.chart.options.locale, this.options.ticks.format)
        }
    }
      , Do = class extends Sr {
        static{o(this, "LinearScale")
        }determineDataLimits() {
            let {min: t, max: e} = this.getMinMax(!0);
            this.min = fe(t) ? t : 0,
            this.max = fe(e) ? e : 1,
            this.handleTickRangeOptions()
        }
        computeTickLimit() {
            let t = this.isHorizontal()
              , e = t ? this.width : this.height
              , s = _i(this.options.ticks.minRotation)
              , r = (t ? Math.sin(s) : Math.cos(s)) || .001
              , a = this._resolveTickFontOptions(0);
            return Math.ceil(e / Math.min(40, a.lineHeight / r))
        }
        getPixelForValue(t) {
            return t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange)
        }
        getValueForPixel(t) {
            return this._startValue + this.getDecimalForPixel(t) * this._valueRange
        }
    }
    ;
    Do.id = "linear";
    Do.defaults = {
        ticks: {
            callback: ul.formatters.numeric
        }
    };
    function Ng(n) {
        return n / Math.pow(10, Math.floor(oi(n))) === 1
    }
    o(Ng, "isMajor");
    function cT(n, t) {
        let e = Math.floor(oi(t.max))
          , s = Math.ceil(t.max / Math.pow(10, e))
          , r = []
          , a = ri(n.min, Math.pow(10, Math.floor(oi(t.min))))
          , l = Math.floor(oi(a))
          , u = Math.floor(a / Math.pow(10, l))
          , d = l < 0 ? Math.pow(10, Math.abs(l)) : 1;
        do
            r.push({
                value: a,
                major: Ng(a)
            }),
            ++u,
            u === 10 && (u = 1,
            ++l,
            d = l >= 0 ? 1 : d),
            a = Math.round(u * Math.pow(10, l) * d) / d;
        while (l < e || l === e && u < s);
        let p = ri(n.max, a);
        return r.push({
            value: p,
            major: Ng(a)
        }),
        r
    }
    o(cT, "generateTicks");
    var Po = class extends ys {
        static{o(this, "LogarithmicScale")
        }constructor(t) {
            super(t),
            this.start = void 0,
            this.end = void 0,
            this._startValue = void 0,
            this._valueRange = 0
        }
        parse(t, e) {
            let s = Sr.prototype.parse.apply(this, [t, e]);
            if (s === 0) {
                this._zero = !0;
                return
            }
            return fe(s) && s > 0 ? s : null
        }
        determineDataLimits() {
            let {min: t, max: e} = this.getMinMax(!0);
            this.min = fe(t) ? Math.max(0, t) : null,
            this.max = fe(e) ? Math.max(0, e) : null,
            this.options.beginAtZero && (this._zero = !0),
            this.handleTickRangeOptions()
        }
        handleTickRangeOptions() {
            let {minDefined: t, maxDefined: e} = this.getUserBounds()
              , s = this.min
              , r = this.max
              , a = o(d => s = t ? s : d, "setMin")
              , l = o(d => r = e ? r : d, "setMax")
              , u = o( (d, p) => Math.pow(10, Math.floor(oi(d)) + p), "exp");
            s === r && (s <= 0 ? (a(1),
            l(10)) : (a(u(s, -1)),
            l(u(r, 1)))),
            s <= 0 && a(u(r, -1)),
            r <= 0 && l(u(s, 1)),
            this._zero && this.min !== this._suggestedMin && s === u(this.min, 0) && a(u(s, -1)),
            this.min = s,
            this.max = r
        }
        buildTicks() {
            let t = this.options
              , e = {
                min: this._userMin,
                max: this._userMax
            }
              , s = cT(e, this);
            return t.bounds === "ticks" && Ah(s, this, "value"),
            t.reverse ? (s.reverse(),
            this.start = this.max,
            this.end = this.min) : (this.start = this.min,
            this.end = this.max),
            s
        }
        getLabelForValue(t) {
            return t === void 0 ? "0" : cr(t, this.chart.options.locale, this.options.ticks.format)
        }
        configure() {
            let t = this.min;
            super.configure(),
            this._startValue = oi(t),
            this._valueRange = oi(this.max) - oi(t)
        }
        getPixelForValue(t) {
            return (t === void 0 || t === 0) && (t = this.min),
            t === null || isNaN(t) ? NaN : this.getPixelForDecimal(t === this.min ? 0 : (oi(t) - this._startValue) / this._valueRange)
        }
        getValueForPixel(t) {
            let e = this.getDecimalForPixel(t);
            return Math.pow(10, this._startValue + e * this._valueRange)
        }
    }
    ;
    Po.id = "logarithmic";
    Po.defaults = {
        ticks: {
            callback: ul.formatters.logarithmic,
            major: {
                enabled: !0
            }
        }
    };
    function Ed(n) {
        let t = n.ticks;
        if (t.display && n.display) {
            let e = Me(t.backdropPadding);
            return It(t.font && t.font.size, jt.font.size) + e.height
        }
        return 0
    }
    o(Ed, "getTickBackdropHeight");
    function uT(n, t, e) {
        return e = ee(e) ? e : [e],
        {
            w: Np(n, t.string, e),
            h: e.length * t.lineHeight
        }
    }
    o(uT, "measureLabelSize");
    function Fg(n, t, e, s, r) {
        return n === s || n === r ? {
            start: t - e / 2,
            end: t + e / 2
        } : n < s || n > r ? {
            start: t - e,
            end: t
        } : {
            start: t,
            end: t + e
        }
    }
    o(Fg, "determineLimits");
    function hT(n) {
        let t = {
            l: n.left + n._padding.left,
            r: n.right - n._padding.right,
            t: n.top + n._padding.top,
            b: n.bottom - n._padding.bottom
        }
          , e = Object.assign({}, t)
          , s = []
          , r = []
          , a = n._pointLabels.length
          , l = n.options.pointLabels
          , u = l.centerPointLabels ? ae / a : 0;
        for (let d = 0; d < a; d++) {
            let p = l.setContext(n.getPointLabelContext(d));
            r[d] = p.padding;
            let b = n.getPointPosition(d, n.drawingArea + r[d], u)
              , E = ge(p.font)
              , x = uT(n.ctx, E, n._pointLabels[d]);
            s[d] = x;
            let w = ze(n.getIndexAngle(d) + u)
              , C = Math.round(Wa(w))
              , I = Fg(C, b.x, x.w, 0, 180)
              , L = Fg(C, b.y, x.h, 90, 270);
            dT(e, t, w, I, L)
        }
        n.setCenterPoint(t.l - e.l, e.r - t.r, t.t - e.t, e.b - t.b),
        n._pointLabelItems = fT(n, s, r)
    }
    o(hT, "fitWithPointLabels");
    function dT(n, t, e, s, r) {
        let a = Math.abs(Math.sin(e))
          , l = Math.abs(Math.cos(e))
          , u = 0
          , d = 0;
        s.start < t.l ? (u = (t.l - s.start) / a,
        n.l = Math.min(n.l, t.l - u)) : s.end > t.r && (u = (s.end - t.r) / a,
        n.r = Math.max(n.r, t.r + u)),
        r.start < t.t ? (d = (t.t - r.start) / l,
        n.t = Math.min(n.t, t.t - d)) : r.end > t.b && (d = (r.end - t.b) / l,
        n.b = Math.max(n.b, t.b + d))
    }
    o(dT, "updateLimits");
    function fT(n, t, e) {
        let s = []
          , r = n._pointLabels.length
          , a = n.options
          , l = Ed(a) / 2
          , u = n.drawingArea
          , d = a.pointLabels.centerPointLabels ? ae / r : 0;
        for (let p = 0; p < r; p++) {
            let b = n.getPointPosition(p, u + l + e[p], d)
              , E = Math.round(Wa(ze(b.angle + he)))
              , x = t[p]
              , w = mT(b.y, x.h, E)
              , C = pT(E)
              , I = gT(b.x, x.w, C);
            s.push({
                x: b.x,
                y: w,
                textAlign: C,
                left: I,
                top: w,
                right: I + x.w,
                bottom: w + x.h
            })
        }
        return s
    }
    o(fT, "buildPointLabelItems");
    function pT(n) {
        return n === 0 || n === 180 ? "center" : n < 180 ? "left" : "right"
    }
    o(pT, "getTextAlignForAngle");
    function gT(n, t, e) {
        return e === "right" ? n -= t : e === "center" && (n -= t / 2),
        n
    }
    o(gT, "leftForTextAlign");
    function mT(n, t, e) {
        return e === 90 || e === 270 ? n -= t / 2 : (e > 270 || e < 90) && (n -= t),
        n
    }
    o(mT, "yForAngle");
    function vT(n, t) {
        let {ctx: e, options: {pointLabels: s}} = n;
        for (let r = t - 1; r >= 0; r--) {
            let a = s.setContext(n.getPointLabelContext(r))
              , l = ge(a.font)
              , {x: u, y: d, textAlign: p, left: b, top: E, right: x, bottom: w} = n._pointLabelItems[r]
              , {backdropColor: C} = a;
            if (!zt(C)) {
                let I = jn(a.borderRadius)
                  , L = Me(a.backdropPadding);
                e.fillStyle = C;
                let k = b - L.left
                  , F = E - L.top
                  , z = x - b + L.width
                  , j = w - E + L.height;
                Object.values(I).some(H => H !== 0) ? (e.beginPath(),
                ar(e, {
                    x: k,
                    y: F,
                    w: z,
                    h: j,
                    radius: I
                }),
                e.fill()) : e.fillRect(k, F, z, j)
            }
            Hn(e, n._pointLabels[r], u, d + l.lineHeight / 2, l, {
                color: a.color,
                textAlign: p,
                textBaseline: "middle"
            })
        }
    }
    o(vT, "drawPointLabels");
    function om(n, t, e, s) {
        let {ctx: r} = n;
        if (e)
            r.arc(n.xCenter, n.yCenter, t, 0, te);
        else {
            let a = n.getPointPosition(0, t);
            r.moveTo(a.x, a.y);
            for (let l = 1; l < s; l++)
                a = n.getPointPosition(l, t),
                r.lineTo(a.x, a.y)
        }
    }
    o(om, "pathRadiusLine");
    function bT(n, t, e, s) {
        let r = n.ctx
          , a = t.circular
          , {color: l, lineWidth: u} = t;
        !a && !s || !l || !u || e < 0 || (r.save(),
        r.strokeStyle = l,
        r.lineWidth = u,
        r.setLineDash(t.borderDash),
        r.lineDashOffset = t.borderDashOffset,
        r.beginPath(),
        om(n, e, a, s),
        r.closePath(),
        r.stroke(),
        r.restore())
    }
    o(bT, "drawRadiusLine");
    function yT(n, t, e) {
        return mn(n, {
            label: e,
            index: t,
            type: "pointLabel"
        })
    }
    o(yT, "createPointLabelContext");
    var Es = class extends Sr {
        static{o(this, "RadialLinearScale")
        }constructor(t) {
            super(t),
            this.xCenter = void 0,
            this.yCenter = void 0,
            this.drawingArea = void 0,
            this._pointLabels = [],
            this._pointLabelItems = []
        }
        setDimensions() {
            let t = this._padding = Me(Ed(this.options) / 2)
              , e = this.width = this.maxWidth - t.width
              , s = this.height = this.maxHeight - t.height;
            this.xCenter = Math.floor(this.left + e / 2 + t.left),
            this.yCenter = Math.floor(this.top + s / 2 + t.top),
            this.drawingArea = Math.floor(Math.min(e, s) / 2)
        }
        determineDataLimits() {
            let {min: t, max: e} = this.getMinMax(!1);
            this.min = fe(t) && !isNaN(t) ? t : 0,
            this.max = fe(e) && !isNaN(e) ? e : 0,
            this.handleTickRangeOptions()
        }
        computeTickLimit() {
            return Math.ceil(this.drawingArea / Ed(this.options))
        }
        generateTickLabels(t) {
            Sr.prototype.generateTickLabels.call(this, t),
            this._pointLabels = this.getLabels().map( (e, s) => {
                let r = ie(this.options.pointLabels.callback, [e, s], this);
                return r || r === 0 ? r : ""
            }
            ).filter( (e, s) => this.chart.getDataVisibility(s))
        }
        fit() {
            let t = this.options;
            t.display && t.pointLabels.display ? hT(this) : this.setCenterPoint(0, 0, 0, 0)
        }
        setCenterPoint(t, e, s, r) {
            this.xCenter += Math.floor((t - e) / 2),
            this.yCenter += Math.floor((s - r) / 2),
            this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(t, e, s, r))
        }
        getIndexAngle(t) {
            let e = te / (this._pointLabels.length || 1)
              , s = this.options.startAngle || 0;
            return ze(t * e + _i(s))
        }
        getDistanceFromCenterForValue(t) {
            if (zt(t))
                return NaN;
            let e = this.drawingArea / (this.max - this.min);
            return this.options.reverse ? (this.max - t) * e : (t - this.min) * e
        }
        getValueForDistanceFromCenter(t) {
            if (zt(t))
                return NaN;
            let e = t / (this.drawingArea / (this.max - this.min));
            return this.options.reverse ? this.max - e : this.min + e
        }
        getPointLabelContext(t) {
            let e = this._pointLabels || [];
            if (t >= 0 && t < e.length) {
                let s = e[t];
                return yT(this.getContext(), t, s)
            }
        }
        getPointPosition(t, e, s=0) {
            let r = this.getIndexAngle(t) - he + s;
            return {
                x: Math.cos(r) * e + this.xCenter,
                y: Math.sin(r) * e + this.yCenter,
                angle: r
            }
        }
        getPointPositionForValue(t, e) {
            return this.getPointPosition(t, this.getDistanceFromCenterForValue(e))
        }
        getBasePosition(t) {
            return this.getPointPositionForValue(t || 0, this.getBaseValue())
        }
        getPointLabelPosition(t) {
            let {left: e, top: s, right: r, bottom: a} = this._pointLabelItems[t];
            return {
                left: e,
                top: s,
                right: r,
                bottom: a
            }
        }
        drawBackground() {
            let {backgroundColor: t, grid: {circular: e}} = this.options;
            if (t) {
                let s = this.ctx;
                s.save(),
                s.beginPath(),
                om(this, this.getDistanceFromCenterForValue(this._endValue), e, this._pointLabels.length),
                s.closePath(),
                s.fillStyle = t,
                s.fill(),
                s.restore()
            }
        }
        drawGrid() {
            let t = this.ctx, e = this.options, {angleLines: s, grid: r} = e, a = this._pointLabels.length, l, u, d;
            if (e.pointLabels.display && vT(this, a),
            r.display && this.ticks.forEach( (p, b) => {
                if (b !== 0) {
                    u = this.getDistanceFromCenterForValue(p.value);
                    let E = r.setContext(this.getContext(b - 1));
                    bT(this, E, u, a)
                }
            }
            ),
            s.display) {
                for (t.save(),
                l = a - 1; l >= 0; l--) {
                    let p = s.setContext(this.getPointLabelContext(l))
                      , {color: b, lineWidth: E} = p;
                    !E || !b || (t.lineWidth = E,
                    t.strokeStyle = b,
                    t.setLineDash(p.borderDash),
                    t.lineDashOffset = p.borderDashOffset,
                    u = this.getDistanceFromCenterForValue(e.ticks.reverse ? this.min : this.max),
                    d = this.getPointPosition(l, u),
                    t.beginPath(),
                    t.moveTo(this.xCenter, this.yCenter),
                    t.lineTo(d.x, d.y),
                    t.stroke())
                }
                t.restore()
            }
        }
        drawBorder() {}
        drawLabels() {
            let t = this.ctx
              , e = this.options
              , s = e.ticks;
            if (!s.display)
                return;
            let r = this.getIndexAngle(0), a, l;
            t.save(),
            t.translate(this.xCenter, this.yCenter),
            t.rotate(r),
            t.textAlign = "center",
            t.textBaseline = "middle",
            this.ticks.forEach( (u, d) => {
                if (d === 0 && !e.reverse)
                    return;
                let p = s.setContext(this.getContext(d))
                  , b = ge(p.font);
                if (a = this.getDistanceFromCenterForValue(this.ticks[d].value),
                p.showLabelBackdrop) {
                    t.font = b.string,
                    l = t.measureText(u.label).width,
                    t.fillStyle = p.backdropColor;
                    let E = Me(p.backdropPadding);
                    t.fillRect(-l / 2 - E.left, -a - b.size / 2 - E.top, l + E.width, b.size + E.height)
                }
                Hn(t, u.label, 0, -a, b, {
                    color: p.color
                })
            }
            ),
            t.restore()
        }
        drawTitle() {}
    }
    ;
    Es.id = "radialLinear";
    Es.defaults = {
        display: !0,
        animate: !0,
        position: "chartArea",
        angleLines: {
            display: !0,
            lineWidth: 1,
            borderDash: [],
            borderDashOffset: 0
        },
        grid: {
            circular: !1
        },
        startAngle: 0,
        ticks: {
            showLabelBackdrop: !0,
            callback: ul.formatters.numeric
        },
        pointLabels: {
            backdropColor: void 0,
            backdropPadding: 2,
            display: !0,
            font: {
                size: 10
            },
            callback(n) {
                return n
            },
            padding: 5,
            centerPointLabels: !1
        }
    };
    Es.defaultRoutes = {
        "angleLines.color": "borderColor",
        "pointLabels.color": "color",
        "ticks.color": "color"
    };
    Es.descriptors = {
        angleLines: {
            _fallback: "grid"
        }
    };
    var hl = {
        millisecond: {
            common: !0,
            size: 1,
            steps: 1e3
        },
        second: {
            common: !0,
            size: 1e3,
            steps: 60
        },
        minute: {
            common: !0,
            size: 6e4,
            steps: 60
        },
        hour: {
            common: !0,
            size: 36e5,
            steps: 24
        },
        day: {
            common: !0,
            size: 864e5,
            steps: 30
        },
        week: {
            common: !1,
            size: 6048e5,
            steps: 4
        },
        month: {
            common: !0,
            size: 2628e6,
            steps: 12
        },
        quarter: {
            common: !1,
            size: 7884e6,
            steps: 4
        },
        year: {
            common: !0,
            size: 3154e7
        }
    }
      , Ue = Object.keys(hl);
    function _T(n, t) {
        return n - t
    }
    o(_T, "sorter");
    function Vg(n, t) {
        if (zt(t))
            return null;
        let e = n._adapter
          , {parser: s, round: r, isoWeekday: a} = n._parseOpts
          , l = t;
        return typeof s == "function" && (l = s(l)),
        fe(l) || (l = typeof s == "string" ? e.parse(l, s) : e.parse(l)),
        l === null ? null : (r && (l = r === "week" && (ms(a) || a === !0) ? e.startOf(l, "isoWeek", a) : e.startOf(l, r)),
        +l)
    }
    o(Vg, "parse");
    function Bg(n, t, e, s) {
        let r = Ue.length;
        for (let a = Ue.indexOf(n); a < r - 1; ++a) {
            let l = hl[Ue[a]]
              , u = l.steps ? l.steps : Number.MAX_SAFE_INTEGER;
            if (l.common && Math.ceil((e - t) / (u * l.size)) <= s)
                return Ue[a]
        }
        return Ue[r - 1]
    }
    o(Bg, "determineUnitForAutoTicks");
    function ET(n, t, e, s, r) {
        for (let a = Ue.length - 1; a >= Ue.indexOf(e); a--) {
            let l = Ue[a];
            if (hl[l].common && n._adapter.diff(r, s, l) >= t - 1)
                return l
        }
        return Ue[e ? Ue.indexOf(e) : 0]
    }
    o(ET, "determineUnitForFormatting");
    function ST(n) {
        for (let t = Ue.indexOf(n) + 1, e = Ue.length; t < e; ++t)
            if (hl[Ue[t]].common)
                return Ue[t]
    }
    o(ST, "determineMajorUnit");
    function Hg(n, t, e) {
        if (!e)
            n[t] = !0;
        else if (e.length) {
            let {lo: s, hi: r} = $a(e, t)
              , a = e[s] >= t ? e[s] : e[r];
            n[a] = !0
        }
    }
    o(Hg, "addTick");
    function TT(n, t, e, s) {
        let r = n._adapter, a = +r.startOf(t[0].value, s), l = t[t.length - 1].value, u, d;
        for (u = a; u <= l; u = +r.add(u, 1, s))
            d = e[u],
            d >= 0 && (t[d].major = !0);
        return t
    }
    o(TT, "setMajorTicks");
    function jg(n, t, e) {
        let s = [], r = {}, a = t.length, l, u;
        for (l = 0; l < a; ++l)
            u = t[l],
            r[u] = l,
            s.push({
                value: u,
                major: !1
            });
        return a === 0 || !e ? s : TT(n, s, r, e)
    }
    o(jg, "ticksFromTimestamps");
    var Ss = class extends ys {
        static{o(this, "TimeScale")
        }constructor(t) {
            super(t),
            this._cache = {
                data: [],
                labels: [],
                all: []
            },
            this._unit = "day",
            this._majorUnit = void 0,
            this._offsets = {},
            this._normalized = !1,
            this._parseOpts = void 0
        }
        init(t, e) {
            let s = t.time || (t.time = {})
              , r = this._adapter = new fE._date(t.adapters.date);
            r.init(e),
            sr(s.displayFormats, r.formats()),
            this._parseOpts = {
                parser: s.parser,
                round: s.round,
                isoWeekday: s.isoWeekday
            },
            super.init(t),
            this._normalized = e.normalized
        }
        parse(t, e) {
            return t === void 0 ? null : Vg(this, t)
        }
        beforeLayout() {
            super.beforeLayout(),
            this._cache = {
                data: [],
                labels: [],
                all: []
            }
        }
        determineDataLimits() {
            let t = this.options
              , e = this._adapter
              , s = t.time.unit || "day"
              , {min: r, max: a, minDefined: l, maxDefined: u} = this.getUserBounds();
            function d(p) {
                !l && !isNaN(p.min) && (r = Math.min(r, p.min)),
                !u && !isNaN(p.max) && (a = Math.max(a, p.max))
            }
            o(d, "_applyBounds"),
            (!l || !u) && (d(this._getLabelBounds()),
            (t.bounds !== "ticks" || t.ticks.source !== "labels") && d(this.getMinMax(!1))),
            r = fe(r) && !isNaN(r) ? r : +e.startOf(Date.now(), s),
            a = fe(a) && !isNaN(a) ? a : +e.endOf(Date.now(), s) + 1,
            this.min = Math.min(r, a - 1),
            this.max = Math.max(r + 1, a)
        }
        _getLabelBounds() {
            let t = this.getLabelTimestamps()
              , e = Number.POSITIVE_INFINITY
              , s = Number.NEGATIVE_INFINITY;
            return t.length && (e = t[0],
            s = t[t.length - 1]),
            {
                min: e,
                max: s
            }
        }
        buildTicks() {
            let t = this.options
              , e = t.time
              , s = t.ticks
              , r = s.source === "labels" ? this.getLabelTimestamps() : this._generate();
            t.bounds === "ticks" && r.length && (this.min = this._userMin || r[0],
            this.max = this._userMax || r[r.length - 1]);
            let a = this.min
              , l = this.max
              , u = Cp(r, a, l);
            return this._unit = e.unit || (s.autoSkip ? Bg(e.minUnit, this.min, this.max, this._getLabelCapacity(a)) : ET(this, u.length, e.minUnit, this.min, this.max)),
            this._majorUnit = !s.major.enabled || this._unit === "year" ? void 0 : ST(this._unit),
            this.initOffsets(r),
            t.reverse && u.reverse(),
            jg(this, u, this._majorUnit)
        }
        afterAutoSkip() {
            this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map(t => +t.value))
        }
        initOffsets(t) {
            let e = 0, s = 0, r, a;
            this.options.offset && t.length && (r = this.getDecimalForValue(t[0]),
            t.length === 1 ? e = 1 - r : e = (this.getDecimalForValue(t[1]) - r) / 2,
            a = this.getDecimalForValue(t[t.length - 1]),
            t.length === 1 ? s = a : s = (a - this.getDecimalForValue(t[t.length - 2])) / 2);
            let l = t.length < 3 ? .5 : .25;
            e = be(e, 0, l),
            s = be(s, 0, l),
            this._offsets = {
                start: e,
                end: s,
                factor: 1 / (e + 1 + s)
            }
        }
        _generate() {
            let t = this._adapter, e = this.min, s = this.max, r = this.options, a = r.time, l = a.unit || Bg(a.minUnit, e, s, this._getLabelCapacity(e)), u = It(a.stepSize, 1), d = l === "week" ? a.isoWeekday : !1, p = ms(d) || d === !0, b = {}, E = e, x, w;
            if (p && (E = +t.startOf(E, "isoWeek", d)),
            E = +t.startOf(E, p ? "day" : l),
            t.diff(s, e, l) > 1e5 * u)
                throw new Error(e + " and " + s + " are too far apart with stepSize of " + u + " " + l);
            let C = r.ticks.source === "data" && this.getDataTimestamps();
            for (x = E,
            w = 0; x < s; x = +t.add(x, u, l),
            w++)
                Hg(b, x, C);
            return (x === s || r.bounds === "ticks" || w === 1) && Hg(b, x, C),
            Object.keys(b).sort( (I, L) => I - L).map(I => +I)
        }
        getLabelForValue(t) {
            let e = this._adapter
              , s = this.options.time;
            return s.tooltipFormat ? e.format(t, s.tooltipFormat) : e.format(t, s.displayFormats.datetime)
        }
        _tickFormatFunction(t, e, s, r) {
            let a = this.options
              , l = a.time.displayFormats
              , u = this._unit
              , d = this._majorUnit
              , p = u && l[u]
              , b = d && l[d]
              , E = s[e]
              , x = d && b && E && E.major
              , w = this._adapter.format(t, r || (x ? b : p))
              , C = a.ticks.callback;
            return C ? ie(C, [w, e, s], this) : w
        }
        generateTickLabels(t) {
            let e, s, r;
            for (e = 0,
            s = t.length; e < s; ++e)
                r = t[e],
                r.label = this._tickFormatFunction(r.value, e, t)
        }
        getDecimalForValue(t) {
            return t === null ? NaN : (t - this.min) / (this.max - this.min)
        }
        getPixelForValue(t) {
            let e = this._offsets
              , s = this.getDecimalForValue(t);
            return this.getPixelForDecimal((e.start + s) * e.factor)
        }
        getValueForPixel(t) {
            let e = this._offsets
              , s = this.getDecimalForPixel(t) / e.factor - e.end;
            return this.min + s * (this.max - this.min)
        }
        _getLabelSize(t) {
            let e = this.options.ticks
              , s = this.ctx.measureText(t).width
              , r = _i(this.isHorizontal() ? e.maxRotation : e.minRotation)
              , a = Math.cos(r)
              , l = Math.sin(r)
              , u = this._resolveTickFontOptions(0).size;
            return {
                w: s * a + u * l,
                h: s * l + u * a
            }
        }
        _getLabelCapacity(t) {
            let e = this.options.time
              , s = e.displayFormats
              , r = s[e.unit] || s.millisecond
              , a = this._tickFormatFunction(t, 0, jg(this, [t], this._majorUnit), r)
              , l = this._getLabelSize(a)
              , u = Math.floor(this.isHorizontal() ? this.width / l.w : this.height / l.h) - 1;
            return u > 0 ? u : 1
        }
        getDataTimestamps() {
            let t = this._cache.data || [], e, s;
            if (t.length)
                return t;
            let r = this.getMatchingVisibleMetas();
            if (this._normalized && r.length)
                return this._cache.data = r[0].controller.getAllParsedValues(this);
            for (e = 0,
            s = r.length; e < s; ++e)
                t = t.concat(r[e].controller.getAllParsedValues(this));
            return this._cache.data = this.normalize(t)
        }
        getLabelTimestamps() {
            let t = this._cache.labels || [], e, s;
            if (t.length)
                return t;
            let r = this.getLabels();
            for (e = 0,
            s = r.length; e < s; ++e)
                t.push(Vg(this, r[e]));
            return this._cache.labels = this._normalized ? t : this.normalize(t)
        }
        normalize(t) {
            return Lh(t.sort(_T))
        }
    }
    ;
    Ss.id = "time";
    Ss.defaults = {
        bounds: "data",
        adapters: {},
        time: {
            parser: !1,
            unit: !1,
            round: !1,
            isoWeekday: !1,
            minUnit: "millisecond",
            displayFormats: {}
        },
        ticks: {
            source: "auto",
            major: {
                enabled: !1
            }
        }
    };
    function il(n, t, e) {
        let s = 0, r = n.length - 1, a, l, u, d;
        e ? (t >= n[s].pos && t <= n[r].pos && ({lo: s, hi: r} = zi(n, "pos", t)),
        {pos: a, time: u} = n[s],
        {pos: l, time: d} = n[r]) : (t >= n[s].time && t <= n[r].time && ({lo: s, hi: r} = zi(n, "time", t)),
        {time: a, pos: u} = n[s],
        {time: l, pos: d} = n[r]);
        let p = l - a;
        return p ? u + (d - u) * (t - a) / p : u
    }
    o(il, "interpolate");
    var Ro = class extends Ss {
        static{o(this, "TimeSeriesScale")
        }constructor(t) {
            super(t),
            this._table = [],
            this._minPos = void 0,
            this._tableRange = void 0
        }
        initOffsets() {
            let t = this._getTimestampsForTable()
              , e = this._table = this.buildLookupTable(t);
            this._minPos = il(e, this.min),
            this._tableRange = il(e, this.max) - this._minPos,
            super.initOffsets(t)
        }
        buildLookupTable(t) {
            let {min: e, max: s} = this, r = [], a = [], l, u, d, p, b;
            for (l = 0,
            u = t.length; l < u; ++l)
                p = t[l],
                p >= e && p <= s && r.push(p);
            if (r.length < 2)
                return [{
                    time: e,
                    pos: 0
                }, {
                    time: s,
                    pos: 1
                }];
            for (l = 0,
            u = r.length; l < u; ++l)
                b = r[l + 1],
                d = r[l - 1],
                p = r[l],
                Math.round((b + d) / 2) !== p && a.push({
                    time: p,
                    pos: l / (u - 1)
                });
            return a
        }
        _getTimestampsForTable() {
            let t = this._cache.all || [];
            if (t.length)
                return t;
            let e = this.getDataTimestamps()
              , s = this.getLabelTimestamps();
            return e.length && s.length ? t = this.normalize(e.concat(s)) : t = e.length ? e : s,
            t = this._cache.all = t,
            t
        }
        getDecimalForValue(t) {
            return (il(this._table, t) - this._minPos) / this._tableRange
        }
        getValueForPixel(t) {
            let e = this._offsets
              , s = this.getDecimalForPixel(t) / e.factor - e.end;
            return il(this._table, s * this._tableRange + this._minPos, !0)
        }
    }
    ;
    Ro.id = "timeseries";
    Ro.defaults = Ss.defaults;
    var xT = Object.freeze({
        __proto__: null,
        CategoryScale: Er,
        LinearScale: Do,
        LogarithmicScale: Po,
        RadialLinearScale: Es,
        TimeScale: Ss,
        TimeSeriesScale: Ro
    })
      , am = [dE, yS, sT, xT];
    _s.register(...am);
    var lm = _s;
    var Td = class extends vt {
        static{o(this, "default")
        }static targets = ["graph", "description"];
        static values = {
            data: Array,
            selectedKey: String,
            color: String
        };
        chart = null;
        connect() {
            if (super.connect(),
            !this.hasDataValue)
                throw "you must pass a data-value to the controller";
            if (!this.dataValue[0])
                throw "data-value is empty";
            if (this.dataValue[0].value == null)
                throw 'data-value must contain entries with a "value" property';
            if (this.dataValue[0].label == null)
                throw 'data-value must contain entries with a "label" property';
            if (this.colorValue || (this.colorValue = "#0b62a4"),
            this.dataValue[0].key == null && (this.dataValue = this.dataValue.map( (n, t) => ({
                ...n,
                key: t
            }))),
            !this.selectedKeyValue) {
                let n = Math.max(...this.dataValue.map(t => t.value));
                this.selectedKeyValue = this.dataValue.find(t => t.value == n).key
            }
            this.chart = this.setupChart(),
            this.descriptionTargets.forEach(n => {
                let t = o(e => {
                    e.preventDefault(),
                    this.setSelectedKeyValueChanged(n.dataset.sectionsChartKey)
                }
                , "listener");
                n.addEventListener("click", t),
                n.addEventListener("mouseenter", t)
            }
            )
        }
        setSelectedKeyValueChanged(n) {
            this.selectedKeyValue = n
        }
        selectedKeyValueChanged() {
            this.triggerChartHover(),
            this.triggerDescriptionHighlight()
        }
        triggerChartHover() {
            if (!this.chart) {
                setTimeout( () => this.triggerChartHover(), 0);
                return
            }
            let n = this.dataValue.findIndex(t => t.key == this.selectedKeyValue);
            n < 0 ? this.chart.setActiveElements([]) : this.chart.setActiveElements([{
                datasetIndex: 0,
                index: n
            }]),
            this.chart.update()
        }
        triggerDescriptionHighlight() {
            this.descriptionTargets.forEach(n => {
                n.dataset.sectionsChartKey == this.selectedKeyValue ? n.classList.add("selected") : n.classList.remove("selected")
            }
            )
        }
        setupChart() {
            let s = {
                type: "doughnut",
                data: {
                    labels: this.dataValue.map(r => r.label),
                    datasets: [{
                        data: this.dataValue.map(r => r.value),
                        backgroundColor: this.dataValue[0].color ? this.dataValue.map(r => r.color) : this.colorArray("#0b62a4", this.dataValue.length)
                    }]
                },
                options: {
                    hoverOffset: 20,
                    maintainAspectRatio: !1,
                    layout: {
                        padding: {
                            bottom: 20,
                            top: 20
                        }
                    },
                    cutout: "70%",
                    borderWidth: 2,
                    borderColor: "#FFF",
                    hoverBorderColor: "#FFF",
                    plugins: {
                        legend: {
                            display: !1
                        },
                        tooltip: {
                            enabled: !1
                        }
                    },
                    events: ["mousemove", "click", "touchstart", "touchmove"],
                    interaction: {
                        mode: "nearest",
                        intersect: !1,
                        axis: "r"
                    },
                    onHover: o( (r, a) => {
                        let l = a[0];
                        l && this.setSelectedKeyValueChanged(this.dataValue[l.index].key)
                    }
                    , "graphHoverListener")
                },
                plugins: [{
                    id: "centerLabel",
                    afterDatasetsDraw: this.drawCenterText.bind(this)
                }]
            };
            return new lm(this.graphTarget,s)
        }
        colorArray(n, t) {
            let e = o(u => {
                let d = u.slice(u.startsWith("#") ? 1 : 0);
                return d = parseInt(d, 16),
                [d >>> 16, (d & 65280) >> 8, d & 255]
            }
            , "hexToRgb")
              , s = o(u => "#" + ((u[0] << 16) + (u[1] << 8) + u[2]).toString(16).padStart(6, "0"), "rgbToHex")
              , r = e(n)
              , l = Math.pow(10, 1 / t);
            return [...Array(t).keys()].map(u => {
                let d = Math.pow(l, u);
                return [255 - parseInt((255 - [0]) / d), 255 - parseInt((255 - r[1]) / d), 255 - parseInt((255 - r[2]) / d)]
            }
            ).map(u => s(u))
        }
        drawCenterText(n, t, e) {
            let s = n._active[0];
            if (s) {
                let r = n.ctx
                  , a = this.dataValue[s.index]
                  , l = a.label.trim().replace(/(\s+)/, " ")
                  , u = a.valueFormatted || a.value
                  , d = s.element.x
                  , p = s.element.y
                  , b = 12
                  , E = 20
                  , x = 2 * s.element.innerRadius - 20;
                r.font = `${b}px arial`;
                let w = r.measureText(l).width
                  , C = [l];
                w > x && l.indexOf(" ") > 1 && (C = l.split(" "),
                w = Math.max(...C.map(F => r.measureText(F).width)));
                let I = x / w * b;
                I = Math.max(b, Math.min(E, I));
                let L = x * .2;
                r.textAlign = "center",
                r.textBaseline = "bottom",
                r.font = `${I}px arial`,
                r.fillStyle = "#222";
                let k = p;
                C.reverse().forEach(F => {
                    r.fillText(F, d, k),
                    k -= I
                }
                ),
                r.textBaseline = "top",
                r.font = `bold ${L}px arial`,
                r.fillText(u, d, p)
            }
        }
    }
    ;
    var Cd = {};
    Rt(Cd, {
        default: () => wd
    });
    var wd = class extends vt {
        static{o(this, "default")
        }static targets = ["options", "radio"];
        connect() {
            super.connect()
        }
        update() {
            let n = Array.from(this.radioTarget.querySelectorAll("input[type=radio]")).find(s => s.checked).value, t, e = [];
            n === "true" ? (t = JSON.parse(this.data.get("estimation")),
            t.forEach(s => e.push('<option value="' + s[1] + '">' + s[0].replace("(kWh)", "") + "</option>"))) : (t = JSON.parse(this.data.get("complete")),
            t.forEach(s => e.push('<option value="' + s[1] + '">' + s[0] + "</option>"))),
            this.optionsTarget.innerHTML = e.join(" ")
        }
    }
    ;
    var kd = {};
    Rt(kd, {
        default: () => Ad
    });
    var Ad = class extends vt {
        static{o(this, "default")
        }static targets = ["seasonYear", "reportedPeriod"];
        static values = {
            labelYear: String,
            labelSeason: String,
            yearOption: String
        };
        connect() {
            super.connect(),
            this.update()
        }
        update() {
            this.seasonYearTarget.value == this.yearOptionValue ? (this.reportedPeriodTarget.querySelector("label > span").innerHTML = this.labelYearValue,
            this.reportedPeriodTarget.querySelectorAll("select > option").forEach(n => {
                n.innerHTML = parseInt(n.innerHTML)
            }
            )) : (this.reportedPeriodTarget.querySelector("label > span").innerHTML = this.labelSeasonValue,
            this.reportedPeriodTarget.querySelectorAll("select > option").forEach(n => {
                let t = parseInt(n.innerHTML);
                n.innerHTML = `${t}/${t + 1}`
            }
            ))
        }
    }
    ;
    var Od = {};
    Rt(Od, {
        default: () => Md
    });
    var Md = class extends vt {
        static{o(this, "default")
        }static values = {
            changed: Boolean,
            message: String
        };
        leavingPage(n) {
            if (this.changedValue)
                if (n.type == "turbolinks:before-visit")
                    window.confirm(this.messageValue) || n.preventDefault();
                else
                    return n.returnValue = this.messageValue,
                    n.returnValue
        }
        allowFormSubmission(n) {
            this.changedValue = !1
        }
        formIsChanged(n) {
            this.changedValue = !0
        }
    }
    ;
    var Dd = {};
    Rt(Dd, {
        default: () => Ld
    });
    var Ld = class extends vt {
        static{o(this, "default")
        }static targets = ["collapse", "zettelIconBtn", "collapseCloseBtn"];
        boxShow() {
            this.collapseCloseBtnTarget.removeAttribute("hidden"),
            this.zettelIconBtnTargets.forEach(n => n.classList.add("invisible")),
            this.element.classList.add("mobile-full-height")
        }
        boxHide() {
            this.collapseCloseBtnTarget.setAttribute("hidden", !0),
            this.zettelIconBtnTargets.forEach(n => n.classList.remove("invisible")),
            this.element.classList.remove("mobile-full-height")
        }
        closeAll() {
            this.collapseTargets.forEach(n => {
                new window.bootstrap.Collapse(n,{
                    toggle: !1
                }).hide()
            }
            )
        }
    }
    ;
    var wT = [{
        name: "..--controllers--admin--carbon-projects--cpm-show",
        module: ou,
        filename: "../controllers/admin/carbon_projects/cpm_show_controller.js"
    }, {
        name: "..--controllers--admin--input-value",
        module: au,
        filename: "../controllers/admin/input_value_controller.js"
    }, {
        name: "..--controllers--admin--label",
        module: cu,
        filename: "../controllers/admin/label_controller.js"
    }, {
        name: "..--controllers--admin--multiple-reservations-editor",
        module: hu,
        filename: "../controllers/admin/multiple_reservations_editor_controller.js"
    }, {
        name: "..--controllers--admin--new-rebooking",
        module: fu,
        filename: "../controllers/admin/new_rebooking_controller.js"
    }, {
        name: "..--controllers--admin--orders--country-input",
        module: gu,
        filename: "../controllers/admin/orders/country_input_controller.js"
    }, {
        name: "..--controllers--admin--orders--partner-string-input",
        module: vu,
        filename: "../controllers/admin/orders/partner_string_input_controller.js"
    }, {
        name: "..--controllers--admin--prima-reservations",
        module: yu,
        filename: "../controllers/admin/prima_reservations_controller.js"
    }, {
        name: "..--controllers--admin--reservation-filter",
        module: Eu,
        filename: "../controllers/admin/reservation_filter_controller.js"
    }, {
        name: "..--controllers--admin--reservations--split-multi",
        module: Tu,
        filename: "../controllers/admin/reservations/split_multi_controller.js"
    }, {
        name: "..--controllers--admin--reservations--split-single",
        module: wu,
        filename: "../controllers/admin/reservations/split_single_controller.js"
    }, {
        name: "..--controllers--admin--select-all",
        module: Au,
        filename: "../controllers/admin/select_all_controller.js"
    }, {
        name: "..--controllers--admin--separate-group-selection",
        module: Mu,
        filename: "../controllers/admin/separate_group_selection_controller.js"
    }, {
        name: "..--controllers--admin--simple-filter",
        module: Lu,
        filename: "../controllers/admin/simple_filter_controller.js"
    }, {
        name: "..--controllers--admin--sites--form",
        module: Pu,
        filename: "../controllers/admin/sites/form_controller.js"
    }, {
        name: "..--controllers--admin--textarea-autoheight",
        module: Iu,
        filename: "../controllers/admin/textarea_autoheight_controller.js"
    }, {
        name: "..--controllers--airport-autocomplete",
        module: Fu,
        filename: "../controllers/airport_autocomplete_controller.js"
    }, {
        name: "..--controllers--application",
        module: su,
        filename: "../controllers/application_controller.js"
    }, {
        name: "..--controllers--calculation-drafts--list",
        module: Bu,
        filename: "../controllers/calculation_drafts/list_controller.js"
    }, {
        name: "..--controllers--car-fuel-consumption",
        module: ju,
        filename: "../controllers/car_fuel_consumption_controller.js"
    }, {
        name: "..--controllers--car-fuel-variant",
        module: $u,
        filename: "../controllers/car_fuel_variant_controller.js"
    }, {
        name: "..--controllers--carousel",
        module: zu,
        filename: "../controllers/carousel_controller.js"
    }, {
        name: "..--controllers--clear-input",
        module: Ku,
        filename: "../controllers/clear_input_controller.js"
    }, {
        name: "..--controllers--copy-to-clipboard",
        module: Xu,
        filename: "../controllers/copy_to_clipboard_controller.js"
    }, {
        name: "..--controllers--custom-increment",
        module: Qu,
        filename: "../controllers/custom_increment_controller.js"
    }, {
        name: "..--controllers--dfb-calculator--note",
        module: Zu,
        filename: "../controllers/dfb_calculator/note_controller.js"
    }, {
        name: "..--controllers--dfb-calculator--parallax",
        module: eh,
        filename: "../controllers/dfb_calculator/parallax_controller.js"
    }, {
        name: "..--controllers--dfb-calculator--regional-association",
        module: nh,
        filename: "../controllers/dfb_calculator/regional_association_controller.js"
    }, {
        name: "..--controllers--dfb-calculator--result-svg",
        module: rh,
        filename: "../controllers/dfb_calculator/result_svg_controller.js"
    }, {
        name: "..--controllers--disable",
        module: lh,
        filename: "../controllers/disable_controller.js"
    }, {
        name: "..--controllers--header-scroll",
        module: uh,
        filename: "../controllers/header_scroll_controller.js"
    }, {
        name: "..--controllers--percent-sum",
        module: dh,
        filename: "../controllers/percent_sum_controller.js"
    }, {
        name: "..--controllers--post-json",
        module: ph,
        filename: "../controllers/post_json_controller.js"
    }, {
        name: "..--controllers--rotary-club-calculator--new-event",
        module: mh,
        filename: "../controllers/rotary_club_calculator/new_event_controller.js"
    }, {
        name: "..--controllers--sections-chart",
        module: xd,
        filename: "../controllers/sections_chart_controller.js"
    }, {
        name: "..--controllers--select-collection",
        module: Cd,
        filename: "../controllers/select_collection_controller.js"
    }, {
        name: "..--controllers--sports-club-calculator--reported-period-input",
        module: kd,
        filename: "../controllers/sports_club_calculator/reported_period_input_controller.js"
    }, {
        name: "..--controllers--toggle",
        module: oh,
        filename: "../controllers/toggle_controller.js"
    }, {
        name: "..--controllers--unsaved-changes",
        module: Od,
        filename: "../controllers/unsaved_changes_controller.js"
    }, {
        name: "..--controllers--zettel-box",
        module: Dd,
        filename: "../controllers/zettel_box_controller.js"
    }]
      , cm = wT;
    hm();
    dm();
    fm();
    gm();
    mm();
    var dl = ka.start();
    cm.forEach(n => {
        dl.register(n.name.replace(/^.*?controllers--/, ""), n.module.default)
    }
    );
    dl.register("autocomplete", hs);
    window.addEventListener("pageshow", n => {
        dl.controllers.forEach(t => {
            typeof t.pageShow == "function" && t.pageShow(n.persisted)
        }
        )
    }
    );
    window.addEventListener("pagehide", () => {
        dl.controllers.forEach(n => {
            typeof n.pageHide == "function" && n.pageHide()
        }
        )
    }
    );
}
)();
/*! Bundled license information:

jquery/dist/jquery.js:
  (*!
   * jQuery JavaScript Library v3.7.1
   * https://jquery.com/
   *
   * Copyright OpenJS Foundation and other contributors
   * Released under the MIT license
   * https://jquery.org/license
   *
   * Date: 2023-08-28T13:37Z
   *)

popper.js/dist/umd/popper.js:
  (**!
   * @fileOverview Kickass library to create and place poppers near their reference elements.
   * @version 1.16.1
   * @license
   * Copyright (c) 2016 Federico Zivolo and contributors
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   *)

bootstrap/dist/js/bootstrap.js:
  (*!
    * Bootstrap v4.6.0 (https://getbootstrap.com/)
    * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
    * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
    *)

@hotwired/turbo/dist/turbo.es2017-esm.js:
  (*!
  Turbo 8.0.13
  Copyright © 2025 37signals LLC
   *)

chart.js/dist/chunks/helpers.segment.mjs:
chart.js/dist/chart.mjs:
  (*!
   * Chart.js v3.9.1
   * https://www.chartjs.org
   * (c) 2022 Chart.js Contributors
   * Released under the MIT License
   *)

chart.js/dist/chunks/helpers.segment.mjs:
  (*!
   * @kurkle/color v0.2.1
   * https://github.com/kurkle/color#readme
   * (c) 2022 Jukka Kurkela
   * Released under the MIT License
   *)
*/
